<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>

    <title>JavaScript高级程序设计（第4版）</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" type="text/css" href="../stylesheet.css"/>
    <link rel="stylesheet" type="text/css" href="../page_styles.css"/>

    <link href="../calibreHtmlOutBasicCss.css" type="text/css" rel="stylesheet"/>

  </head>
  <body>

    <div class="calibreMeta">
      <div class="calibreMetaTitle">

        <h1>
          <a href="../../54m0dfqx.html">JavaScript高级程序设计（第4版）
          </a>
        </h1>

      </div>
      <div class="calibreMetaAuthor">
        [美] 马特 • 弗里斯比

      </div>
    </div>

    <div class="calibreMain">

      <div class="calibreEbookContent">

        <div class="calibreEbNavTop">

          <a href="part0060.html" class="calibreAPrev">上一页
          </a>

          <a href="part0062.html" class="calibreANext">下一页
          </a>

        </div>

        <h2 id="nav_point_175" class="calibre9">8.2 创建对象</h2>
        <p class="calibre1">虽然使用<code class="calibre11">Object</code>构造函数或对象字面量可以方便地创建对象，但这些方式也有明显不足：创建具有同样接口的多个对象需要重复编写很多代码。</p>
        <h3 id="nav_point_176" class="calibre15">8.2.1 概述</h3>
        <p class="calibre1">综观ECMAScript规范的历次发布，每个版本的特性似乎都出人意料。ECMAScript 5.1并没有正式支持面向对象的结构，比如类或继承。但是，正如接下来几节会介绍的，巧妙地运用原型式继承可以成功地模拟同样的行为。</p>
        <p class="calibre1">ECMAScript 6开始正式支持类和继承。ES6的类旨在完全涵盖之前规范设计的基于原型的继承模式。不过，无论从哪方面看，ES6的类都仅仅是封装了ES5.1构造函数加原型继承的语法糖而已。</p>
        <blockquote class="calibre13">
          <p class="calibre1">
            <strong class="calibre2">注意</strong>
            不要误会：采用面向对象编程模式的JavaScript代码还是应该使用ECMAScript 6的类。但不管怎么说，理解ES6类出现之前的惯例总是有益无害的。特别是ES6的类定义本身就相当于对原有结构的封装。因此，在介绍ES6的类之前，本书会循序渐进地介绍被类取代的那些底层概念。</p>
        </blockquote>
        <h3 id="nav_point_177" class="calibre15">8.2.2 工厂模式</h3>
        <p class="calibre1">工厂模式是一种众所周知的设计模式，广泛应用于软件工程领域，用于抽象创建特定对象的过程。（本书后面还会讨论其他设计模式及其在JavaScript中的实现。）下面的例子展示了一种按照特定接口创建对象的方式：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">function createperson(name, age, job) {
  let o = new object();
  o.name = name;
  o.age = age;
  o.job = job;
  o.sayname = function() {
    console.log(this.name);
  };
  return o;
}

let person1 = createperson("nicholas", 29, "software engineer");
let person2 = createperson("greg", 27, "doctor");</code></pre>
        <p class="calibre1">这里，函数<code class="calibre11">createPerson()</code>接收3个参数，根据这几个参数构建了一个包含<code class="calibre11">Person</code>信息的对象。可以用不同的参数多次调用这个函数，每次都会返回包含3个属性和1个方法的对象。这种工厂模式虽然可以解决创建多个类似对象的问题，但没有解决对象标识问题（即新创建的对象是什么类型）。</p>
        <h3 id="nav_point_178" class="calibre15">8.2.3 构造函数模式</h3>
        <p class="calibre1">前面几章提到过，ECMAScript中的构造函数是用于创建特定类型对象的。像<code class="calibre11">Object</code>和<code class="calibre11">Array</code>这样的原生构造函数，运行时可以直接在执行环境中使用。当然也可以自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。</p>
        <p class="calibre1">比如，前面的例子使用构造函数模式可以这样写：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">function person(name, age, job){
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayname = function() {
    console.log(this.name);
  };
}

let person1 = new person("nicholas", 29, "software engineer");
let person2 = new person("greg", 27, "doctor");

person1.sayname();  // nicholas
person2.sayname();  // greg</code></pre>
        <p class="calibre1">在这个例子中，<code class="calibre11">Person()</code>构造函数代替了<code class="calibre11">createPerson()</code>工厂函数。实际上，<code class="calibre11">Person()</code>内部的代码跟<code class="calibre11">createPerson()</code>基本是一样的，只是有如下区别。</p>
        <ul class="calibre10">
          <li class="di_1ji_wu_xu_lie_biao">没有显式地创建对象。</li>
          <li class="di_1ji_wu_xu_lie_biao">属性和方法直接赋值给了<code class="calibre11">this</code>。</li>
          <li class="di_1ji_wu_xu_lie_biao">没有<code class="calibre11">return</code>。</li>
        </ul>
        <p class="calibre1">另外，要注意函数名<code class="calibre11">Person</code>的首字母大写了。按照惯例，构造函数名称的首字母都是要大写的，非构造函数则以小写字母开头。这是从面向对象编程语言那里借鉴的，有助于在ECMAScript中区分构造函数和普通函数。毕竟ECMAScript的构造函数就是能创建对象的函数。</p>
        <p class="calibre1">要创建<code class="calibre11">Person</code>的实例，应使用<code class="calibre11">new</code>操作符。以这种方式调用构造函数会执行如下操作。</p>
        <p class="calibre1">(1) 在内存中创建一个新对象。</p>
        <p class="calibre1">(2) 这个新对象内部的<code class="calibre11">[[Prototype]]</code>特性被赋值为构造函数的<code class="calibre11">prototype</code>属性。</p>
        <p class="calibre1">(3) 构造函数内部的<code class="calibre11">this</code>被赋值为这个新对象（即<code class="calibre11">this</code>指向新对象）。</p>
        <p class="calibre1">(4) 执行构造函数内部的代码（给新对象添加属性）。</p>
        <p class="calibre1">(5) 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</p>
        <p class="calibre1">上一个例子的最后，<code class="calibre11">person1</code>和<code class="calibre11">person2</code>分别保存着<code class="calibre11">Person</code>的不同实例。这两个对象都有一个<code class="calibre11">constructor</code>属性指向<code class="calibre11">Person</code>，如下所示：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">console.log(person1.constructor == person);  // true
console.log(person2.constructor == person);  // true</code></pre>
        <p class="calibre1">
          <code class="calibre11">constructor</code>本来是用于标识对象类型的。不过，一般认为<code class="calibre11">instanceof</code>操作符是确定对象类型更可靠的方式。前面例子中的每个对象都是<code class="calibre11">Object</code>的实例，同时也是<code class="calibre11">Person</code>的实例，如下面调用<code class="calibre11">instanceof</code>操作符的结果所示：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">console.log(person1 instanceof object);  // true
console.log(person1 instanceof person);  // true
console.log(person2 instanceof object);  // true
console.log(person2 instanceof person);  // true</code></pre>
        <p class="calibre1">定义自定义构造函数可以确保实例被标识为特定类型，相比于工厂模式，这是一个很大的好处。在这个例子中，<code class="calibre11">person1</code>和<code class="calibre11">person2</code>之所以也被认为是<code class="calibre11">Object</code>的实例，是因为所有自定义对象都继承自<code class="calibre11">Object</code>（后面再详细讨论这一点）。</p>
        <p class="calibre1">构造函数不一定要写成函数声明的形式。赋值给变量的函数表达式也可以表示构造函数：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let person = function(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayname = function() {
    console.log(this.name);
  };
}

let person1 = new person("nicholas", 29, "software engineer");
let person2 = new person("greg", 27, "doctor");

person1.sayname();  // nicholas
person2.sayname();  // greg

console.log(person1 instanceof object);  // true
console.log(person1 instanceof person);  // true
console.log(person2 instanceof object);  // true
console.log(person2 instanceof person);  // true</code></pre>
        <p class="calibre1">在实例化时，如果不想传参数，那么构造函数后面的括号可加可不加。只要有<code class="calibre11">new</code>操作符，就可以调用相应的构造函数：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">function person() {
  this.name = "jake";
  this.sayname = function() {
    console.log(this.name);
  };
}

let person1 = new person();
let person2 = new person;

person1.sayname();  // jake
person2.sayname();  // jake

console.log(person1 instanceof object);  // true
console.log(person1 instanceof person);  // true
console.log(person2 instanceof object);  // true
console.log(person2 instanceof person);  // true</code></pre>
        <ol class="calibre16">
          <li value="1" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">构造函数也是函数</strong>
            </p>
            <p class="calibre1">构造函数与普通函数唯一的区别就是调用方式不同。除此之外，构造函数也是函数。并没有把某个函数定义为构造函数的特殊语法。任何函数只要使用<code class="calibre11">new</code>操作符调用就是构造函数，而不使用<code class="calibre11">new</code>操作符调用的函数就是普通函数。比如，前面的例子中定义的<code class="calibre11">Person()</code>可以像下面这样调用：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">// 作为构造函数
let person = new person("nicholas", 29, "software engineer");
person.sayname();    // "nicholas"

// 作为函数调用
person("greg", 27, "doctor");   // 添加到window对象
window.sayname();    // "greg"

// 在另一个对象的作用域中调用
let o = new object();
person.call(o, "kristen", 25, "nurse");
o.sayname();   // "kristen"</code></pre>
            <p class="calibre1">这个例子一开始展示了典型的构造函数调用方式，即使用<code class="calibre11">new</code>操作符创建一个新对象。然后是普通函数的调用方式，这时候没有使用<code class="calibre11">new</code>操作符调用<code class="calibre11">Person()</code>，结果会将属性和方法添加到<code class="calibre11">window</code>对象。这里要记住，在调用一个函数而没有明确设置<code class="calibre11">this</code>值的情况下（即没有作为对象的方法调用，或者没有使用<code class="calibre11">call()</code>/<code class="calibre11">apply()</code>调用），<code class="calibre11">this</code>始终指向<code class="calibre11">Global</code>对象（在浏览器中就是<code class="calibre11">window</code>对象）。因此在上面的调用之后，<code class="calibre11">window</code>对象上就有了一个<code class="calibre11">sayName()</code>方法，调用它会返回<code class="calibre11">"Greg"</code>。最后展示的调用方式是通过<code class="calibre11">call()</code>（或<code class="calibre11">apply()</code>）调用函数，同时将特定对象指定为作用域。这里的调用将对象<code class="calibre11">o</code>指定为<code class="calibre11">Person()</code>内部的<code class="calibre11">this</code>值，因此执行完函数代码后，所有属性和<code class="calibre11">sayName()</code>方法都会添加到对象<code class="calibre11">o</code>上面。<br class="calibre4"/>
            </p>
          </li>
          <li value="2" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">构造函数的问题</strong>
            </p>
            <p class="calibre1">构造函数虽然有用，但也不是没有问题。构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍。因此对前面的例子而言，<code class="calibre11">person1</code>和<code class="calibre11">person2</code>都有名为<code class="calibre11">sayName()</code>的方法，但这两个方法不是同一个<code class="calibre11">Function</code>实例。我们知道，ECMAScript中的函数是对象，因此每次定义函数时，都会初始化一个对象。逻辑上讲，这个构造函数实际上是这样的：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">function person(name, age, job){
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayname = new function("console.log(this.name)"); // 逻辑等价
}</code></pre>
            <p class="calibre1">这样理解这个构造函数可以更清楚地知道，每个<code class="calibre11">Person</code>实例都会有自己的<code class="calibre11">Function</code>实例用于显示<code class="calibre11">name</code>属性。当然了，以这种方式创建函数会带来不同的作用域链和标识符解析。但创建新<code class="calibre11">Function</code>实例的机制是一样的。因此不同实例上的函数虽然同名却不相等，如下所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">console.log(person1.sayname == person2.sayname); // false</code></pre>
            <p class="calibre1">因为都是做一样的事，所以没必要定义两个不同的<code class="calibre11">Function</code>实例。况且，<code class="calibre11">this</code>对象可以把函数与对象的绑定推迟到运行时。</p>
            <p class="calibre1">要解决这个问题，可以把函数定义转移到构造函数外部：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">function person(name, age, job){
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayname = sayname;
}

function sayname() {
  console.log(this.name);
}

let person1 = new person("nicholas", 29, "software engineer");
let person2 = new person("greg", 27, "doctor");

person1.sayname();  // nicholas
person2.sayname();  // greg</code></pre>
            <p class="calibre1">在这里，<code class="calibre11">sayName()</code>被定义在了构造函数外部。在构造函数内部，<code class="calibre11">sayName</code>属性等于全局<code class="calibre11">sayName()</code>函数。因为这一次<code class="calibre11">sayName</code>属性中包含的只是一个指向外部函数的指针，所以<code class="calibre11">person1</code>和<code class="calibre11">person2</code>共享了定义在全局作用域上的<code class="calibre11">sayName()</code>函数。这样虽然解决了相同逻辑的函数重复定义的问题，但全局作用域也因此被搞乱了，因为那个函数实际上只能在一个对象上调用。如果这个对象需要多个方法，那么就要在全局作用域中定义多个函数。这会导致自定义类型引用的代码不能很好地聚集一起。这个新问题可以通过原型模式来解决。</p>
          </li>
        </ol>
        <h3 id="nav_point_179" class="calibre15">8.2.4 原型模式</h3>
        <p class="calibre1">每个函数都会创建一个<code class="calibre11">prototype</code>属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型，如下所示：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">function person() {}

person.prototype.name = "nicholas";
person.prototype.age = 29;
person.prototype.job = "software engineer";
person.prototype.sayname = function() {
  console.log(this.name);
};

let person1 = new person();
person1.sayname(); // "nicholas"

let person2 = new person();
person2.sayname(); // "nicholas"

console.log(person1.sayname == person2.sayname); // true</code></pre>
        <p class="calibre1">使用函数表达式也可以：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let person = function() {};

person.prototype.name = "nicholas";
person.prototype.age = 29;
person.prototype.job = "software engineer";
person.prototype.sayname = function() {
  console.log(this.name);
};

let person1 = new person();
person1.sayname();   // "nicholas"

let person2 = new person();
person2.sayname();   // "nicholas"

console.log(person1.sayname == person2.sayname); // true</code></pre>
        <p class="calibre1">这里，所有属性和<code class="calibre11">sayName()</code>方法都直接添加到了<code class="calibre11">Person</code>的<code class="calibre11">prototype</code>属性上，构造函数体中什么也没有。但这样定义之后，调用构造函数创建的新对象仍然拥有相应的属性和方法。与构造函数模式不同，使用这种原型模式定义的属性和方法是由所有实例共享的。因此<code class="calibre11">person1</code>和<code class="calibre11">person2</code>访问的都是相同的属性和相同的<code class="calibre11">sayName()</code>函数。要理解这个过程，就必须理解ECMAScript中原型的本质。</p>
        <ol class="calibre16">
          <li value="1" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">理解原型</strong>
            </p>
            <p class="calibre1">无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个<code class="calibre11">prototype</code>属性（指向原型对象）。默认情况下，所有原型对象自动获得一个名为<code class="calibre11">constructor</code>的属性，指回与之关联的构造函数。对前面的例子而言，<code class="calibre11">Person.prototype.constructor</code>指向<code class="calibre11">Person</code>。然后，因构造函数而异，可能会给原型对象添加其他属性和方法。</p>
            <p class="calibre1">在自定义构造函数时，原型对象默认只会获得<code class="calibre11">constructor</code>属性，其他的所有方法都继承自<code class="calibre11">Object</code>。每次调用构造函数创建一个新实例，这个实例的内部<code class="calibre11">[[Prototype]]</code>指针就会被赋值为构造函数的原型对象。脚本中没有访问这个<code class="calibre11">[[Prototype]]</code>特性的标准方式，但Firefox、Safari和Chrome会在每个对象上暴露<code class="calibre11">__proto__</code>属性，通过这个属性可以访问对象的原型。在其他实现中，这个特性完全被隐藏了。关键在于理解这一点：实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有。</p>
            <p class="calibre1">这种关系不好可视化，但可以通过下面的代码来理解原型的行为：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">/**
 * 构造函数可以是函数表达式
 * 也可以是函数声明，因此以下两种形式都可以：
 *   function person() {}
 *   let person = function() {}
 */
function person() {}

/**
 * 声明之后，构造函数就有了一个
 * 与之关联的原型对象：
 */
console.log(typeof person.prototype);
console.log(person.prototype);
// {
//   constructor: f person(),
//   __proto__: object
// }

/**
 * 如前所述，构造函数有一个prototype属性
 * 引用其原型对象，而这个原型对象也有一个
 * constructor属性，引用这个构造函数
 * 换句话说，两者循环引用：
 */
console.log(person.prototype.constructor === person); // true

/**
 * 正常的原型链都会终止于object的原型对象
 * object原型的原型是null
 */
console.log(person.prototype.__proto__ === object.prototype);   // true
console.log(person.prototype.__proto__.constructor === object); // true
console.log(person.prototype.__proto__.__proto__ === null);     // true

console.log(person.prototype.__proto__);
// {
//   constructor: f object(),
//   tostring: ...
//   hasownproperty: ...
//   isprototypeof: ...
//   ...
// }
　
　
let person1 = new person(),
    person2 = new person();

/**
 * 构造函数、原型对象和实例
 * 是3个完全不同的对象：
 */
console.log(person1 !== person);           // true
console.log(person1 !== person.prototype); // true
console.log(person.prototype !== person);  // true

/**
  * 实例通过__proto__链接到原型对象，
  * 它实际上指向隐藏特性[[prototype]]
  *
  * 构造函数通过prototype属性链接到原型对象
  *
  * 实例与构造函数没有直接联系，与原型对象有直接联系
  */
console.log(person1.__proto__ === person.prototype);   // true
conosle.log(person1.__proto__.constructor === person); // true

/**
 * 同一个构造函数创建的两个实例
 * 共享同一个原型对象：
 */
console.log(person1.__proto__ === person2.__proto__); // true

/**
 * instanceof检查实例的原型链中
 * 是否包含指定构造函数的原型：
 */
console.log(person1 instanceof person);           // true
console.log(person1 instanceof object);           // true
console.log(person.prototype instanceof object);  // true</code></pre>
            <p class="calibre1">对于前面例子中的<code class="calibre11">Person</code>构造函数和<code class="calibre11">Person.prototype</code>，可以通过图8-1看出各个对象之间的关系。</p>
            <p class="calibre1"><img src="../images/00011.gif" alt="" width="85%" class="calibre33"/></p>
            <p class="calibre1">
              <strong class="calibre2">图 8-1</strong>
            </p>
            <p class="calibre1">图8-1展示了<code class="calibre11">Person</code>构造函数、<code class="calibre11">Person</code>的原型对象和<code class="calibre11">Person</code>现有两个实例之间的关系。注意，<code class="calibre11">Person.prototype</code>指向原型对象，而<code class="calibre11">Person.prototype.contructor</code>指回<code class="calibre11">Person</code>构造函数。原型对象包含<code class="calibre11">constructor</code>属性和其他后来添加的属性。<code class="calibre11">Person</code>的两个实例<code class="calibre11">person1</code>和<code class="calibre11">person2</code>都只有一个内部属性指回<code class="calibre11">Person.prototype</code>，而且两者都与构造函数没有直接联系。另外要注意，虽然这两个实例都没有属性和方法，但<code class="calibre11">person1.sayName()</code>可以正常调用。这是由于对象属性查找机制的原因。</p>
            <p class="calibre1">虽然不是所有实现都对外暴露了<code class="calibre11">[[Prototype]]</code>，但可以使用<code class="calibre11">isPrototypeOf()</code>方法确定两个对象之间的这种关系。本质上，<code class="calibre11">isPrototypeOf()</code>会在传入参数的<code class="calibre11">[[Prototype]]</code>指向调用它的对象时返回<code class="calibre11">true</code>，如下所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">console.log(person.prototype.isprototypeof(person1));  // true
console.log(person.prototype.isprototypeof(person2));  // true</code></pre>
            <p class="calibre1">这里通过原型对象调用<code class="calibre11">isPrototypeOf()</code>方法检查了<code class="calibre11">person1</code>和<code class="calibre11">person2</code>。因为这两个例子内部都有链接指向<code class="calibre11">Person.prototype</code>，所以结果都返回<code class="calibre11">true</code>。</p>
            <p class="calibre1">ECMAScript的<code class="calibre11">Object</code>类型有一个方法叫<code class="calibre11">Object.getPrototypeOf()</code>，返回参数的内部特性<code class="calibre11">[[Prototype]]</code>的值。例如：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">console.log(object.getprototypeof(person1) == person.prototype);  // true
console.log(object.getprototypeof(person1).name);                 // "nicholas"</code></pre>
            <p class="calibre1">第一行代码简单确认了<code class="calibre11">Object.getPrototypeOf()</code>返回的对象就是传入对象的原型对象。第二行代码则取得了原型对象上<code class="calibre11">name</code>属性的值，即<code class="calibre11">"Nicholas"</code>。使用<code class="calibre11">Object.getPrototypeOf()</code>可以方便地取得一个对象的原型，而这在通过原型实现继承时显得尤为重要（本章后面会介绍）。</p>
            <p class="calibre1">
              <code class="calibre11">Object</code>类型还有一个<code class="calibre11">setPrototypeOf()</code>方法，可以向实例的私有特性<code class="calibre11">[[Prototype]]</code>写入一个新值。这样就可以重写一个对象的原型继承关系：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let biped = {
  numlegs: 2
};
let person = {
  name: 'matt'
};

object.setprototypeof(person, biped);

console.log(person.name);                              // matt
console.log(person.numlegs);                           // 2
console.log(object.getprototypeof(person) === biped);  // true</code></pre>
            <blockquote class="calibre13">
              <p class="calibre1">
                <strong class="calibre2">警告</strong>
                <code class="calibre11">Object.setPrototypeOf()</code>可能会严重影响代码性能。Mozilla文档说得很清楚：“在所有浏览器和JavaScript引擎中，修改继承关系的影响都是微妙且深远的。这种影响并不仅是执行<code class="calibre11">Object.setPrototypeOf()</code>语句那么简单，而是会涉及所有访问了那些修改过<code class="calibre11">[[Prototype]]</code>的对象的代码。”</p>
            </blockquote>
            <p class="calibre1">为避免使用<code class="calibre11">Object.setPrototypeOf()</code>可能造成的性能下降，可以通过<code class="calibre11">Object.create()</code>来创建一个新对象，同时为其指定原型：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let biped = {
  numlegs: 2
};
let person = object.create(biped);
person.name = 'matt';

console.log(person.name);                              // matt
console.log(person.numlegs);                           // 2
console.log(object.getprototypeof(person) === biped);  // true</code></pre>
            <p class="calibre1"></p>
          </li>
          <li value="2" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">原型层级</strong>
            </p>
            <p class="calibre1">在通过对象访问属性时，会按照这个属性的名称开始搜索。搜索开始于对象实例本身。如果在这个实例上发现了给定的名称，则返回该名称对应的值。如果没有找到这个属性，则搜索会沿着指针进入原型对象，然后在原型对象上找到属性后，再返回对应的值。因此，在调用<code class="calibre11">person1.sayName()</code>时，会发生两步搜索。首先，JavaScript引擎会问：“<code class="calibre11">person1</code>实例有<code class="calibre11">sayName</code>属性吗？”答案是没有。然后，继续搜索并问：“<code class="calibre11">person1</code>的原型有<code class="calibre11">sayName</code>属性吗？”答案是有。于是就返回了保存在原型上的这个函数。在调用<code class="calibre11">person2.sayName()</code>时，会发生同样的搜索过程，而且也会返回相同的结果。这就是原型用于在多个对象实例间共享属性和方法的原理。</p>
            <blockquote class="calibre13">
              <p class="calibre1">
                <strong class="calibre2">注意</strong>
                前面提到的<code class="calibre11">constructor</code>属性只存在于原型对象，因此通过实例对象也是可以访问到的。</p>
            </blockquote>
            <p class="calibre1">虽然可以通过实例读取原型对象上的值，但不可能通过实例重写这些值。如果在实例上添加了一个与原型对象中同名的属性，那就会在实例上创建这个属性，这个属性会遮住原型对象上的属性。下面看一个例子：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">function person() {}

person.prototype.name = "nicholas";
person.prototype.age = 29;
person.prototype.job = "software engineer";
person.prototype.sayname = function() {
  console.log(this.name);
};

let person1 = new person();
let person2 = new person();

person1.name = "greg";
console.log(person1.name);  // "greg"，来自实例
console.log(person2.name);  // "nicholas"，来自原型</code></pre>
            <p class="calibre1">在这个例子中，<code class="calibre11">person1</code>的<code class="calibre11">name</code>属性遮蔽了原型对象上的同名属性。虽然<code class="calibre11">person1.name</code>和<code class="calibre11">person2.name</code>都返回了值，但前者返回的是<code class="calibre11">"Greg"</code>（来自实例），后者返回的是<code class="calibre11">"Nicholas"</code>（来自原型）。当<code class="calibre11">console.log()</code>访问<code class="calibre11">person1.name</code>时，会先在实例上搜索个属性。因为这个属性在实例上存在，所以就不会再搜索原型对象了。而在访问<code class="calibre11">person2.name</code>时，并没有在实例上找到这个属性，所以会继续搜索原型对象并使用定义在原型上的属性。</p>
            <p class="calibre1">只要给对象实例添加一个属性，这个属性就会<strong class="calibre2">遮蔽</strong>（shadow）原型对象上的同名属性，也就是虽然不会修改它，但会屏蔽对它的访问。即使在实例上把这个属性设置为<code class="calibre11">null</code>，也不会恢复它和原型的联系。不过，使用<code class="calibre11">delete</code>操作符可以完全删除实例上的这个属性，从而让标识符解析过程能够继续搜索原型对象。</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">function person() {}

person.prototype.name = "nicholas";
person.prototype.age = 29;
person.prototype.job = "software engineer";
person.prototype.sayname = function() {
  console.log(this.name);
};

let person1 = new person();
let person2 = new person();

person1.name = "greg";
console.log(person1.name);  // "greg"，来自实例
console.log(person2.name);  // "nicholas"，来自原型

delete person1.name;
console.log(person1.name);  // "nicholas"，来自原型</code></pre>
            <p class="calibre1">这个修改后的例子中使用<code class="calibre11">delete</code>删除了<code class="calibre11">person1.name</code>，这个属性之前以<code class="calibre11">"Greg"</code>遮蔽了原型上的同名属性。然后原型上<code class="calibre11">name</code>属性的联系就恢复了，因此再访问<code class="calibre11">person1.name</code>时，就会返回原型对象上这个属性的值。</p>
            <p class="calibre1">
              <code class="calibre11">hasOwnProperty()</code>方法用于确定某个属性是在实例上还是在原型对象上。这个方法是继承自<code class="calibre11">Object</code>的，会在属性存在于调用它的对象实例上时返回<code class="calibre11">true</code>，如下面的例子所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">function person() {}

person.prototype.name = "nicholas";
person.prototype.age = 29;
person.prototype.job = "software engineer";
person.prototype.sayname = function() {
  console.log(this.name);
};

let person1 = new person();
let person2 = new person();
console.log(person1.hasownproperty("name")); // false

person1.name = "greg";
console.log(person1.name); // "greg"，来自实例
console.log(person1.hasownproperty("name")); // true

console.log(person2.name); // "nicholas"，来自原型
console.log(person2.hasownproperty("name")); // false

delete person1.name;
console.log(person1.name); // "nicholas"，来自原型
console.log(person1.hasownproperty("name")); // false</code></pre>
            <p class="calibre1">在这个例子中，通过调用<code class="calibre11">hasOwnProperty()</code>能够清楚地看到访问的是实例属性还是原型属性。调用<code class="calibre11">person1.hasOwnProperty("name")</code>只在重写<code class="calibre11">person1</code>上<code class="calibre11">name</code>属性的情况下才返回<code class="calibre11">true</code>，表明此时<code class="calibre11">name</code>是一个实例属性，不是原型属性。图8-2形象地展示了上面例子中各个步骤的状态。（为简单起见，图中省略了<code class="calibre11">Person</code>构造函数。）</p>
            <p class="calibre1"><img src="../images/00083.gif" alt="" width="85%" class="calibre33"/></p>
            <p class="calibre1">
              <strong class="calibre2">图 8-2</strong>
            </p>
            <blockquote class="calibre13">
              <p class="calibre1">
                <strong class="calibre2">注意</strong>
                ECMAScript的<code class="calibre11">Object.getOwnPropertyDescriptor()</code>方法只对实例属性有效。要取得原型属性的描述符，就必须直接在原型对象上调用<code class="calibre11">Object.getOwnPropertyDescriptor()</code>。</p>
            </blockquote>
            <p class="calibre1"></p>
          </li>
          <li value="3" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">原型和<code class="calibre11">in</code>操作符</strong>
            </p>
            <p class="calibre1">有两种方式使用<code class="calibre11">in</code>操作符：单独使用和在<code class="calibre11">for-in</code>循环中使用。在单独使用时，<code class="calibre11">in</code>操作符会在可以通过对象访问指定属性时返回<code class="calibre11">true</code>，无论该属性是在实例上还是在原型上。来看下面的例子：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">function person() {}

person.prototype.name = "nicholas";
person.prototype.age = 29;
person.prototype.job = "software engineer";
person.prototype.sayname = function() {
  console.log(this.name);
};

let person1 = new person();
let person2 = new person();

console.log(person1.hasownproperty("name")); // false
console.log("name" in person1); // true

person1.name = "greg";
console.log(person1.name); // "greg"，来自实例
console.log(person1.hasownproperty("name")); // true
console.log("name" in person1); // true

console.log(person2.name); // "nicholas"，来自原型
console.log(person2.hasownproperty("name")); // false
console.log("name" in person2); // true

delete person1.name;
console.log(person1.name); // "nicholas"，来自原型
console.log(person1.hasownproperty("name")); // false
console.log("name" in person1); // true</code></pre>
            <p class="calibre1">在上面整个例子中，<code class="calibre11">name</code>随时可以通过实例或通过原型访问到。因此，调用<code class="calibre11">"name" in persoon1</code>时始终返回<code class="calibre11">true</code>，无论这个属性是否在实例上。如果要确定某个属性是否存在于原型上，则可以像下面这样同时使用<code class="calibre11">hasOwnProperty()</code>和<code class="calibre11">in</code>操作符：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">function hasprototypeproperty(object, name){
  return !object.hasownproperty(name) &amp;&amp; (name in object);
}</code></pre>
            <p class="calibre1">只要通过对象可以访问，<code class="calibre11">in</code>操作符就返回<code class="calibre11">true</code>，而<code class="calibre11">hasOwnProperty()</code>只有属性存在于实例上时才返回<code class="calibre11">true</code>。因此，只要<code class="calibre11">in</code>操作符返回<code class="calibre11">true</code>且<code class="calibre11">hasOwnProperty()</code>返回<code class="calibre11">false</code>，就说明该属性是一个原型属性。来看下面的例子：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">function person() {}

person.prototype.name = "nicholas";
person.prototype.age = 29;
person.prototype.job = "software engineer";
person.prototype.sayname = function() {
  console.log(this.name);
};

let person = new person();
console.log(hasprototypeproperty(person, "name")); // true

person.name = "greg";
console.log(hasprototypeproperty(person, "name")); // false</code></pre>
            <p class="calibre1">在这里，<code class="calibre11">name</code>属性首先只存在于原型上，所以<code class="calibre11">hasPrototypeProperty()</code>返回<code class="calibre11">true</code>。而在实例上重写这个属性后，实例上也有了这个属性，因此<code class="calibre11">hasPrototypeProperty()</code>返回<code class="calibre11">false</code>。即便此时原型对象还有<code class="calibre11">name</code>属性，但因为实例上的属性遮蔽了它，所以不会用到。</p>
            <p class="calibre1">在<code class="calibre11">for-in</code>循环中使用<code class="calibre11">in</code>操作符时，可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性。遮蔽原型中不可枚举（<code class="calibre11">[[Enumerable]]</code>特性被设置为<code class="calibre11">false</code>）属性的实例属性也会在<code class="calibre11">for-in</code>循环中返回，因为默认情况下开发者定义的属性都是可枚举的。</p>
            <p class="calibre1">要获得对象上所有可枚举的实例属性，可以使用<code class="calibre11">Object.keys()</code>方法。这个方法接收一个对象作为参数，返回包含该对象所有可枚举属性名称的字符串数组。比如：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">function person() {}

person.prototype.name = "nicholas";
person.prototype.age = 29;
person.prototype.job = "software engineer";
person.prototype.sayname = function() {
  console.log(this.name);
};

let keys = object.keys(person.prototype);
console.log(keys);   // "name,age,job,sayname"
let p1 = new person();
p1.name = "rob";
p1.age = 31;
let p1keys = object.keys(p1);
console.log(p1keys); // "[name,age]"</code></pre>
            <p class="calibre1">这里，<code class="calibre11">keys</code>变量保存的数组中包含<code class="calibre11">"name"</code>、<code class="calibre11">"age"</code>、<code class="calibre11">"job"</code>和<code class="calibre11">"sayName"</code>。这是正常情况下通过<code class="calibre11">for-in</code>返回的顺序。而在<code class="calibre11">Person</code>的实例上调用时，<code class="calibre11">Object.keys()</code>返回的数组中只包含<code class="calibre11">"name"</code>和<code class="calibre11">"age"</code>两个属性。</p>
            <p class="calibre1">如果想列出所有实例属性，无论是否可以枚举，都可以使用<code class="calibre11">Object.getOwnPropertyNames()</code>：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let keys = object.getownpropertynames(person.prototype);
console.log(keys);   // "[constructor,name,age,job,sayname]"</code></pre>
            <p class="calibre1">注意，返回的结果中包含了一个不可枚举的属性<code class="calibre11">constructor</code>。<code class="calibre11">Object.keys()</code>和<code class="calibre11">Object.getOwnPropertyNames()</code>在适当的时候都可用来代替<code class="calibre11">for-in</code>循环。</p>
            <p class="calibre1">在ECMAScript 6新增符号类型之后，相应地出现了增加一个<code class="calibre11">Object.getOwnPropertyNames()</code>的兄弟方法的需求，因为以符号为键的属性没有名称的概念。因此，<code class="calibre11">Object.getOwnPropertySymbols()</code>方法就出现了，这个方法与<code class="calibre11">Object.getOwnPropertyNames()</code>类似，只是针对符号而已：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let k1 = symbol('k1'),
    k2 = symbol('k2');

let o = {
  [k1]: 'k1',
  [k2]: 'k2'
};

console.log(object.getownpropertysymbols(o));
// [symbol(k1), symbol(k2)]</code></pre>
            <p class="calibre1"></p>
          </li>
          <li value="4" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">属性枚举顺序</strong>
            </p>
            <p class="calibre1">
              <code class="calibre11">for-in</code>循环、<code class="calibre11">Object.keys()</code>、<code class="calibre11">Object.getOwnPropertyNames()</code>、<code class="calibre11">Object.getOwnPropertySymbols()</code>以及<code class="calibre11">Object.assign()</code>在属性枚举顺序方面有很大区别。<code class="calibre11">for-in</code>循环和<code class="calibre11">Object.keys()</code>的枚举顺序是不确定的，取决于JavaScript引擎，可能因浏览器而异。</p>
            <p class="calibre1">
              <code class="calibre11">Object.getOwnPropertyNames()</code>、<code class="calibre11">Object.getOwnPropertySymbols()</code>和<code class="calibre11">Object.assign()</code>的枚举顺序是确定性的。先以升序枚举数值键，然后以插入顺序枚举字符串和符号键。在对象字面量中定义的键以它们逗号分隔的顺序插入。</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let k1 = symbol('k1'),
    k2 = symbol('k2');

let o = {
  1: 1,
  first: 'first',
  [k1]: 'sym2',
  second: 'second',
  0: 0
};

o[k2] = 'sym2';
o[3] = 3;
o.third = 'third';
o[2] = 2;

console.log(object.getownpropertynames(o));
// ["0", "1", "2", "3", "first", "second", "third"]

console.log(object.getownpropertysymbols(o));
// [symbol(k1), symbol(k2)]</code></pre>
          </li>
        </ol>
        <h3 id="nav_point_180" class="calibre15">8.2.5 对象迭代</h3>
        <p class="calibre1">在JavaScript有史以来的大部分时间内，迭代对象属性都是一个难题。ECMAScript 2017新增了两个静态方法，用于将对象内容转换为序列化的——更重要的是可迭代的——格式。这两个静态方法<code class="calibre11">Object.values()</code>和<code class="calibre11">Object.entries()</code>接收一个对象，返回它们内容的数组。<code class="calibre11">Object.values()</code>返回对象值的数组，<code class="calibre11">Object.entries()</code>返回键/值对的数组。</p>
        <p class="calibre1">下面的示例展示了这两个方法：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">const o = {
  foo: 'bar',
  baz: 1,
  qux: {}
};

console.log(object.values(o));
// ["bar", 1, {}]

console.log(object.entries((o)));
// [["foo", "bar"], ["baz", 1], ["qux", {}]]</code></pre>
        <p class="calibre1">注意，非字符串属性会被转换为字符串输出。另外，这两个方法执行对象的浅复制：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">const o = {
  qux: {}
};

console.log(object.values(o)[0] === o.qux);
// true

console.log(object.entries(o)[0][1] === o.qux);
// true</code></pre>
        <p class="calibre1">符号属性会被忽略：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">const sym = symbol();
const o = {
  [sym]: 'foo'
};

console.log(object.values(o));
// []

console.log(object.entries((o)));
// []</code></pre>
        <ol class="calibre16">
          <li value="1" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">其他原型语法</strong>
            </p>
            <p class="calibre1">有读者可能注意到了，在前面的例子中，每次定义一个属性或方法都会把<code class="calibre11">Person.prototype</code>重写一遍。为了减少代码冗余，也为了从视觉上更好地封装原型功能，直接通过一个包含所有属性和方法的对象字面量来重写原型成为了一种常见的做法，如下面的例子所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">function person() {}

person.prototype = {
  name: "nicholas",
  age: 29,
  job: "software engineer",
  sayname() {
    console.log(this.name);
  }
};</code></pre>
            <p class="calibre1">在这个例子中，<code class="calibre11">Person.prototype</code>被设置为等于一个通过对象字面量创建的新对象。最终结果是一样的，只有一个问题：这样重写之后，<code class="calibre11">Person.prototype</code>的<code class="calibre11">constructor</code>属性就不指向<code class="calibre11">Person</code>了。在创建函数时，也会创建它的<code class="calibre11">prototype</code>对象，同时会自动给这个原型的<code class="calibre11">constructor</code>属性赋值。而上面的写法完全重写了默认的<code class="calibre11">prototype</code>对象，因此其<code class="calibre11">constructor</code>属性也指向了完全不同的新对象（<code class="calibre11">Object</code>构造函数），不再指向原来的构造函数。虽然<code class="calibre11">instanceof</code>操作符还能可靠地返回值，但我们不能再依靠<code class="calibre11">constructor</code>属性来识别类型了，如下面的例子所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let friend = new person();

console.log(friend instanceof object);      // true
console.log(friend instanceof person);      // true
console.log(friend.constructor == person);  // false
console.log(friend.constructor == object);  // true</code></pre>
            <p class="calibre1">这里，<code class="calibre11">instanceof</code>仍然对<code class="calibre11">Object</code>和<code class="calibre11">Person</code>都返回<code class="calibre11">true</code>。但<code class="calibre11">constructor</code>属性现在等于<code class="calibre11">Object</code>而不是<code class="calibre11">Person</code>了。如果<code class="calibre11">constructor</code>的值很重要，则可以像下面这样在重写原型对象时专门设置一下它的值：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">function person() {
}

person.prototype = {
  constructor: person,
  name: "nicholas",
  age: 29,
  job: "software engineer",
  sayname() {
    console.log(this.name);
  }
};</code></pre>
            <p class="calibre1">这次的代码中特意包含了<code class="calibre11">constructor</code>属性，并将它设置为<code class="calibre11">Person</code>，保证了这个属性仍然包含恰当的值。</p>
            <p class="calibre1">但要注意，以这种方式恢复<code class="calibre11">constructor</code>属性会创建一个<code class="calibre11">[[Enumerable]]</code>为<code class="calibre11">true</code>的属性。而原生<code class="calibre11">constructor</code>属性默认是不可枚举的。因此，如果你使用的是兼容ECMAScript的JavaScript引擎，那可能会改为使用<code class="calibre11">Object.defineProperty()</code>方法来定义<code class="calibre11">constructor</code>属性：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">function person() {}

person.prototype = {
  name: "nicholas",
  age: 29,
  job: "software engineer",
  sayname() {
    console.log(this.name);
  }
};

// 恢复constructor属性
object.defineproperty(person.prototype, "constructor", {
  enumerable: false,
  value: person
});</code></pre>
            <p class="calibre1"></p>
          </li>
          <li value="2" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">原型的动态性</strong>
            </p>
            <p class="calibre1">因为从原型上搜索值的过程是动态的，所以即使实例在修改原型之前已经存在，任何时候对原型对象所做的修改也会在实例上反映出来。下面是一个例子：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let friend = new person();

person.prototype.sayhi = function() {
  console.log("hi");
};

friend.sayhi();   // "hi"，没问题！</code></pre>
            <p class="calibre1">以上代码先创建一个<code class="calibre11">Person</code>实例并保存在<code class="calibre11">friend</code>中。然后一条语句在<code class="calibre11">Person.prototype</code>上添加了一个名为<code class="calibre11">sayHi()</code>的方法。虽然<code class="calibre11">friend</code>实例是在添加方法之前创建的，但它仍然可以访问这个方法。之所以会这样，主要原因是实例与原型之间松散的联系。在调用<code class="calibre11">friend.sayHi()</code>时，首先会从这个实例中搜索名为<code class="calibre11">sayHi</code>的属性。在没有找到的情况下，运行时会继续搜索原型对象。因为实例和原型之间的链接就是简单的指针，而不是保存的副本，所以会在原型上找到<code class="calibre11">sayHi</code>属性并返回这个属性保存的函数。</p>
            <p class="calibre1">虽然随时能给原型添加属性和方法，并能够立即反映在所有对象实例上，但这跟重写整个原型是两回事。实例的<code class="calibre11">[[Prototype]]</code>指针是在调用构造函数时自动赋值的，这个指针即使把原型修改为不同的对象也不会变。重写整个原型会切断最初原型与构造函数的联系，但实例引用的仍然是最初的原型。记住，实例只有指向原型的指针，没有指向构造函数的指针。来看下面的例子：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">function person() {}

let friend = new person();
person.prototype = {
  constructor: person,
  name: "nicholas",
  age: 29,
  job: "software engineer",
  sayname() {
    console.log(this.name);
  }
};

friend.sayname();  // 错误</code></pre>
            <p class="calibre1">在这个例子中，<code class="calibre11">Person</code>的新实例是在重写原型对象之前创建的。在调用<code class="calibre11">friend.sayName()</code>的时候，会导致错误。这是因为<code class="calibre11">firend</code>指向的原型还是最初的原型，而这个原型上并没有<code class="calibre11">sayName</code>属性。图8-3展示了这里面的原因。</p>
            <p class="calibre1"><img src="../images/00019.gif" alt="" width="90%" class="calibre34"/></p>
            <p class="calibre1">
              <strong class="calibre2">图 8-3</strong>
            </p>
            <p class="calibre1">重写构造函数上的原型之后再创建的实例才会引用新的原型。而在此之前创建的实例仍然会引用最初的原型。<br class="calibre4"/>
            </p>
          </li>
          <li value="3" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">原生对象原型</strong>
            </p>
            <p class="calibre1">原型模式之所以重要，不仅体现在自定义类型上，而且还因为它也是实现所有原生引用类型的模式。所有原生引用类型的构造函数（包括<code class="calibre11">Object</code>、<code class="calibre11">Array</code>、<code class="calibre11">String</code>等）都在原型上定义了实例方法。比如，数组实例的<code class="calibre11">sort()</code>方法就是<code class="calibre11">Array.prototype</code>上定义的，而字符串包装对象的<code class="calibre11">substring()</code>方法也是在<code class="calibre11">String.prototype</code>上定义的，如下所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">console.log(typeof array.prototype.sort);       // "function"
console.log(typeof string.prototype.substring); // "function"</code></pre>
            <p class="calibre1">通过原生对象的原型可以取得所有默认方法的引用，也可以给原生类型的实例定义新的方法。可以像修改自定义对象原型一样修改原生对象原型，因此随时可以添加方法。比如，下面的代码就给<code class="calibre11">String</code>原始值包装类型的实例添加了一个<code class="calibre11">startsWith()</code>方法：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">string.prototype.startswith = function (text) {
  return this.indexof(text) === 0;
};

let msg = "hello world!";
console.log(msg.startswith("hello"));  // true</code></pre>
            <p class="calibre1">如果给定字符串的开头出现了调用<code class="calibre11">startsWith()</code>方法的文本，那么该方法会返回<code class="calibre11">true</code>。因为这个方法是被定义在<code class="calibre11">String.prototype</code>上，所以当前环境下所有的字符串都可以使用这个方法。<code class="calibre11">msg</code>是个字符串，在读取它的属性时，后台会自动创建<code class="calibre11">String</code>的包装实例，从而找到并调用<code class="calibre11">startsWith()</code>方法。</p>
            <blockquote class="calibre13">
              <p class="calibre1">
                <strong class="calibre2">注意</strong>
                尽管可以这么做，但并不推荐在产品环境中修改原生对象原型。这样做很可能造成误会，而且可能引发命名冲突（比如一个名称在某个浏览器实现中不存在，在另一个实现中却存在）。另外还有可能意外重写原生的方法。推荐的做法是创建一个自定义的类，继承原生类型。</p>
            </blockquote>
            <p class="calibre1"></p>
          </li>
          <li value="4" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">原型的问题</strong>
            </p>
            <p class="calibre1">原型模式也不是没有问题。首先，它弱化了向构造函数传递初始化参数的能力，会导致所有实例默认都取得相同的属性值。虽然这会带来不便，但还不是原型的最大问题。原型的最主要问题源自它的共享特性。</p>
            <p class="calibre1">我们知道，原型上的所有属性是在实例间共享的，这对函数来说比较合适。另外包含原始值的属性也还好，如前面例子中所示，可以通过在实例上添加同名属性来简单地遮蔽原型上的属性。真正的问题来自包含引用值的属性。来看下面的例子：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">function person() {}

person.prototype = {
  constructor: person,
  name: "nicholas",
  age: 29,
  job: "software engineer",
  friends: ["shelby", "court"],
  sayname() {
    console.log(this.name);
  }
};

let person1 = new person();
let person2 = new person();

person1.friends.push("van");

console.log(person1.friends);  // "shelby,court,van"
console.log(person2.friends);  // "shelby,court,van"
console.log(person1.friends === person2.friends);  // true</code></pre>
            <p class="calibre1">这里，<code class="calibre11">Person.prototype</code>有一个名为<code class="calibre11">friends</code>的属性，它包含一个字符串数组。然后这里创建了两个<code class="calibre11">Person</code>的实例。<code class="calibre11">person1.friends</code>通过<code class="calibre11">push</code>方法向数组中添加了一个字符串。由于这个<code class="calibre11">friends</code>属性存在于<code class="calibre11">Person.prototype</code>而非<code class="calibre11">person1</code>上，新加的这个字符串也会在（指向同一个数组的）<code class="calibre11">person2.friends</code>上反映出来。如果这是有意在多个实例间共享数组，那没什么问题。但一般来说，不同的实例应该有属于自己的属性副本。这就是实际开发中通常不单独使用原型模式的原因。</p>
          </li>
        </ol>

      </div>

      <div class="calibreToc">
        <h2>
          <a href="../../54m0dfqx.html">Table of contents
          </a>
        </h2>
        <div>
          <ul>
            <li>
              <a href="part0002.html#nav_point_0">版权声明</a>
            </li>
            <li>
              <a href="part0003.html#nav_point_1">献词</a>
            </li>
            <li>
              <a href="part0004.html#nav_point_2">译者序</a>
            </li>
            <li>
              <a href="part0005.html#nav_point_3">序</a>
            </li>
            <li>
              <a href="part0006.html#nav_point_4">前言</a>
            </li>
            <li>
              <a href="part0012.html#nav_point_10">致谢</a>
            </li>
            <li>
              <a href="part0013.html#nav_point_11">第 1 章 什么是JavaScript</a>
            </li>
            <li>
              <a href="part0018.html#nav_point_19">第 2 章 HTML中的JavaScript</a>
            </li>
            <li>
              <a href="part0024.html#nav_point_31">第 3 章 语言基础</a>
            </li>
            <li>
              <a href="part0033.html#nav_point_78">第 4 章 变量、作用域与内存</a>
            </li>
            <li>
              <a href="part0038.html#nav_point_93">第 5 章 基本引用类型</a>
            </li>
            <li>
              <a href="part0044.html#nav_point_111">第 6 章 集合引用类型</a>
            </li>
            <li>
              <a href="part0054.html#nav_point_153">第 7 章 迭代器与生成器</a>
            </li>
            <li>
              <a href="part0059.html#nav_point_166">第 8 章 对象、类与面向对象编程</a>
            </li>
            <li>
              <a href="part0065.html#nav_point_194">第 9 章 代理与反射</a>
            </li>
            <li>
              <a href="part0070.html#nav_point_225">第 10 章 函数</a>
            </li>
            <li>
              <a href="part0088.html#nav_point_258">第 11 章 期约与异步函数</a>
            </li>
            <li>
              <a href="part0093.html#nav_point_273">第 12 章 BOM</a>
            </li>
            <li>
              <a href="part0100.html#nav_point_294">第 13 章 客户端检测</a>
            </li>
            <li>
              <a href="part0105.html#nav_point_306">第 14 章 DOM</a>
            </li>
            <li>
              <a href="part0110.html#nav_point_328">第 15 章 DOM扩展</a>
            </li>
            <li>
              <a href="part0116.html#nav_point_348">第 16 章 DOM2和DOM3</a>
            </li>
            <li>
              <a href="part0122.html#nav_point_370">第 17 章 事件</a>
            </li>
            <li>
              <a href="part0130.html#nav_point_403">第 18 章 动画与Canvas图形</a>
            </li>
            <li>
              <a href="part0136.html#nav_point_428">第 19 章 表单脚本</a>
            </li>
            <li>
              <a href="part0143.html#nav_point_450">第 20 章 JavaScript API</a>
            </li>
            <li>
              <a href="part0157.html#nav_point_500">第 21 章 错误处理与调试</a>
            </li>
            <li>
              <a href="part0163.html#nav_point_526">第 22 章 处理XML</a>
            </li>
            <li>
              <a href="part0168.html#nav_point_542">第 23 章 JSON</a>
            </li>
            <li>
              <a href="part0172.html#nav_point_552">第 24 章 网络请求与远程资源</a>
            </li>
            <li>
              <a href="part0182.html#nav_point_582">第 25 章 客户端存储</a>
            </li>
            <li>
              <a href="part0187.html#nav_point_607">第 26 章 模块</a>
            </li>
            <li>
              <a href="part0193.html#nav_point_633">第 27 章 工作者线程</a>
            </li>
            <li>
              <a href="part0199.html#nav_point_667">第 28 章 最佳实践</a>
            </li>
            <li>
              <a href="part0204.html#nav_point_683">附录 A ES2018和ES2019</a>
            </li>
            <li>
              <a href="part0215.html#nav_point_708">附录 B 严格模式</a>
            </li>
            <li>
              <a href="part0223.html#nav_point_719">附录 C JavaScript库和框架</a>
            </li>
            <li>
              <a href="part0227.html#nav_point_741">附录 D JavaScript工具</a>
            </li>
            <li>
              <a href="part0239.html#nav_point_800">作者简介</a>
            </li>
          </ul>
        </div>

      </div>

      <div class="calibreEbNav">

        <a href="part0060.html" class="calibreAPrev">上一页
        </a>

        <a href="../../54m0dfqx.html" class="calibreAHome">首页
        </a>

        <a href="part0062.html" class="calibreANext">下一页
        </a>

      </div>

    </div>

    <script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6487844781006261" crossorigin="anonymous"></script>
  </body>
</html>