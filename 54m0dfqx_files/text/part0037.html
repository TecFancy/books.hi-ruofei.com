<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>

    <title>JavaScript高级程序设计（第4版）</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" type="text/css" href="../stylesheet.css"/>
    <link rel="stylesheet" type="text/css" href="../page_styles.css"/>

    <link href="../calibreHtmlOutBasicCss.css" type="text/css" rel="stylesheet"/>

  </head>
  <body>

    <div class="calibreMeta">
      <div class="calibreMetaTitle">

        <h1>
          <a href="../../54m0dfqx.html">JavaScript高级程序设计（第4版）
          </a>
        </h1>

      </div>
      <div class="calibreMetaAuthor">
        [美] 马特 • 弗里斯比

      </div>
    </div>

    <div class="calibreMain">

      <div class="calibreEbookContent">

        <div class="calibreEbNavTop">

          <a href="part0036.html" class="calibreAPrev">上一页
          </a>

          <a href="part0038.html" class="calibreANext">下一页
          </a>

        </div>

        <h2 id="nav_point_92" class="calibre9">4.4 小结</h2>
        <p class="calibre1">JavaScript变量可以保存两种类型的值：原始值和引用值。原始值可能是以下6种原始数据类型之一：<code class="calibre11">Undefined</code>、<code class="calibre11">Null</code>、<code class="calibre11">Boolean</code>、<code class="calibre11">Number</code>、<code class="calibre11">String</code>和<code class="calibre11">Symbol</code>。原始值和引用值有以下特点。</p>
        <ul class="calibre10">
          <li class="di_1ji_wu_xu_lie_biao">原始值大小固定，因此保存在栈内存上。</li>
          <li class="di_1ji_wu_xu_lie_biao">从一个变量到另一个变量复制原始值会创建该值的第二个副本。</li>
          <li class="di_1ji_wu_xu_lie_biao">引用值是对象，存储在堆内存上。</li>
          <li class="di_1ji_wu_xu_lie_biao">包含引用值的变量实际上只包含指向相应对象的一个指针，而不是对象本身。</li>
          <li class="di_1ji_wu_xu_lie_biao">从一个变量到另一个变量复制引用值只会复制指针，因此结果是两个变量都指向同一个对象。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">typeof</code>操作符可以确定值的原始类型，而<code class="calibre11">instanceof</code>操作符用于确保值的引用类型。</li>
        </ul>
        <p class="calibre1">任何变量（不管包含的是原始值还是引用值）都存在于某个执行上下文中（也称为作用域）。这个上下文（作用域）决定了变量的生命周期，以及它们可以访问代码的哪些部分。执行上下文可以总结如下。</p>
        <ul class="calibre10">
          <li class="di_1ji_wu_xu_lie_biao">执行上下文分全局上下文、函数上下文和块级上下文。</li>
          <li class="di_1ji_wu_xu_lie_biao">代码执行流每进入一个新上下文，都会创建一个作用域链，用于搜索变量和函数。</li>
          <li class="di_1ji_wu_xu_lie_biao">函数或块的局部上下文不仅可以访问自己作用域内的变量，而且也可以访问任何包含上下文乃至全局上下文中的变量。</li>
          <li class="di_1ji_wu_xu_lie_biao">全局上下文只能访问全局上下文中的变量和函数，不能直接访问局部上下文中的任何数据。</li>
          <li class="di_1ji_wu_xu_lie_biao">变量的执行上下文用于确定什么时候释放内存。</li>
        </ul>
        <p class="calibre1">JavaScript是使用垃圾回收的编程语言，开发者不需要操心内存分配和回收。JavaScript的垃圾回收程序可以总结如下。</p>
        <ul class="calibre10">
          <li class="di_1ji_wu_xu_lie_biao">离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除。</li>
          <li class="di_1ji_wu_xu_lie_biao">主流的垃圾回收算法是标记清理，即先给当前不使用的值加上标记，再回来回收它们的内存。</li>
          <li class="di_1ji_wu_xu_lie_biao">引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。JavaScript引擎不再使用这种算法，但某些旧版本的IE仍然会受这种算法的影响，原因是JavaScript会访问非原生JavaScript对象（如DOM元素）。</li>
          <li class="di_1ji_wu_xu_lie_biao">引用计数在代码中存在循环引用时会出现问题。</li>
          <li class="di_1ji_wu_xu_lie_biao">解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮助。为促进内存回收，全局对象、全局对象的属性和循环引用都应该在不需要时解除引用。</li>
        </ul>

        <br class="calibre4" id="calibre_pb_59"/>

      </div>

      <div class="calibreToc">
        <h2>
          <a href="../../54m0dfqx.html">Table of contents
          </a>
        </h2>
        <div>
          <ul>
            <li>
              <a href="part0002.html#nav_point_0">版权声明</a>
            </li>
            <li>
              <a href="part0003.html#nav_point_1">献词</a>
            </li>
            <li>
              <a href="part0004.html#nav_point_2">译者序</a>
            </li>
            <li>
              <a href="part0005.html#nav_point_3">序</a>
            </li>
            <li>
              <a href="part0006.html#nav_point_4">前言</a>
            </li>
            <li>
              <a href="part0012.html#nav_point_10">致谢</a>
            </li>
            <li>
              <a href="part0013.html#nav_point_11">第 1 章 什么是JavaScript</a>
            </li>
            <li>
              <a href="part0018.html#nav_point_19">第 2 章 HTML中的JavaScript</a>
            </li>
            <li>
              <a href="part0024.html#nav_point_31">第 3 章 语言基础</a>
            </li>
            <li>
              <a href="part0033.html#nav_point_78">第 4 章 变量、作用域与内存</a>
            </li>
            <li>
              <a href="part0038.html#nav_point_93">第 5 章 基本引用类型</a>
            </li>
            <li>
              <a href="part0044.html#nav_point_111">第 6 章 集合引用类型</a>
            </li>
            <li>
              <a href="part0054.html#nav_point_153">第 7 章 迭代器与生成器</a>
            </li>
            <li>
              <a href="part0059.html#nav_point_166">第 8 章 对象、类与面向对象编程</a>
            </li>
            <li>
              <a href="part0065.html#nav_point_194">第 9 章 代理与反射</a>
            </li>
            <li>
              <a href="part0070.html#nav_point_225">第 10 章 函数</a>
            </li>
            <li>
              <a href="part0088.html#nav_point_258">第 11 章 期约与异步函数</a>
            </li>
            <li>
              <a href="part0093.html#nav_point_273">第 12 章 BOM</a>
            </li>
            <li>
              <a href="part0100.html#nav_point_294">第 13 章 客户端检测</a>
            </li>
            <li>
              <a href="part0105.html#nav_point_306">第 14 章 DOM</a>
            </li>
            <li>
              <a href="part0110.html#nav_point_328">第 15 章 DOM扩展</a>
            </li>
            <li>
              <a href="part0116.html#nav_point_348">第 16 章 DOM2和DOM3</a>
            </li>
            <li>
              <a href="part0122.html#nav_point_370">第 17 章 事件</a>
            </li>
            <li>
              <a href="part0130.html#nav_point_403">第 18 章 动画与Canvas图形</a>
            </li>
            <li>
              <a href="part0136.html#nav_point_428">第 19 章 表单脚本</a>
            </li>
            <li>
              <a href="part0143.html#nav_point_450">第 20 章 JavaScript API</a>
            </li>
            <li>
              <a href="part0157.html#nav_point_500">第 21 章 错误处理与调试</a>
            </li>
            <li>
              <a href="part0163.html#nav_point_526">第 22 章 处理XML</a>
            </li>
            <li>
              <a href="part0168.html#nav_point_542">第 23 章 JSON</a>
            </li>
            <li>
              <a href="part0172.html#nav_point_552">第 24 章 网络请求与远程资源</a>
            </li>
            <li>
              <a href="part0182.html#nav_point_582">第 25 章 客户端存储</a>
            </li>
            <li>
              <a href="part0187.html#nav_point_607">第 26 章 模块</a>
            </li>
            <li>
              <a href="part0193.html#nav_point_633">第 27 章 工作者线程</a>
            </li>
            <li>
              <a href="part0199.html#nav_point_667">第 28 章 最佳实践</a>
            </li>
            <li>
              <a href="part0204.html#nav_point_683">附录 A ES2018和ES2019</a>
            </li>
            <li>
              <a href="part0215.html#nav_point_708">附录 B 严格模式</a>
            </li>
            <li>
              <a href="part0223.html#nav_point_719">附录 C JavaScript库和框架</a>
            </li>
            <li>
              <a href="part0227.html#nav_point_741">附录 D JavaScript工具</a>
            </li>
            <li>
              <a href="part0239.html#nav_point_800">作者简介</a>
            </li>
          </ul>
        </div>

      </div>

      <div class="calibreEbNav">

        <a href="part0036.html" class="calibreAPrev">上一页
        </a>

        <a href="../../54m0dfqx.html" class="calibreAHome">首页
        </a>

        <a href="part0038.html" class="calibreANext">下一页
        </a>

      </div>

    </div>

    <script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6487844781006261" crossorigin="anonymous"></script>
  </body>
</html>