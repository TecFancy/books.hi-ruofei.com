<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>

    <title>JavaScript高级程序设计（第4版）</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" type="text/css" href="../stylesheet.css"/>
    <link rel="stylesheet" type="text/css" href="../page_styles.css"/>

    <link href="../calibreHtmlOutBasicCss.css" type="text/css" rel="stylesheet"/>

  </head>
  <body>

    <div class="calibreMeta">
      <div class="calibreMetaTitle">

        <h1>
          <a href="../../54m0dfqx.html">JavaScript高级程序设计（第4版）
          </a>
        </h1>

      </div>
      <div class="calibreMetaAuthor">
        [美] 马特 • 弗里斯比

      </div>
    </div>

    <div class="calibreMain">

      <div class="calibreEbookContent">

        <div class="calibreEbNavTop">

          <a href="part0196.html" class="calibreAPrev">上一页
          </a>

          <a href="part0198.html" class="calibreANext">下一页
          </a>

        </div>

        <h2 id="nav_point_654" class="calibre9">27.4 服务工作者线程</h2>
        <p class="calibre1">
          <strong class="calibre2">服务工作者线程</strong>（service worker）是一种类似浏览器中代理服务器的线程，可以拦截外出请求和缓存响应。这可以让网页在没有网络连接的情况下正常使用，因为部分或全部页面可以从服务工作者线程缓存中提供服务。服务工作者线程也可以使用Notifications API、Push API、Background Sync API和Channel Messaging API。</p>
        <p class="calibre1">与共享工作者线程类似，来自一个域的多个页面共享一个服务工作者线程。不过，为了使用Push API等特性，服务工作者线程也可以在相关的标签页或浏览器关闭后继续等待到来的推送事件。</p>
        <p class="calibre1">无论如何，对于大多数开发者而言，服务工作者线程在两个主要任务上最有用：充当网络请求的缓存层和启用推送通知。在这个意义上，服务工作者线程就是用于把网页变成像原生应用程序一样的工具。</p>
        <blockquote class="calibre13">
          <p class="calibre1">
            <strong class="calibre2">注意</strong>
            服务工作者线程涉及的内容极其广泛，几乎可以单独写一本书。为了更好地理解这一话题，推荐有条件的读者学一下Udacity的课程“Offline Web Applications”。除此之外，也可以参考Mozilla维护的Service Worker Cookbook网站，其中包含了常见的服务工作者线程模式。</p>
        </blockquote>
        <p class="calibre1"></p>
        <blockquote class="calibre13">
          <p class="calibre1">
            <strong class="calibre2">注意</strong>
            服务工作者线程的生命周期取决于打开的同源标签页（称为“客户端”）数量、页面是否发生导航，以及服务脚本是否改变（以及其他一些因素）。如果对服务工作者线程的生命周期认识不够，本节的一些例子可能会让人觉得出乎意料。27.4.5节详细解释了服务工作者线程的生命周期。</p>
          <p class="calibre1">另外，在调试服务工作者线程时，要谨慎使用浏览器的强制刷新功能（Ctrl+Shift+R）。强制刷新会强制浏览器忽略所有网络缓存，而服务工作者线程对大多数主流浏览器而言就是网络缓存。</p>
        </blockquote>
        <h3 id="nav_point_655" class="calibre15">27.4.1 服务工作者线程基础</h3>
        <p class="calibre1">作为一种工作者线程，服务工作者线程与专用工作者线程和共享工作者线程拥有很多共性。比如，在独立上下文中运行，只能通过异步消息通信。不过，服务工作者线程与专用工作者线程和共享工作者线程还是有很多本质区别的。</p>
        <ol class="calibre16">
          <li value="1" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">
                <code class="calibre11">ServiceWorkerContainer</code>
              </strong>
            </p>
            <p class="calibre1">服务工作者线程与专用工作者线程或共享工作者线程的一个区别是没有全局构造函数。服务工作者线程是通过<code class="calibre11">ServiceWorkerContainer</code>来管理的，它的实例保存在<code class="calibre11">navigator.serviceWorker</code>属性中。该对象是个顶级接口，通过它可以让浏览器创建、更新、销毁或者与服务工作者线程交互。</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">console.log(navigator.serviceworker);
// serviceworkercontainer { ... }</code></pre>
            <p class="calibre1"></p>
          </li>
          <li value="2" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">创建服务工作者线程</strong>
            </p>
            <p class="calibre1">与共享工作者线程类似，服务工作者线程同样是在还不存在时创建新实例，在存在时连接到已有实例。<code class="calibre11">ServiceWorkerContainer</code>没有通过全局构造函数创建，而是暴露了<code class="calibre11">register()</code>方法，该方法以与<code class="calibre11">Worker()</code>或<code class="calibre11">SharedWorker()</code>构造函数相同的方式传递脚本URL：</p>
            <p class="calibre1">
              <strong class="calibre2">emptyServiceWorker.js</strong>
            </p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">// 空服务脚本</code></pre>
            <p class="calibre1">
              <strong class="calibre2">main.js</strong>
            </p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">navigator.serviceworker.register('./emptyserviceworker.js');</code></pre>
            <p class="calibre1">
              <code class="calibre11">register()</code>方法返回一个期约，该期约解决为<code class="calibre11">ServiceWorkerRegistration</code>对象，或在注册失败时拒绝。</p>
            <p class="calibre1">
              <strong class="calibre2">emptyServiceWorker.js</strong>
            </p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">// 空服务脚本</code></pre>
            <p class="calibre1">
              <strong class="calibre2">main.js</strong>
            </p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">// 注册成功，成功回调（解决）
navigator.serviceworker.register('./emptyserviceworker.js')
  .then(console.log, console.error);

// serviceworkerregistration { ... }

// 使用不存在的文件注册，失败回调（拒绝）
navigator.serviceworker.register('./doesnotexist.js')
  .then(console.log, console.error);

// typeerror: failed to register a serviceworker:
// a bad http response code (404) was received when fetching the script.</code></pre>
            <p class="calibre1">服务工作者线程对于何时注册是比较灵活的。在第一次调用<code class="calibre11">register()</code>激活服务工作者线程后，后续在同一个页面使用相同URL对<code class="calibre11">register()</code>的调用实际上什么也不会执行。此外，即使浏览器未全局支持服务工作者线程，服务工作者线程本身对页面也应该是不可见的。这是因为它的行为类似代理，就算有需要它处理的操作，也仅仅是发送常规的网络请求。</p>
            <p class="calibre1">考虑到上述情况，注册服务工作者线程的一种非常常见的模式是基于特性检测，并在页面的<code class="calibre11">load</code>事件中操作。比如：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">if ('serviceworker' in navigator) {
  window.addeventlistener('load', () =&gt; {
    navigator.serviceworker.register('./serviceworker.js');
  });
}</code></pre>
            <p class="calibre1">如果没有<code class="calibre11">load</code>事件这个门槛，服务工作者线程的注册就会与页面资源的加载重叠，进而拖慢初始页面渲染的过程。除非该服务工作者线程负责管理缓存（这样的话就需要尽早注册，比如使用本章稍后会讨论的<code class="calibre11">clients.claim()</code>），否则等待<code class="calibre11">load</code>事件是个明智的选择，这样同样可以发挥服务工作者线程的价值。<br class="calibre4"/>
            </p>
          </li>
          <li value="3" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">使用<code class="calibre11">ServiceWorkerContainer</code>对象</strong>
            </p>
            <p class="calibre1">
              <code class="calibre11">ServiceWorkerContainer</code>接口是浏览器对服务工作者线程生态的顶部封装。它为管理服务工作者线程状态和生命周期提供了便利。</p>
            <p class="calibre1">
              <code class="calibre11">ServiceWorkerContainer</code>始终可以在客户端上下文中访问：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">console.log(navigator.serviceworker);

// serviceworkercontainer { ... }</code></pre>
            <p class="calibre1">
              <code class="calibre11">ServiceWorkerContainer</code>支持以下事件处理程序。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">oncontrollerchange</code>：在<code class="calibre11">ServiceWorkerContainer</code>触发<code class="calibre11">controllerchange</code>事件时会调用指定的事件处理程序。<ul class="calibre28">
                  <li class="di_1ji_wu_xu_lie_biao">此事件在获得新激活的<code class="calibre11">ServiceWorkerRegistration</code>时触发。</li>
                  <li class="di_1ji_wu_xu_lie_biao">此事件也可以使用<code class="calibre11">navigator.serviceWorker.addEventListener('controllerchange', handler)</code>处理。</li>
                </ul>
              </li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">onerror</code>：在关联的服务工作者线程触发<code class="calibre11">ErrorEvent</code>错误事件时会调用指定的事件处理程序。<ul class="calibre28">
                  <li class="di_1ji_wu_xu_lie_biao">此事件在关联的服务工作者线程内部抛出错误时触发。</li>
                  <li class="di_1ji_wu_xu_lie_biao">此事件也可以使用<code class="calibre11">navigator.serviceWorker.addEventListener('error', handler)</code>处理。</li>
                </ul>
              </li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">onmessage</code>：在服务工作者线程触发<code class="calibre11">MessageEvent</code>事件时会调用指定的事件处理程序。<ul class="calibre28">
                  <li class="di_1ji_wu_xu_lie_biao">此事件在服务脚本向父上下文发送消息时触发。</li>
                  <li class="di_1ji_wu_xu_lie_biao">此事件也可以使用<code class="calibre11">navigator.serviceWorker.addEventListener('message', handler)</code>处理。</li>
                </ul>
              </li>
            </ul>
            <p class="calibre1">
              <code class="calibre11">ServiceWorkerContainer</code>支持下列属性。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">ready</code>：返回期约，解决为激活的<code class="calibre11">ServiceWorkerRegistration</code>对象。该期约不会拒绝。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">controller</code>：返回与当前页面关联的激活的<code class="calibre11">ServiceWorker</code>对象，如果没有激活的服务工作者线程则返回<code class="calibre11">null</code>。</li>
            </ul>
            <p class="calibre1">
              <code class="calibre11">ServiceWorkerContainer</code>支持下列方法。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">register()</code>：使用接收的<code class="calibre11">url</code>和<code class="calibre11">options</code>对象创建或更新<code class="calibre11">ServiceWorkerRegistration</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">getRegistration()</code>：返回期约，解决为与提供的作用域匹配的<code class="calibre11">ServiceWorkerRegistration</code>对象；如果没有匹配的服务工作者线程则返回<code class="calibre11">undefined</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">getRegistrations()</code>：返回期约，解决为与<code class="calibre11">ServiceWorkerContainer</code>关联的<code class="calibre11">ServiceWorkerRegistration</code>对象的数组；如果没有关联的服务工作者线程则返回空数组。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">startMessage()</code>：开始传送通过<code class="calibre11">Client.postMessage()</code>派发的消息。<br class="calibre4"/>
              </li>
            </ul>
          </li>
          <li value="4" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">使用<code class="calibre11">ServiceWorkerRegistration</code>对象</strong>
            </p>
            <p class="calibre1">
              <code class="calibre11">ServiceWorkerRegistration</code>对象表示注册成功的服务工作者线程。该对象可以在<code class="calibre11">register()</code>返回的解决期约的处理程序中访问到。通过它的一些属性可以确定关联服务工作者线程的生命周期状态。</p>
            <p class="calibre1">调用<code class="calibre11">navigator.serviceWorker.register()</code>之后返回的期约会将注册成功的<code class="calibre11">ServiceWorkerRegistration</code>对象（注册对象）发送给处理函数。在同一页面使用同一URL多次调用该方法会返回相同的注册对象。</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">navigator.serviceworker.register('./serviceworker.js')
.then((registrationa) =&gt; {
  console.log(registrationa);

  navigator.serviceworker.register('./serviceworker2.js')
    .then((registrationb) =&gt; {
      console.log(registrationa === registrationb);
    });
});</code></pre>
            <p class="calibre1">
              <code class="calibre11">ServiceWorkerRegistration</code>支持以下事件处理程序。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">onupdatefound</code>：在服务工作者线程触发<code class="calibre11">updatefound</code>事件时会调用指定的事件处理程序。<ul class="calibre28">
                  <li class="di_1ji_wu_xu_lie_biao">此事件会在服务工作者线程开始安装新版本时触发，表现为<code class="calibre11">ServiceWorkerRegistration.installing</code>收到一个新的服务工作者线程。</li>
                  <li class="di_1ji_wu_xu_lie_biao">此事件也可以使用<code class="calibre11">serv serviceWorkerRegistration.addEventListener('updatefound', handler)</code>处理。</li>
                </ul>
              </li>
            </ul>
            <p class="calibre1">
              <code class="calibre11">ServiceWorkerRegistration</code>支持以下通用属性。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">scope</code>：返回服务工作者线程作用域的完整URL路径。该值源自接收服务脚本的路径和在<code class="calibre11">register()</code>中提供的作用域。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">navigationPreload</code>：返回与注册对象关联的<code class="calibre11">NavigationPreloadManager</code>实例。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">pushManager</code>：返回与注册对象关联的<code class="calibre11">pushManager</code>实例。</li>
            </ul>
            <p class="calibre1">
              <code class="calibre11">ServiceWorkerRegistration</code>还支持以下属性，可用于判断服务工作者线程处于生命周期的什么阶段。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">installing</code>：如果有则返回状态为<code class="calibre11">installing</code>（安装）的服务工作者线程，否则为<code class="calibre11">null</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">waiting</code>：如果有则返回状态为<code class="calibre11">waiting</code>（等待）的服务工作者线程，否则为<code class="calibre11">null</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">active</code>：如果有则返回状态<code class="calibre11">activating</code>或<code class="calibre11">active</code>（活动）的服务工作者线程，否则为<code class="calibre11">null</code>。</li>
            </ul>
            <p class="calibre1">注意，这些属性都是服务工作者线程状态的一次性快照。这在大多数情况下是没有问题的，因为活动状态的服务工作者线程在页面的生命周期内不会改变状态，除非强制这样做（比如调用<code class="calibre11">ServiceWorkerGlobalScope.skipWaiting()</code>）。</p>
            <p class="calibre1">
              <code class="calibre11">ServiceWorkerRegistration</code>支持下列方法。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">getNotifications()</code>：返回期约，解决为<code class="calibre11">Notification</code>对象的数组。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">showNotifications()</code>：显示通知，可以配置<code class="calibre11">title</code>和<code class="calibre11">options</code>参数。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">update()</code>：直接从服务器重新请求服务脚本，如果新脚本不同，则重新初始化。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">unregister()</code>：取消服务工作者线程的注册。该方法会在服务工作者线程执行完再取消注册。<br class="calibre4"/>
              </li>
            </ul>
          </li>
          <li value="5" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">使用<code class="calibre11">ServiceWorker</code>对象</strong>
            </p>
            <p class="calibre1">
              <code class="calibre11">ServiceWorker</code>对象可以通过两种方式获得：通过<code class="calibre11">ServiceWorkerContainer</code>对象的<code class="calibre11">controller</code>属性和通过<code class="calibre11">ServiceWorkerRegistration</code>的<code class="calibre11">active</code>属性。该对象继承<code class="calibre11">Worker</code>原型，因此包括其所有属性和方法，但没有<code class="calibre11">terminate()</code>方法。</p>
            <p class="calibre1">
              <code class="calibre11">ServiceWorker</code>支持以下事件处理程序。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">onstatechange</code>：<code class="calibre11">ServiceWorker</code>发生<code class="calibre11">statechange</code>事件时会调用指定的事件处理程序。<ul class="calibre28">
                  <li class="di_1ji_wu_xu_lie_biao">此事件会在<code class="calibre11">ServiceWorker.state</code>变化时发生。</li>
                  <li class="di_1ji_wu_xu_lie_biao">此事件也可以使用<code class="calibre11">serviceWorker.addEventListener('statechange', handler)</code>处理。</li>
                </ul>
              </li>
            </ul>
            <p class="calibre1">
              <code class="calibre11">ServiceWorker</code>支持以下属性。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">scriptURL</code>：解析后注册服务工作者线程的URL。例如，如果服务工作者线程是通过相对路径<code class="calibre11">'./serviceWorker.js'</code>创建的，且注册在https://www.example.com上，则<code class="calibre11">scriptURL</code>属性将返回<code class="calibre11">"https://www.example.com/serviceWorker.js"</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">state</code>：表示服务工作者线程状态的字符串，可能的值如下。<ul class="calibre28">
                  <li class="di_1ji_wu_xu_lie_biao">
                    <code class="calibre11">installing</code>
                  </li>
                  <li class="di_1ji_wu_xu_lie_biao">
                    <code class="calibre11">installed</code>
                  </li>
                  <li class="di_1ji_wu_xu_lie_biao">
                    <code class="calibre11">activating</code>
                  </li>
                  <li class="di_1ji_wu_xu_lie_biao">
                    <code class="calibre11">activated</code>
                  </li>
                  <li class="di_1ji_wu_xu_lie_biao">
                    <code class="calibre11">redundant</code><br class="calibre4"/>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li value="6" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">服务工作者线程的安全限制</strong>
            </p>
            <p class="calibre1">与其他工作者线程一样，服务工作者线程也受加载脚本对应源的常规限制（更多信息参见27.2.1节）。此外，由于服务工作者线程几乎可以任意修改和重定向网络请求，以及加载静态资源，服务工作者线程API只能在安全上下文（HTTPS）下使用。在非安全上下文（HTTP）中，<code class="calibre11">navigator.serviceWorker</code>是<code class="calibre11">undefined</code>。为方便开发，浏览器豁免了通过<code class="calibre11">localhost</code>或<code class="calibre11">127.0.0.1</code>在本地加载的页面的安全上下文规则。</p>
            <blockquote class="calibre13">
              <p class="calibre1">
                <strong class="calibre2">注意</strong>
                可以通过<code class="calibre11">window.isSecureContext</code>确定当前上下文是否安全。</p>
            </blockquote>
            <p class="calibre1"></p>
          </li>
          <li value="7" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">
                <code class="calibre11">ServiceWorkerGlobalScope</code>
              </strong>
            </p>
            <p class="calibre1">在服务工作者线程内部，全局上下文是<code class="calibre11">ServiceWorkerGlobalScope</code>的实例。<code class="calibre11">ServiceWorkerGlobalScope</code>继承自<code class="calibre11">WorkerGlobalScope</code>，因此拥有它的所有属性和方法。服务工作者线程可以通过self关键字访问该全局上下文。</p>
            <p class="calibre1">
              <code class="calibre11">ServiceWorkerGlobalScope</code>通过以下属性和方法扩展了<code class="calibre11">WorkerGlobalScope</code>。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">caches</code>：返回服务工作者线程的<code class="calibre11">CacheStorage</code>对象。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">clients</code>：返回服务工作者线程的<code class="calibre11">Clients</code>接口，用于访问底层<code class="calibre11">Client</code>对象。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">registration</code>：返回服务工作者线程的<code class="calibre11">ServiceWorkerRegistration</code>对象。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">skipWaiting()</code>：强制服务工作者线程进入活动状态；需要跟<code class="calibre11">Clients.claim()</code>一起使用。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">fetch()</code>：在服务工作者线程内发送常规网络请求；用于在服务工作者线程确定有必要发送实际网络请求（而不是返回缓存值）时。</li>
            </ul>
            <p class="calibre1">虽然专用工作者线程和共享工作者线程只有一个<code class="calibre11">message</code>事件作为输入，但服务工作者线程则可以接收很多事件，包括页面操作、通知操作触发的事件或推送事件。</p>
            <blockquote class="calibre13">
              <p class="calibre1">
                <strong class="calibre2">注意</strong>
                根据浏览器实现，在<code class="calibre11">SeviceWorker</code>中把日志打印到控制台不一定能在浏览器默认控制台中看到。</p>
            </blockquote>
            <p class="calibre1">服务工作者线程的全局作用域可以监听以下事件，这里进行了分类。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">
                <strong class="calibre2">服务工作者线程状态</strong>
                <ul class="calibre28">
                  <li class="di_1ji_wu_xu_lie_biao">
                    <code class="calibre11">install</code>：在服务工作者线程进入<strong class="calibre2">安装</strong>状态时触发（在客户端可以通过<code class="calibre11">ServiceWorkerRegistration.installing</code>判断）。也可以在<code class="calibre11">self.oninstall</code>属性上指定该事件的处理程序。<ul class="calibre37">
                      <li class="di_1ji_wu_xu_lie_biao">这是服务工作者线程接收的第一个事件，在线程一开始执行时就会触发。</li>
                      <li class="di_1ji_wu_xu_lie_biao">每个服务工作者线程只会调用一次。</li>
                    </ul>
                  </li>
                  <li class="di_1ji_wu_xu_lie_biao">act<code class="calibre11">i</code>vate：在服务工作者线程进入<strong class="calibre2">激活</strong>或<strong class="calibre2">已激活</strong>状态时触发（在客户端可以通过<code class="calibre11">ServiceWorkerRegistration.active</code>判断）。也可以在<code class="calibre11">self.onactive</code>属性上指定该事件的处理程序。<ul class="calibre37">
                      <li class="di_1ji_wu_xu_lie_biao">此事件在服务工作者线程准备好处理功能性事件和控制客户端时触发。</li>
                      <li class="di_1ji_wu_xu_lie_biao">此事件并<strong class="calibre2">不</strong>代表服务工作者线程在控制客户端，只表明具有控制客户端的条件。</li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li class="di_1ji_wu_xu_lie_biao">
                <strong class="calibre2">Fetch API</strong>
                <ul class="calibre28">
                  <li class="di_1ji_wu_xu_lie_biao">
                    <code class="calibre11">fetch</code>：在服务工作者线程截获来自主页面的<code class="calibre11">fetch()</code>请求时触发。服务工作者线程的<code class="calibre11">fetch</code>事件处理程序可以访问<code class="calibre11">FetchEvent</code>，可以根据需要调整输出。也可以在<code class="calibre11">self.onfetch</code>属性上指定该事件的处理程序。</li>
                </ul>
              </li>
              <li class="di_1ji_wu_xu_lie_biao">
                <strong class="calibre2">Message API</strong>
                <ul class="calibre28">
                  <li class="di_1ji_wu_xu_lie_biao">
                    <code class="calibre11">message</code>：在服务工作者线程通过<code class="calibre11">postMesssage()</code>获取数据时触发。也可以在<code class="calibre11">self.onmessage</code>属性上指定该事件的处理程序。</li>
                </ul>
              </li>
              <li class="di_1ji_wu_xu_lie_biao">
                <strong class="calibre2">Notification API</strong>
                <ul class="calibre28">
                  <li class="di_1ji_wu_xu_lie_biao">
                    <code class="calibre11">notificationclick</code>：在系统告诉浏览器用户点击了<code class="calibre11">ServiceWorkerRegistration.showNotification()</code>生成的通知时触发。也可以在<code class="calibre11">self.onnotificationclick</code>属性上指定该事件的处理程序。</li>
                  <li class="di_1ji_wu_xu_lie_biao">
                    <code class="calibre11">notificationclose</code>：在系统告诉浏览器用户关闭或取消显示了<code class="calibre11">ServiceWorkerRegistration.showNotification()</code>生成的通知时触发。也可以在<code class="calibre11">self.onnotificationclose</code>属性上指定该事件的处理程序。</li>
                </ul>
              </li>
              <li class="di_1ji_wu_xu_lie_biao">
                <strong class="calibre2">Push API</strong>
                <ul class="calibre28">
                  <li class="di_1ji_wu_xu_lie_biao">
                    <code class="calibre11">push</code>：在服务工作者线程接收到推送消息时触发。也可以在<code class="calibre11">self.onpush</code>属性上指定该事件的处理程序。</li>
                  <li class="di_1ji_wu_xu_lie_biao">
                    <code class="calibre11">pushsubscriptionchange</code>：在应用控制外的因素（非JavaScript显式操作）导致推送订阅状态变化时触发。也可以在<code class="calibre11">self.onpushsubscriptionchange</code>属性上指定该事件的处理程序。</li>
                </ul>
              </li>
            </ul>
            <blockquote class="calibre13">
              <p class="calibre1">
                <strong class="calibre2">注意</strong>
                有些浏览器也支持<code class="calibre11">async</code>事件，该事件是在Background Sync API中定义的。Background Sync API还没有标准化，目前只有Chrome和Opera支持，因此本书没介绍。</p>
            </blockquote>
            <p class="calibre1"></p>
          </li>
          <li value="8" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">服务工作者线程作用域限制</strong>
            </p>
            <p class="calibre1">服务工作者线程只能拦截其作用域内的客户端发送的请求。作用域是相对于获取服务脚本的路径定义的。如果没有在<code class="calibre11">register()</code>中指定，则作用域就是服务脚本的路径。</p>
            <p class="calibre1">（本章中涉及注册服务工作者线程的例子都使用脚本绝对URL，以避免混淆。）下面第一个例子演示通过根目录获取服务脚本对应的默认根作用域：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">navigator.serviceworker.register('/serviceworker.js')
.then((serviceworkerregistration) =&gt; {
  console.log(serviceworkerregistration.scope);
  // https://example.com/
});

// 以下请求都会被拦截：
// fetch('/foo.js');
// fetch('/foo/fooscript.js');
// fetch('/baz/bazscript.js');</code></pre>
            <p class="calibre1">下面的例子演示了通过根目录获取服务脚本但指定了同一目录作用域：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">navigator.serviceworker.register('/serviceworker.js', {scope: './'})
.then((serviceworkerregistration) =&gt; {
  console.log(serviceworkerregistration.scope);
  // https://example.com/
});

// 以下请求都会被拦截：
// fetch('/foo.js');
// fetch('/foo/fooscript.js');
// fetch('/baz/bazscript.js');</code></pre>
            <p class="calibre1">下面的例子演示了通过根目录获取服务脚本但限定了目录作用域：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">navigator.serviceworker.register('/serviceworker.js', {scope: './foo'})
.then((serviceworkerregistration) =&gt; {
  console.log(serviceworkerregistration.scope);
  // https://example.com/foo/
});

// 以下请求都会被拦截：
// fetch('/foo/fooscript.js');

// 以下请求都不会被拦截：
// fetch('/foo.js');
// fetch('/baz/bazscript.js');</code></pre>
            <p class="calibre1">下面的例子演示了通过嵌套的二级目录获取服务脚本对应的同一目录作用域：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">navigator.serviceworker.register('/foo/serviceworker.js')
.then((serviceworkerregistration) =&gt; {
  console.log(serviceworkerregistration.scope);
  // https://example.com/foo/
});

// 以下请求都会被拦截：
// fetch('/foo/fooscript.js');

// 以下请求都不会被拦截：
// fetch('/foo.js');
// fetch('/baz/bazscript.js');</code></pre>
            <p class="calibre1">服务工作者线程的作用域实际上遵循了目录权限模型，即只能相对于服务脚本所在路径缩小作用域。像下面这样扩展作用域会抛出错误：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">navigator.serviceworker.register('/foo/serviceworker.js', {scope: '/'});

// error: the path of the provided scope 'https://example.com/'
// is not under the max scope allowed 'https://example.com/foo/'</code></pre>
            <p class="calibre1">通常，服务工作者线程作用域会使用末尾带斜杠的绝对路径来定义，比如：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">navigator.serviceworker.register('/serviceworker.js', {scope: '/foo/'})</code></pre>
            <p class="calibre1">这样定义作用域有两个目的：将脚本文件的相对路径与作用域的相对路径分开，同时将该路径本身排除在作用域之外。例如，对于前面的代码片段而言，可能不需要在服务工作者线程的作用域中包含路径<code class="calibre11">/foo</code>。在末尾加上一个斜杠就可以明确排除<code class="calibre11">/foo</code>。当然，这要求绝对作用域路径不能扩展到服务工作者线程路径外。</p>
            <p class="calibre1">如果想扩展服务工作者线程的作用域，主要有两种方式。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">通过包含想要的作用域的路径提供（获取）服务脚本。</li>
              <li class="di_1ji_wu_xu_lie_biao">给服务脚本的响应添加<code class="calibre11">Service-Worker-Allowed</code>头部，把它的值设置为想要的作用域。该作用域值应该与<code class="calibre11">register()</code>中的作用域值一致。</li>
            </ul>
          </li>
        </ol>
        <h3 id="nav_point_656" class="calibre15">27.4.2 服务工作者线程缓存</h3>
        <p class="calibre1">在服务工作者线程之前，网页缺少缓存网络请求的稳健机制。浏览器一直使用HTTP缓存，但HTTP缓存并没有对JavaScript暴露编程接口，且其行为是受JavaScript运行时外部控制的。可以开发临时缓存机制，缓存响应字符串或blob，但这种策略比较麻烦且效率低。</p>
        <p class="calibre1">JavaScript缓存的实现之前也有过尝试。MDN文档也介绍了：</p>
        <blockquote class="calibre13">
          <p class="calibre1">之前的尝试，即AppCache，看起来是个不错的想法，因为它支持非常容易地指定要缓存的资源。可是，它对你想要做的事情做了很多假设，当应用程序没有完全遵循这些假设时，它就崩溃了。</p>
        </blockquote>
        <p class="calibre1">服务工作者线程的一个主要能力是可以通过编程方式实现真正的网络请求缓存机制。与HTTP缓存或CPU缓存不同，服务工作者线程缓存非常简单。</p>
        <ul class="calibre10">
          <li class="di_1ji_wu_xu_lie_biao">
            <strong class="calibre2">服务工作者线程缓存不自动缓存任何请求</strong>。所有缓存都必须明确指定。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <strong class="calibre2">服务工作者线程缓存没有到期失效的概念</strong>。除非明确删除，否则缓存内容一直有效。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <strong class="calibre2">服务工作者线程缓存必须手动更新和删除</strong>。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <strong class="calibre2">缓存版本必须手动管理</strong>。每次服务工作者线程更新，新服务工作者线程负责提供新的缓存键以保存新缓存。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <strong class="calibre2">唯一的浏览器强制逐出策略基于服务工作者线程缓存占用的空间</strong>。服务工作者线程负责管理自己缓存占用的空间。缓存超过浏览器限制时，浏览器会基于最近最少使用（LRU，Least Recently Used）原则为新缓存腾出空间。</li>
        </ul>
        <p class="calibre1">本质上，服务工作者线程缓存机制是一个双层字典，其中顶级字典的条目映射到二级嵌套字典。顶级字典是<code class="calibre11">CacheStorage</code>对象，可以通过服务工作者线程全局作用域的<code class="calibre11">caches</code>属性访问。顶级字典中的每个值都是一个<code class="calibre11">Cache</code>对象，该对象也是个字典，是<code class="calibre11">Request</code>对象到<code class="calibre11">Response</code>对象的映射。</p>
        <p class="calibre1">与<code class="calibre11">LocalStorage</code>一样，<code class="calibre11">Cache</code>对象在<code class="calibre11">CacheStorage</code>字典中无限期存在，会超出浏览器会话的界限。此外，<code class="calibre11">Cache</code>条目只能以源为基础存取。</p>
        <blockquote class="calibre13">
          <p class="calibre1">
            <strong class="calibre2">注意</strong>
            虽然<code class="calibre11">CacheStorage</code>和<code class="calibre11">Cache</code>对象是在<code class="calibre11">Service Worker</code>规范中定义的，但它们也可以在主页面或其他工作者线程中使用。</p>
        </blockquote>
        <ol class="calibre16">
          <li value="1" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">
                <code class="calibre11">CacheStorage</code>对象</strong>
            </p>
            <p class="calibre1">
              <code class="calibre11">CacheStorage</code>对象是映射到<code class="calibre11">Cache</code>对象的字符串键/值存储。<code class="calibre11">CacheStorage</code>提供的API类似于异步<code class="calibre11">Map</code>。<code class="calibre11">CacheStorage</code>的接口通过全局对象的<code class="calibre11">caches</code>属性暴露出来。</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">console.log(caches); // cachestorage {}</code></pre>
            <p class="calibre1">
              <code class="calibre11">CacheStorage</code>中的每个缓存可以通过给<code class="calibre11">caches.open()</code>传入相应字符串键取得。非字符串键会转换为字符串。如果缓存不存在，就会创建。</p>
            <p class="calibre1">
              <code class="calibre11">Cache</code>对象是通过期约返回的：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">caches.open('v1').then(console.log);

// cache {}</code></pre>
            <p class="calibre1">与<code class="calibre11">Map</code>类似，<code class="calibre11">CacheStorage</code>也有<code class="calibre11">has()</code>、<code class="calibre11">delete()</code>和<code class="calibre11">keys()</code>方法。这些方法与<code class="calibre11">Map</code>上对应方法类似，但都基于期约。</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">// 打开新缓存v1
// 检查缓存v1是否存在
// 检查不存在的缓存v2

caches.open('v1')
.then(() =&gt; caches.has('v1'))
.then(console.log)   // true
.then(() =&gt; caches.has('v2'))
.then(console.log);  // false

// 打开新缓存v1
// 检查缓存v1是否存在
// 删除缓存v1
// 再次检查缓存v1是否存在

caches.open('v1')
.then(() =&gt; caches.has('v1'))
.then(console.log)   // true
.then(() =&gt; caches.delete('v1'))
.then(() =&gt; caches.has('v1'))
.then(console.log);  // false

// 打开缓存v1、v3和v2
// 检查当前缓存的键
// 注意：缓存键按创建顺序输出

caches.open('v1')
.then(() =&gt; caches.open('v3'))
.then(() =&gt; caches.open('v2'))
.then(() =&gt; caches.keys())
.then(console.log); // ["v1", "v3", "v2"]</code></pre>
            <p class="calibre1">
              <code class="calibre11">CacheStorage</code>接口还有一个<code class="calibre11">match()</code>方法，可以根据<code class="calibre11">Request</code>对象搜索<code class="calibre11">CacheStorage</code>中的所有<code class="calibre11">Cache</code>对象。搜索顺序是<code class="calibre11">CacheStorage.keys()</code>的顺序，返回匹配的第一个响应：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">// 创建一个请求键和两个响应值
const request = new request('');
const response1 = new response('v1');
const response2 = new response('v2');

// 用同一个键创建两个缓存对象，最终会先找到v1
// 因为它排在caches.keys()输出的前面
caches.open('v1')
.then((v1cache) =&gt; v1cache.put(request, response1))
.then(() =&gt; caches.open('v2'))
.then((v2cache) =&gt; v2cache.put(request, response2))
.then(() =&gt; caches.match(request))
.then((response) =&gt; response.text())
.then(console.log); // v1</code></pre>
            <p class="calibre1">
              <code class="calibre11">CacheStorage.match()</code>可以接收一个<code class="calibre11">options</code>配置对象。下一节会介绍该对象。<br class="calibre4"/>
            </p>
          </li>
          <li value="2" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">
                <code class="calibre11">Cache</code>对象</strong>
            </p>
            <p class="calibre1">
              <code class="calibre11">CacheStorage</code>通过字符串映射到<code class="calibre11">Cache</code>对象。<code class="calibre11">Cache</code>对象跟<code class="calibre11">CacheStorage</code>一样，类似于异步的<code class="calibre11">Map</code>。<code class="calibre11">Cache</code>键可以是<code class="calibre11">URL</code>字符串，也可以是<code class="calibre11">Request</code>对象。这些键会映射到<code class="calibre11">Response</code>对象。</p>
            <p class="calibre1">服务工作者线程缓存只考虑缓存HTTP的GET请求。这样是合理的，因为GET请求的响应通常不会随时间而改变。另一方面，默认情况下，<code class="calibre11">Cache</code>不允许使用POST、PUT和DELETE等请求方法。这些方法意味着与服务器动态交换信息，因此不适合客户端缓存。</p>
            <p class="calibre1">为填充<code class="calibre11">Cache</code>，可能使用以下三个方法。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">put(request, response)</code>：在键（<code class="calibre11">Request</code>对象或URL字符串）和值（<code class="calibre11">Response</code>对象）同时存在时用于添加缓存项。该方法返回期约，在添加成功后会解决。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">add(request)</code>：在只有<code class="calibre11">Request</code>对象或URL时使用此方法发送<code class="calibre11">fetch()</code>请求，并缓存响应。该方法返回期约，期约在添加成功后会解决。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">addAll(requests)</code>：在希望填充全部缓存时使用，比如在服务工作者线程初始化时也初始化缓存。该方法接收URL或<code class="calibre11">Request</code>对象的数组。<code class="calibre11">addAll()</code>会对请求数组中的每一项分别调用<code class="calibre11">add()</code>。该方法返回期约，期约在所有缓存内容添加成功后会解决。</li>
            </ul>
            <p class="calibre1">与<code class="calibre11">Map</code>类似，<code class="calibre11">Cache</code>也有<code class="calibre11">delete()</code>和<code class="calibre11">keys()</code>方法。这些方法与<code class="calibre11">Map</code>上对应方法类似，但都基于期约。</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">const request1 = new request('https://www.foo.com');
const response1 = new response('fooresponse');

caches.open('v1')
.then((cache) =&gt; {
  cache.put(request1, response1)
  .then(() =&gt; cache.keys())
  .then(console.log)  // [request]
  .then(() =&gt; cache.delete(request1))
  .then(() =&gt; cache.keys())
  .then(console.log); // []
});</code></pre>
            <p class="calibre1">要检索<code class="calibre11">Cache</code>，可以使用下面的两个方法。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">matchAll(request, options)</code>：返回期约，期约解决为匹配缓存中<code class="calibre11">Response</code>对象的数组。<ul class="calibre28">
                  <li class="di_1ji_wu_xu_lie_biao">此方法对结构类似的缓存执行批量操作，比如删除所有缓存在/images目录下的值。</li>
                  <li class="di_1ji_wu_xu_lie_biao">可以通过<code class="calibre11">options</code>对象配置请求匹配方式，本节稍后会介绍。</li>
                </ul>
              </li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">match(request, options)</code>：返回期约，期约解决为匹配缓存中的<code class="calibre11">Response</code>对象；如果没命中缓存则返回<code class="calibre11">undefined</code>。<ul class="calibre28">
                  <li class="di_1ji_wu_xu_lie_biao">本质上相当于<code class="calibre11">matchAll(request, options)[0]</code>。</li>
                  <li class="di_1ji_wu_xu_lie_biao">可以通过<code class="calibre11">options</code>对象配置请求匹配方式，本节稍后会介绍。</li>
                </ul>
              </li>
            </ul>
            <p class="calibre1">缓存是否命中取决于URL字符串和/或<code class="calibre11">Request</code>对象URL是否匹配。URL字符串和<code class="calibre11">Request</code>对象是可互换的，因为匹配时会提取<code class="calibre11">Request</code>对象的URL。下面的例子演示了这种互换性：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">const request1 = 'https://www.foo.com';
const request2 = new request('https://www.bar.com');

const response1 = new response('fooresponse');
const response2 = new response('barresponse');

caches.open('v1').then((cache) =&gt; {
  cache.put(request1, response1)
  .then(() =&gt; cache.put(request2, response2))
  .then(() =&gt; cache.match(new request('https://www.foo.com')))
  .then((response) =&gt; response.text())
  .then(console.log)  // fooresponse
  .then(() =&gt; cache.match('https://www.bar.com'))
  .then((response) =&gt; response.text())
  .then(console.log); // barresponse
});</code></pre>
            <p class="calibre1">
              <code class="calibre11">Cache</code>对象使用<code class="calibre11">Request</code>和<code class="calibre11">Response</code>对象的<code class="calibre11">clone()</code>方法创建副本，并把它们存储为键/值对。下面的例子演示了这一点，因为从缓存中取得的实例并不等于原始的键/值对：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">const request1 = new request('https://www.foo.com');
const response1 = new response('fooresponse');

caches.open('v1')
.then((cache) =&gt; {
  cache.put(request1, response1)
  .then(() =&gt; cache.keys())
  .then((keys) =&gt; console.log(keys[0] === request1))        // false
  .then(() =&gt; cache.match(request1))
  .then((response) =&gt; console.log(response === response1)); // false
});</code></pre>
            <p class="calibre1">
              <code class="calibre11">Cache.match()</code>、<code class="calibre11">Cache.matchAll()</code>和<code class="calibre11">CacheStorage.match()</code>都支持可选的<code class="calibre11">options</code>对象，它允许通过设置以下属性来配置URL匹配的行为。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">cacheName</code>：只有<code class="calibre11">CacheStorage.matchAll()</code>支持。设置为字符串时，只会匹配<code class="calibre11">Cache</code>键为指定字符串的缓存值。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">ignoreSearch</code>：设置为<code class="calibre11">true</code>时，在匹配URL时忽略查询字符串，包括请求查询和缓存键。例如，https://example.com?foo=bar会匹配https://example.com。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <p class="calibre1">
                  <code class="calibre11">ignoreMethod</code>：设置为<code class="calibre11">true</code>时，在匹配URL时忽略请求查询的HTTP方法。比如下面的例子展示了POST请求匹配GET请求：</p>
                <pre class="dai_ma_wu_xing_hao"><code class="calibre11">const request1 = new request('https://www.foo.com');
const response1 = new response('fooresponse');

const postrequest1 = new request('https://www.foo.com',
                                 { method: 'post' });

caches.open('v1')
.then((cache) =&gt; {
  cache.put(request1, response1)
  .then(() =&gt; cache.match(postrequest1))
  .then(console.log)  // undefined
  .then(() =&gt; cache.match(postrequest1, { ignoremethod: true }))
  .then(console.log); // response {}
});</code></pre>
              </li>
              <li class="di_1ji_wu_xu_lie_biao">
                <p class="calibre1">
                  <code class="calibre11">ignoreVary</code>：匹配的时候考虑HTTP的<code class="calibre11">Vary</code>头部，该头部指定哪个请求头部导致服务器响应不同的值。<code class="calibre11">ignoreVary</code>设置为<code class="calibre11">true</code>时，在匹配URL时忽略<code class="calibre11">Vary</code>头部。</p>
                <pre class="dai_ma_wu_xing_hao"><code class="calibre11">const request1 = new request('https://www.foo.com');
const response1 = new response('fooresponse',
                               { headers: {'vary': 'accept' }});

const acceptrequest1 = new request('https://www.foo.com',
                                   { headers: { 'accept': 'text/json' } });

caches.open('v1')
.then((cache) =&gt; {
  cache.put(request1, response1)
  .then(() =&gt; cache.match(acceptrequest1))
  .then(console.log)  // undefined
  .then(() =&gt; cache.match(acceptrequest1, { ignorevary: true }))
  .then(console.log); // response {}
});</code></pre>
                <p class="calibre1"></p>
              </li>
            </ul>
          </li>
          <li value="3" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">最大存储空间</strong>
            </p>
            <p class="calibre1">浏览器需要限制缓存占用的磁盘空间，否则无限制存储势必会造成滥用。该存储空间的限制没有任何规范定义，完全由浏览器供应商的个人喜好决定。</p>
            <p class="calibre1">使用StorageEstimate API可以近似地获悉有多少空间可用（以字节为单位），以及当前使用了多少空间。此方法只在安全上下文中可用：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">navigator.storage.estimate()
.then(console.log);

// 不同浏览器的输出可能不同：
// { quota: 2147483648, usage: 590845 }</code></pre>
            <p class="calibre1">根据Service Worker规范：</p>
            <blockquote class="calibre13">
              <p class="calibre1">这些并不是确切的数值，考虑到压缩、去重和混淆等安全原因，该数字并不精确。</p>
            </blockquote>
          </li>
        </ol>
        <h3 id="nav_point_657" class="calibre15">27.4.3 服务工作者线程客户端</h3>
        <p class="calibre1">服务工作者线程会使用<code class="calibre11">Client</code>对象跟踪关联的窗口、工作线程或服务工作者线程。服务工作者线程可以通过<code class="calibre11">Clients</code>接口访问这些<code class="calibre11">Client</code>对象。该接口暴露在全局上下文的<code class="calibre11">self.clients</code>属性上。</p>
        <p class="calibre1">
          <code class="calibre11">Client</code>对象支持以下属性和方法。</p>
        <ul class="calibre10">
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">id</code>：返回客户端的全局唯一标识符，例如<code class="calibre11">7e4248ec-b25e-4b33-b15f-4af8bb0a3ac4</code>。<code class="calibre11">id</code>可用于通过<code class="calibre11">Client.get()</code>获取客户端的引用。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">type</code>：返回表示客户端类型的字符串。<code class="calibre11">type</code>可能的值是<code class="calibre11">window</code>、<code class="calibre11">worker</code>或<code class="calibre11">sharedworker</code>。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">url</code>：返回客户端的URL。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">postMessage()</code>：用于向单个客户端发送消息。</li>
        </ul>
        <p class="calibre1">
          <code class="calibre11">Clients</code>接口支持通过<code class="calibre11">get()</code>或<code class="calibre11">matchAll()</code>访问<code class="calibre11">Client</code>对象。这两个方法都通过期约返回结果。<code class="calibre11">matchAll()</code>也可以接收<code class="calibre11">options</code>对象，该对象支持以下属性。</p>
        <ul class="calibre10">
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">includeUncontrolled</code>：在设置为<code class="calibre11">true</code>时，返回结果包含不受当前服务工作者线程控制的客户端。默认为<code class="calibre11">false</code>。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">type</code>：可以设置为<code class="calibre11">window</code>、<code class="calibre11">worker</code>或<code class="calibre11">sharedworker</code>，对返回结果进行过滤。默认为<code class="calibre11">all</code>，返回所有类型的客户端。</li>
        </ul>
        <p class="calibre1">
          <code class="calibre11">Clients</code>接口也支持以下方法。</p>
        <ul class="calibre10">
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">openWindow(url)</code>：在新窗口中打开指定URL，实际上会给当前服务工作者线程添加一个新<code class="calibre11">Client</code>。这个新<code class="calibre11">Client</code>对象以解决的期约形式返回。该方法可用于回应点击通知的操作，此时服务工作者线程可以检测单击事件并作为响应打开一个窗口。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">claim()</code>：强制性设置当前服务工作者线程以控制其作用域中的所有客户端。<code class="calibre11">claim()</code>可用于不希望等待页面重新加载而让服务工作者线程开始管理页面。</li>
        </ul>
        <h3 id="nav_point_658" class="calibre15">27.4.4 服务工作者线程与一致性</h3>
        <p class="calibre1">理解服务工作者线程最终用途十分重要：让网页能够模拟原生应用程序。要像原生应用程序一样，服务工作者线程必须支持<strong class="calibre2">版本控制</strong>（versioning）。</p>
        <p class="calibre1">从全局角度说，服务工作者线程的版本控制可以确保任何时候两个网页的操作都有<strong class="calibre2">一致性</strong>。该一致性可以表现为如下两种形式。</p>
        <ul class="calibre10">
          <li class="di_1ji_wu_xu_lie_biao">
            <strong class="calibre2">代码一致性</strong>。网页不是像原生应用程序那样基于一个二进制文件创建，而是由很多HTML、CSS、JavaScript、图片、JSON，以及页面可能加载的任何类型的文件创建。网页经常会递增更新，即版本升级，以增加或修改行为。如果网页总共加载了100个文件，而加载的资源同时来自第1版和第2版，那么就会导致完全无法预测，而且很可能出错。服务工作者线程为此提供了一种强制机制，确保来自同源的所有并存页面始终会使用来自相同版本的资源。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <strong class="calibre2">数据一致性</strong>。网页并非与外界隔绝的应用程序。它们会通过各种浏览器API如<code class="calibre11">LocalStorage</code>或<code class="calibre11">IndexedDB</code>在本地读取并写入数据；也会向远程API发送请求并获取数据。这些获取和写入数据的格式在不同版本中可能也会变化。如果一个页面以第1版中的格式写入了数据，第二个页面以第2版中的格式读取该数据就会导致无法预测的结果甚至出错。服务工作者线程的资源一致性机制可以保证网页输入/输出行为对同源的所有并存网页都相同。</li>
        </ul>
        <p class="calibre1">为确保一致性，服务工作者线程的生命周期不遗余力地避免出现有损一致性的现象。比如下面这些可能。</p>
        <ul class="calibre10">
          <li class="di_1ji_wu_xu_lie_biao">
            <strong class="calibre2">服务工作者线程提早失败</strong>。在安装服务工作者线程时，任何预料之外的问题都可能阻止服务工作者线程成功安装。包括服务脚本加载失败、服务脚本中存在语法或运行时错误、无法通过<code class="calibre11">importScripts()</code>加载工作者线程依赖，甚至加载某个缓存资源失败。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <strong class="calibre2">服务工作者线程激进更新</strong>。浏览器再次加载服务脚本时（无论通过<code class="calibre11">register()</code>手动加载还是基于页面重载），服务脚本<strong class="calibre2">或</strong>通过<code class="calibre11">importScripts()</code>加载的依赖中哪怕有一个字节的差异，也会启动安装新版本的服务工作者线程。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <strong class="calibre2">未激活服务工作者线程消极活动</strong>。当页面上第一次调用<code class="calibre11">register()</code>时，服务工作者线程会被安装，但不会被激活，并且在导航事件发生前不会控制页面。这应该是合理的：可以认为当前页面已加载了资源，因此服务工作者线程不应该被激活，否则就会加载不一致的资源。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <strong class="calibre2">活动的服务工作者线程粘连</strong>。只要至少有一个客户端与关联到活动的服务工作者线程，浏览器就会在该源的所有页面中使用它。浏览器可以安装新服务工作者线程实例以替代这个活动的实例，但浏览器在与活动实例关联的客户端为0（或强制更新服务工作者线程）之前不会切换到新工作者线程。这个服务工作者线程逐出策略能够防止两个客户端同时运行两个不同版本的服务工作者线程。</li>
        </ul>
        <h3 id="nav_point_659" class="calibre15">27.4.5 理解服务工作者线程的生命周期</h3>
        <p class="calibre1">Service Worker规范定义了6种服务工作者线程可能存在的状态：<strong class="calibre2">已解析</strong>（parsed）、<strong class="calibre2">安装中</strong>（installing）、<strong class="calibre2">已安装</strong>（installed）、<strong class="calibre2">激活中</strong>（activating）、<strong class="calibre2">已激活</strong>（activated）和<strong class="calibre2">已失效</strong>（redundant）。完整的服务工作者线程生命周期会以该顺序进入相应状态，尽管有可能不会进入每个状态。安装或激活服务工作者线程时遇到错误会跳到<strong class="calibre2">已失效</strong>状态。</p>
        <p class="calibre1">上述状态的每次变化都会在<code class="calibre11">ServiceWorker</code>对象上触发<code class="calibre11">statechange</code>事件，可以像下面这样为它添加一个事件处理程序：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">navigator.serviceworker.register('./serviceworker.js')
.then((registration) =&gt; {
  registration.installing.onstatechange = ({ target: { state } }) =&gt; {
    console.log('state changed to', state);
  };
});</code></pre>
        <ol class="calibre16">
          <li value="1" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">已解析状态</strong>
            </p>
            <p class="calibre1">调用<code class="calibre11">navigator.serviceWorker.register()</code>会启动创建服务工作者线程实例的过程。刚创建的服务工作者线程实例会进入<strong class="calibre2">已解析</strong>状态。该状态没有事件，也没有与之相关的<code class="calibre11">ServiceWorker.state</code>值。</p>
            <blockquote class="calibre13">
              <p class="calibre1">
                <strong class="calibre2">注意</strong>
                虽然<strong class="calibre2">已解析</strong>（<code class="calibre11">parsed</code>）是Service Worker规范正式定义的一个状态，但<code class="calibre11">ServiceWorker.prototype.state</code>永远不会返回<code class="calibre11">"parsed"</code>。通过该属性能够返回的最早阶段是<code class="calibre11">installing</code>。</p>
            </blockquote>
            <p class="calibre1">浏览器获取脚本文件，然后执行一些初始化任务，服务工作者线程的生命周期就开始了。</p>
            <p class="calibre1">(1) 确保服务脚本来自相同的源。</p>
            <p class="calibre1">(2) 确保在安全上下文中注册服务工作者线程。</p>
            <p class="calibre1">(3) 确保服务脚本可以被浏览器JavaScript解释器成功解析而不会抛出任何错误。</p>
            <p class="calibre1">(4) 捕获服务脚本的快照。下一次浏览器下载到服务脚本，会与这个快照对比差异，并据此决定是否应该更新服务工作者线程。</p>
            <p class="calibre1">所有这些任务全部成功，则<code class="calibre11">register()</code>返回的期约会解决为一个<code class="calibre11">ServiceWorkerRegistration</code>对象。新创建的服务工作者线程实例进入到安装中状态。<br class="calibre4"/>
            </p>
          </li>
          <li value="2" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">安装中状态</strong>
            </p>
            <p class="calibre1">
              <strong class="calibre2">安装中</strong>状态是执行所有服务工作者线程设置任务的状态。这些任务包括在服务工作者线程控制页面前必须完成的操作。</p>
            <p class="calibre1">在客户端，这个阶段可以通过检查<code class="calibre11">ServiceWorkerRegistration.installing</code>是否被设置为<code class="calibre11">ServiceWorker</code>实例：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">navigator.serviceworker.register('./serviceworker.js')
.then((registration) =&gt; {
  if (registration.installing) {
    console.log('service worker is in the installing state');
  }
});</code></pre>
            <p class="calibre1">关联的<code class="calibre11">ServiceWorkerRegistration</code>对象也会在服务工作者线程到达该状态时触发<code class="calibre11">updatefound</code>事件：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">navigator.serviceworker.register('./serviceworker.js')
.then((registration) =&gt; {
  registration.onupdatefound = () =&gt;
    console.log('service worker is in the installing state');
  };
});</code></pre>
            <p class="calibre1">在服务工作者线程中，这个阶段可以通过给<code class="calibre11">install</code>事件添加处理程序来确定：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">self.oninstall = (installevent) =&gt; {
  console.log('service worker is in the installing state');
};</code></pre>
            <p class="calibre1">
              <strong class="calibre2">安装中</strong>状态频繁用于填充服务工作者线程的缓存。服务工作者线程在成功缓存指定资源之前可以一直处于该状态。如果任何资源缓存失败，服务工作者线程都会安装失败并跳至<strong class="calibre2">已失效</strong>状态。</p>
            <p class="calibre1">服务工作者线程可以通过<code class="calibre11">ExtendableEvent</code>停留在安装中状态。<code class="calibre11">InstallEvent</code>继承自<code class="calibre11">ExtendableEvent</code>，因此暴露了一个API，允许将状态过渡延迟到期约解决。为此要调用<code class="calibre11">ExtendableEvent.waitUntil()</code>方法，该方法接收一个期约参数，会将状态过渡延迟到这个期约解决。例如，下面的例子可以延迟5秒再将状态过渡到<strong class="calibre2">已安装</strong>状态：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">self.oninstall = (installevent) =&gt; {
  installevent.waituntil(
    new promise((resolve, reject) =&gt; settimeout(resolve, 5000))
  );
};</code></pre>
            <p class="calibre1">更接近实际的例子是通过<code class="calibre11">Cache.addAll()</code>缓存一组资源之后再过渡：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">const cache_key = 'v1';

self.oninstall = (installevent) =&gt; {
  installevent.waituntil(
    caches.open(cache_key)
    .then((cache) =&gt; cache.addall([
      'foo.js',
      'bar.html',
      'baz.css',
    ]))
  );
};</code></pre>
            <p class="calibre1">如果没有错误发生或者没有拒绝，服务工作者线程就会前进到<strong class="calibre2">已安装</strong>状态。<br class="calibre4"/>
            </p>
          </li>
          <li value="3" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">已安装状态</strong>
            </p>
            <p class="calibre1">
              <strong class="calibre2">已安装</strong>状态也称为<strong class="calibre2">等待中</strong>（waiting）状态，意思是服务工作者线程此时没有别的事件要做，只是准备在得到许可的时候去控制客户端。如果没有活动的服务工作者线程，则新安装的服务工作者线程会跳到这个状态，并直接进入<strong class="calibre2">激活中</strong>状态，因为没有必要再等了。</p>
            <p class="calibre1">在客户端，这个阶段可以通过检查<code class="calibre11">ServiceWorkerRegistration.waiting</code>是否被设置为一个<code class="calibre11">ServiceWorker</code>实例来确定：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">navigator.serviceworker.register('./serviceworker.js')
.then((registration) =&gt; {
  if (registration.waiting) {
    console.log('service worker is in the installing/waiting state');
  }
});</code></pre>
            <p class="calibre1">如果已有了一个活动的服务工作者线程，则<strong class="calibre2">已安装</strong>状态是触发逻辑的好时机，这样会把这个新服务工作者线程推进到<strong class="calibre2">激活中</strong>状态。可以通过<code class="calibre11">self.skipWaiting()</code>强制推进服务工作者线程的状态，也可以通过提示用户重新加载应用程序，从而使浏览器可以按部就班地推进。<br class="calibre4"/>
            </p>
          </li>
          <li value="4" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">激活中状态</strong>
            </p>
            <p class="calibre1">
              <strong class="calibre2">激活中</strong>状态表示服务工作者线程已经被浏览器选中即将变成可以控制页面的服务工作者线程。如果浏览器中没有活动服务工作者线程，这个新服务工作者线程会自动到达激活中状态。如果有一个活动服务工作者线程，则这个作为替代的服务工作者线程可以通过如下方式进入激活中状态。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">原有服务工作者线程控制的客户端数量变为0。这通常意味着所有受控的浏览器标签页都被关闭。在下一个导航事件时，新服务工作者线程会到达激活中状态。</li>
              <li class="di_1ji_wu_xu_lie_biao">已安装的服务工作者线程调用<code class="calibre11">self.skipWaiting()</code>。这样可以立即生效，而不必等待一次导航事件。</li>
            </ul>
            <p class="calibre1">在激活中状态下，不能像已激活状态中那样执行发送请求或推送事件的操作。</p>
            <p class="calibre1">在客户端，这个阶段大致可以通过检查<code class="calibre11">ServiceWorkerRegistration.active</code>是否被设置为一个<code class="calibre11">ServiceWorker</code>实例来确定：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">navigator.serviceworker.register('./serviceworker.js')
.then((registration) =&gt; {
  if (registration.active) {
    console.log('service worker is in the activating/activated state');
  }
});</code></pre>
            <p class="calibre1">注意，<code class="calibre11">ServiceWorkerRegistration.active</code>属性表示服务工作者线程可能在激活中状态，也可能在已激活状态。</p>
            <p class="calibre1">在这个服务工作者线程内部，可以通过给<code class="calibre11">activate</code>事件添加处理程序来获悉：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">self.oninstall = (activateevent) =&gt; {
  console.log('service worker is in the activating state');
};</code></pre>
            <p class="calibre1">
              <code class="calibre11">activate</code>事件表示可以将老服务工作者线程清理掉了，该事件经常用于清除旧缓存数据和迁移数据库。例如，下面的代码清除了所有版本比较老的缓存：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">const cache_key = 'v3';

self.oninstall = (activateevent) =&gt; {
  caches.keys()
  .then((keys) =&gt; keys.filter((key) =&gt; key != cache_key))
  .then((oldkeys) =&gt; oldkeys.foreach((oldkey) =&gt; caches.delete(oldkey));
};</code></pre>
            <p class="calibre1">
              <code class="calibre11">activate</code>事件也继承自<code class="calibre11">ExtendableEvent</code>，因此也支持<code class="calibre11">waitUntil()</code>方法，可以延迟过渡到<strong class="calibre2">已激活</strong>状态，或者基于期约拒绝过渡到已失效状态。</p>
            <blockquote class="calibre13">
              <p class="calibre1">
                <strong class="calibre2">注意</strong>
                服务工作者线程中的<code class="calibre11">activate</code>事件并不代表服务工作者线程正在控制客户端。</p>
            </blockquote>
            <p class="calibre1"></p>
          </li>
          <li value="5" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">已激活状态</strong>
            </p>
            <p class="calibre1">
              <strong class="calibre2">已激活</strong>状态表示服务工作者线程正在控制一个或多个客户端。在这个状态，服务工作者线程会捕获其作用域中的<code class="calibre11">fetch()</code>事件、通知和推送事件。</p>
            <p class="calibre1">在客户端，这个阶段大致可以通过检查<code class="calibre11">ServiceWorkerRegistration.active</code>是否被设置为一个<code class="calibre11">ServiceWorker</code>实例来确定：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">navigator.serviceworker.register('./serviceworker.js')
.then((registration) =&gt; {
  if (registration.active) {
    console.log('service worker is in the activating/activated state');
  }
});</code></pre>
            <p class="calibre1">注意，<code class="calibre11">ServiceWorkerRegistration.active</code>属性表示服务工作者线程可能在<strong class="calibre2">激活中</strong>状态，也可能在<strong class="calibre2">已激活</strong>状态。</p>
            <p class="calibre1">更可靠的确定服务工作者线程处于已激活状态一种方式是检查<code class="calibre11">ServiceWorkerRegistration</code>的<code class="calibre11">controller</code>属性。该属性会返回激活的<code class="calibre11">ServiceWorker</code>实例，即控制页面的实例：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">navigator.serviceworker.register('./serviceworker.js')
.then((registration) =&gt; {
  if (registration.controller) {
    console.log('service worker is in the activated state');
  }
});</code></pre>
            <p class="calibre1">在新服务工作者线程控制客户端时，该客户端中的<code class="calibre11">ServiceWorkerContainer</code>会触发<code class="calibre11">controllerchange</code>事件：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">navigator.serviceworker.oncontrollerchange = () =&gt; {
  console.log('a new service worker is controlling this client');
};</code></pre>
            <p class="calibre1">另外，也可以使用<code class="calibre11">ServiceWorkerContainer.ready</code>期约来检测活动服务工作者线程。该期约会在当前页面拥有活动工作者线程时立即解决：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">navigator.serviceworker.ready.then(() =&gt; {
  console.log('a new service worker is controlling this client');
});</code></pre>
            <p class="calibre1"></p>
          </li>
          <li value="6" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">已失效状态</strong>
            </p>
            <p class="calibre1">
              <strong class="calibre2">已失效</strong>状态表示服务工作者线程已被宣布死亡。不会再有事件发送给它，浏览器随时可能销毁它并回收它的资源。<br class="calibre4"/>
            </p>
          </li>
          <li value="7" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">更新服务工作者线程</strong>
            </p>
            <p class="calibre1">因为版本控制的概念根植于服务工作者线程的整个生命周期，所以服务工作者线程会随着版本变化。为此，服务工作者线程提供了稳健同时也复杂的流程，以安装替换过时的服务工作者线程。</p>
            <p class="calibre1">这个更新流程的初始阶段是更新检查，也就是浏览器重新请求服务脚本。以下事件可以触发更新检查。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">以创建当前活动服务工作者线程时不一样的URL调用<code class="calibre11">navigator.serviceWorker.register()</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">浏览器导航到服务工作者线程作用域中的一个页面。</li>
              <li class="di_1ji_wu_xu_lie_biao">发生了<code class="calibre11">fetch()</code>或<code class="calibre11">push()</code>等功能性事件，<strong class="calibre2">且</strong>至少24小时内没有发生更新检查。</li>
            </ul>
            <p class="calibre1">新获取的服务脚本会与当前服务工作者线程的脚本比较差异。如果不相同，浏览器就会用新脚本初始化一个新的服务工作者线程。更新的服务工作者线程进入自己的生命周期，直至抵达<strong class="calibre2">已安装</strong>状态。到达<strong class="calibre2">已安装</strong>状态后，更新服务工作者线程会等待浏览器决定让它安全地获得页面的控制权（或用户强制它获得页面控制权）。</p>
            <p class="calibre1">关键在于，刷新页面<strong class="calibre2">不</strong>会让更新服务工作者线程进入激活状态并取代已有的服务工作者线程。比如，有个打开的页面，其中有一个服务工作者线程正在控制它，而一个更新服务工作者线程正在<strong class="calibre2">已安装</strong>状态中等待。客户端在页面刷新期间会发生重叠，即旧页面还没有卸载，新页面已加载了。因此，现有的服务工作者线程永远不会让出控制权，毕竟至少还有一个客户端在它的控制之下。为此，取代现有服务工作者线程唯一的方式就是关闭所有受控页面。</p>
          </li>
        </ol>
        <h3 id="nav_point_660" class="calibre15">27.4.6 控制反转与服务工作者线程持久化</h3>
        <p class="calibre1">虽然专用工作者线程和共享工作者线程是有状态的，但服务工作者线程是无状态的。更具体地说，服务工作者线程遵循控制反转（IoC，Inversion of Control）模式并且是事件驱动的。</p>
        <p class="calibre1">这样就意味着服务工作者线程不应该依赖工作者线程的全局状态。服务工作者线程中的绝大多数代码应该在事件处理程序中定义。当然，服务工作者线程的版本作为全局常量是个显而易见的例外。服务脚本执行的次数变化很大，高度依赖浏览器状态，因此服务脚本的行为应该是幂等的。</p>
        <p class="calibre1">理解服务工作者线程的生命周期与它所控制的客户端的生命周期无关非常重要。大多数浏览器将服务工作者线程实现为独立的进程，而该进程由浏览器单独控制。如果浏览器检测到某个服务工作者线程空闲了，就可以终止它并在需要时再重新启动。这意味着可以依赖服务工作者线程在激活后处理事件，但不能依赖它们的持久化全局状态。</p>
        <h3 id="nav_point_661" class="calibre15">27.4.7 通过<code class="calibre26">updateViaCache</code>管理服务文件缓存</h3>
        <p class="calibre1">正常情况下，浏览器加载的所有JavaScript资源会按照它们的<code class="calibre11">Cache-Control</code>头部纳入HTTP缓存管理。因为服务脚本没有优先权，所以浏览器不会在缓存文件失效前接收更新的服务脚本。</p>
        <p class="calibre1">为了尽可能传播更新后的服务脚本，常见的解决方案是在响应服务脚本时设置<code class="calibre11">Cache-Control: max-age=0</code>头部。这样浏览器就能始终取得最新的脚本文件。</p>
        <p class="calibre1">这个即时失效的方案能够满足需求，但仅仅依靠HTTP头部来决定是否更新意味着只能由服务器控制客户端。为了让客户端能控制自己的更新行为，可以通过<code class="calibre11">updateViaCache</code>属性设置客户端对待服务脚本的方式。该属性可以在注册服务工作者线程时定义，可以是如下三个字符串值。</p>
        <ul class="calibre10">
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">imports</code>：默认值。顶级服务脚本永远不会被缓存，但通过<code class="calibre11">importScripts()</code>在服务工作者线程内部导入的文件会按照<code class="calibre11">Cache-Control</code>头部设置纳入HTTP缓存管理。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">all</code>：服务脚本没有任何特殊待遇。所有文件都会按照<code class="calibre11">Cache-Control</code>头部设置纳入HTTP缓存管理。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">none</code>：顶级服务脚本和通过<code class="calibre11">importScripts()</code>在服务工作者线程内部导入的文件永远都不会被缓存。</li>
        </ul>
        <p class="calibre1">可以像下面这样使用<code class="calibre11">updateViaCache</code>属性：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">navigator.serviceworker.register('/serviceworker.js', {
  updateviacache: 'none'
});</code></pre>
        <p class="calibre1">浏览器仍在渐进地支持这个选项，因此强烈推荐读者同时使用<code class="calibre11">updateViaCache</code>和<code class="calibre11">CacheControl</code>头部指定客户端的缓存行为。</p>
        <h3 id="nav_point_662" class="calibre15">27.4.8 强制性服务工作者线程操作</h3>
        <p class="calibre1">某些情况下，有必要尽可能快地让服务工作者线程进入已激活状态，即使可能会造成资源版本控制不一致。该操作通常适合在安装事件中缓存资源，此时要强制服务工作者线程进入活动状态，然后再强制活动服务工作者线程去控制关联的客户端。</p>
        <p class="calibre1">实现上述操作的基本代码如下。</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">const cache_key = 'v1';

self.oninstall = (installevent) =&gt; {
  // 填充缓存，然后强制服务工作者线程进入已激活状态
  // 这样会触发activate事件
  installevent.waituntil(
    caches.open(cache_key)
    .then((cache) =&gt; cache.addall([
      'foo.css',
      'bar.js',
    ]))
    .then(() =&gt; self.skipwaiting())
  );
};

// 强制服务工作者线程接管客户端
// 这会在每个客户端触发controllerchange事件
self.onactivate = (activateevent) =&gt; clients.claim();</code></pre>
        <p class="calibre1">浏览器会在每次导航事件中检查新服务脚本，但有时候这样也太不够了。<code class="calibre11">ServiceWorkerRegistration</code>对象为此提供了一个<code class="calibre11">update()</code>方法，可以用来告诉浏览器去重新获取服务脚本，与现有的比较，然后必要时安装更新的服务工作者线程。可以这样来实现：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">navigator.serviceworker.register('./serviceworker.js')
.then((registration) =&gt; {
  // 每17分钟左右检查一个更新版本
  setinterval(() =&gt; registration.update(), 1e6);
});</code></pre>
        <h3 id="nav_point_663" class="calibre15">27.4.9 服务工作者线程消息</h3>
        <p class="calibre1">与专用工作者线程和共享工作者线程一样，服务工作者线程也能与客户端通过<code class="calibre11">postMessage()</code>交换消息。实现通信的最简单方式是向活动工作者线程发送一条消息，然后使用事件对象发送回应。发送给服务工作者线程的消息可以在全局作用域处理，而发送回客户端的消息则可以在<code class="calibre11">ServiceWorkerContext</code>对象上处理：</p>
        <p class="calibre1">
          <strong class="calibre2">ServiceWorker.js</strong>
        </p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">self.onmessage = ({data, source}) =&gt; {
  console.log('service worker heard:', data);

  source.postmessage('bar');
};</code></pre>
        <p class="calibre1">
          <strong class="calibre2">main.js</strong>
        </p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">navigator.serviceworker.onmessage = ({data}) =&gt; {
  console.log('client heard:', data);
};

navigator.serviceworker.register('./serviceworker.js')
.then((registration) =&gt; {
  if (registration.active) {
    registration.active.postmessage('foo');
  }
});

// service worker heard: foo
// client heard: bar</code></pre>
        <p class="calibre1">也可以简单地使用<code class="calibre11">serviceWorker.controller</code>属性：</p>
        <p class="calibre1">
          <strong class="calibre2">ServiceWorker.js</strong>
        </p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">self.onmessage = ({data, source}) =&gt; {
  console.log('service worker heard:', data);

  source.postmessage('bar');
};</code></pre>
        <p class="calibre1">
          <strong class="calibre2">main.js</strong>
        </p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">navigator.serviceworker.onmessage = ({data}) =&gt; {
  console.log('client heard:', data);
};

navigator.serviceworker.register('./serviceworker.js')
.then(() =&gt; {
  if (navigator.serviceworker.controller) {
    navigator.serviceworker.controller.postmessage('foo');
  }
});

// service worker heard: foo
// client heard: bar</code></pre>
        <p class="calibre1">前面的例子在每次页面重新加载时都会运行。这是因为服务工作者线程会回应每次刷新后客户端脚本发送的消息。在通过新标签页打开这个页面时也一样。</p>
        <p class="calibre1">如果服务工作者线程需要率先发送消息，可以像下面这样获得客户端的引用：</p>
        <p class="calibre1">
          <strong class="calibre2">ServiceWorker.js</strong>
        </p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">self.onmessage = ({data}) =&gt; {
  console.log('service worker heard:', data);
};

self.onactivate = () =&gt; {
  self.clients.matchall({includeuncontrolled: true})
  .then((clientmatches) =&gt; clientmatches[0].postmessage('foo'));
};</code></pre>
        <p class="calibre1">
          <strong class="calibre2">main.js</strong>
        </p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">navigator.serviceworker.onmessage = ({data, source}) =&gt; {
  console.log('client heard:', data);

  source.postmessage('bar');
};

navigator.serviceworker.register('./serviceworker.js')

// client heard: foo
// service worker heard: bar</code></pre>
        <p class="calibre1">前面的例子只会运行一次，因为活动事件在每个服务工作者线程上只会触发一次。</p>
        <p class="calibre1">因为客户端和服务工作者线程可以相互之间发送消息，所以通过<code class="calibre11">MessageChannel</code>或<code class="calibre11">BroadcastChannel</code>实现通信也是可能的。</p>
        <h3 id="nav_point_664" class="calibre15">27.4.10 拦截<code class="calibre26">fetch</code>事件</h3>
        <p class="calibre1">服务工作者线程最重要的一个特性就是拦截网络请求。服务工作者线程作用域中的网络请求会注册为<code class="calibre11">fetch</code>事件。这种拦截能力不限于<code class="calibre11">fetch()</code>方法发送的请求，也能拦截对JavaScript、CSS、图片和HTML（包括对主HTML文档本身）等资源发送的请求。这些请求可以来自JavaScript，也可以通过<code class="calibre11">&lt;script&gt;</code>、<code class="calibre11">&lt;link&gt;</code>或<code class="calibre11">&lt;img&gt;</code>标签创建。直观地说，这样是合理的：如果想让服务工作者线程模拟离线应用程序，它就必须能够把控页面正常运行所需的所有请求资源。</p>
        <p class="calibre1">
          <code class="calibre11">FetchEvent</code>继承自<code class="calibre11">ExtendableEvent</code>。让服务工作者线程能够决定如何处理<code class="calibre11">fetch</code>事件的方法是<code class="calibre11">event.respondWith()</code>。该方法接收期约，该期约会解决为一个<code class="calibre11">Response</code>对象。当然，该<code class="calibre11">Response</code>对象实际上来自哪里完全由服务工作者线程决定。可以来自网络，来自缓存，或者动态创建。下面几节将介绍几种网络/缓存策略，可以在服务工作者线程中使用。</p>
        <ol class="calibre16">
          <li value="1" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">从网络返回</strong>
            </p>
            <p class="calibre1">这个策略就是简单地转发<code class="calibre11">fetch</code>事件。那些绝对需要发送到服务器的请求例如POST请求就适合该策略。可以像下面实现这一策略：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">self.onfetch = (fetchevent) =&gt; {
  fetchevent.respondwith(fetch(fetchevent.request));
};</code></pre>
            <blockquote class="calibre13">
              <p class="calibre1">
                <strong class="calibre2">注意</strong>
                前面的代码只演示了如何使用<code class="calibre11">event.respondWith()</code>。如果<code class="calibre11">event.respondWith()</code>没有被调用，浏览器也会通过网络发送请求。</p>
            </blockquote>
            <p class="calibre1"></p>
          </li>
          <li value="2" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">从缓存返回</strong>
            </p>
            <p class="calibre1">这个策略其实就是缓存检查。对于任何肯定有缓存的资源（如在安装阶段缓存的资源），可以采用该策略：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">self.onfetch = (fetchevent) =&gt; {
  fetchevent.respondwith(caches.match(fetchevent.request));
};</code></pre>
            <p class="calibre1"></p>
          </li>
          <li value="3" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">从网络返回，缓存作后备</strong>
            </p>
            <p class="calibre1">这个策略把从网络获取最新的数据作为首选，但如果缓存中有值也会返回缓存的值。如果应用程序需要尽可能展示最新数据，但在离线的情况下仍要展示一些信息，就可以采用该策略：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">self.onfetch = (fetchevent) =&gt; {
  fetchevent.respondwith(
    fetch(fetchevent.request)
    .catch(() =&gt; caches.match(fetchevent.request))
  );
};</code></pre>
            <p class="calibre1"></p>
          </li>
          <li value="4" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">从缓存返回，网络作后备</strong>
            </p>
            <p class="calibre1">这个策略优先考虑响应速度，但仍会在没有缓存的情况下发送网络请求。这是大多数渐进式Web应用程序（PWA，Progressive Web Application）采取的首选策略：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">self.onfetch = (fetchevent) =&gt; {
  fetchevent.respondwith(
    caches.match(fetchevent.request)
    .then((response) =&gt; response || fetch(fetchevent.request))
  );
};</code></pre>
            <p class="calibre1"></p>
          </li>
          <li value="5" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">通用后备</strong>
            </p>
            <p class="calibre1">应用程序需要考虑缓存和网络都不可用的情况。服务工作者线程可以在安装时缓存后备资源，然后在缓存和网络都失败时返回它们：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">self.onfetch = (fetchevent) =&gt; {
  fetchevent.respondwith(
    // 开始执行“从缓存返回，以网络为后备”策略
    caches.match(fetchevent.request)
    .then((response) =&gt; response || fetch(fetchevent.request))
    .catch(() =&gt; caches.match('/fallback.html'))
  );
};</code></pre>
            <p class="calibre1">这里的<code class="calibre11">catch()</code>子句可以扩展为支持不同类型的后备，例如点位图、哑数据，等等。</p>
            <blockquote class="calibre13">
              <p class="calibre1">
                <strong class="calibre2">注意</strong>
                Jake Archibald在Google Developers网站有一篇关于网络/缓存策略的好文章《离线指南》。</p>
            </blockquote>
          </li>
        </ol>
        <h3 id="nav_point_665" class="calibre15">27.4.11 推送通知</h3>
        <p class="calibre1">对于模拟原生应用程序的Web应用程序而言，必须支持推送消息。这意味着网页必须能够接收服务器的推送事件，然后在设备上显示通知（即使应用程序没有运行）。当然，这在常规网页中肯定是不可能的。不过，有了服务工作者线程就可以实现该行为。</p>
        <p class="calibre1">为了在PWA应用程序中支持推送通知，必须支持以下4种行为。</p>
        <p class="calibre1">• 服务工作者线程必须能够显示通知。</p>
        <p class="calibre1">• 服务工作者线程必须能够处理与这些通知的交互。</p>
        <p class="calibre1">• 服务工作者线程必须能够订阅服务器发送的推送通知。</p>
        <p class="calibre1">• 服务工作者线程必须能够处理推送消息，即使应用程序没在前台运行或者根本没打开。</p>
        <ol class="calibre16">
          <li value="1" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">显示通知</strong>
            </p>
            <p class="calibre1">服务工作者线程可以通过它们的注册对象使用Notification API。这样做有很好的理由：与服务工作者线程关联的通知也会触发服务工作者线程内部的交互事件。</p>
            <p class="calibre1">显示通知要求向用户明确地请求授权。授权完成后，可以通过<code class="calibre11">ServiceWorkerRegistration.showNotification()</code>显示通知。下面是示例实现：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">navigator.serviceworker.register('./serviceworker.js')
.then((registration) =&gt; {
  notification.requestpermission()
  .then((status) =&gt; {
    if (status === 'granted') {
      registration.shownotification('foo');
    }
  });
});</code></pre>
            <p class="calibre1">类似地，在服务工作者线程内部可以使用全局<code class="calibre11">registration</code>属性触发通知：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">self.onactivate = () =&gt; self.registration.shownotification('bar');</code></pre>
            <p class="calibre1">在上面的例子中，获得显示通知的授权后，会把<code class="calibre11">foo</code>通知显示在浏览器中。该通知与使用<code class="calibre11">new Notification()</code>创建的通知看不出有任何差别。此外，显示该通知不需要服务工作者线程额外做任何事情。服务工作者线程只在需要处理通知事件时才会发挥作用。<br class="calibre4"/>
            </p>
          </li>
          <li value="2" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">处理通知事件</strong>
            </p>
            <p class="calibre1">通过<code class="calibre11">ServiceWorkerRegistration</code>对象创建的通知会向服务工作者线程发送<code class="calibre11">notificationclick</code>和<code class="calibre11">notificationclose</code>事件。假设前面例子中的服务脚本定义了如下事件处理程序：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">self.onnotificationclick = ({notification}) =&gt; {
  console.log('notification click', notification);
};

self.onnotificationclose = ({notification}) =&gt; {
  console.log('notification close', notification);
};</code></pre>
            <p class="calibre1">在这个例子中，与通知的两种交互操作都在服务工作者线程中注册了处理程序。这里的<code class="calibre11">notification</code>事件对象暴露了<code class="calibre11">notification</code>属性，其中包含着生成该事件<code class="calibre11">Notification</code>对象。这些处理程序可以决定交互操作之后的响应方式。</p>
            <p class="calibre1">一般来说，单击通知意味着用户希望转到某个具体的页面。在服务工作者线程处理程序中，可以通过<code class="calibre11">clients.openWindow()</code>打开相应的URL，例如：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">self.onnotificationclick = ({notification}) =&gt; {
  clients.openwindow('https://foo.com');
};</code></pre>
            <p class="calibre1"></p>
          </li>
          <li value="3" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">订阅推送事件</strong>
            </p>
            <p class="calibre1">对于发送给服务工作者线程的推送消息，必须通过服务工作者线程的<code class="calibre11">PushManager</code>来订阅。这样服务工作者线程就可以在<code class="calibre11">push</code>事件处理程序中处理推送消息。</p>
            <p class="calibre1">下面展示了使用<code class="calibre11">ServiceWorkerRegistration.pushManager</code>订阅推送消息的例子：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">navigator.serviceworker.register('./serviceworker.js')
.then((registration) =&gt; {
  registration.pushmanager.subscribe({
    applicationserverkey: key, // 来自服务器的公钥
    uservisibleonly: true
  });
});</code></pre>
            <p class="calibre1">另外，服务工作者线程也可以使用全局的<code class="calibre11">registration</code>属性自己订阅：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">self.onactivate = () =&gt; {
  self.registration.pushmanager.subscribe({
    applicationserverkey: key, // 来自服务器的公钥
    uservisibleonly: true
  });
};</code></pre>
            <p class="calibre1"></p>
          </li>
          <li value="4" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">处理推送事件</strong>
            </p>
            <p class="calibre1">订阅之后，服务工作者线程会在每次服务器推送消息时收到<code class="calibre11">push</code>事件。这时候它可以这样来处理：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">self.onpush = (pushevent) =&gt; {
  console.log('service worker was pushed data:', pushevent.data.text());
};</code></pre>
            <p class="calibre1">为实现真正的推送通知，这个处理程序只需要通过注册对象创建一个通知即可。不过，完善的推送通知需要创建它的服务工作者线程保持活动足够长时间，以便处理后续的交互事件。</p>
            <p class="calibre1">要实现这一点，<code class="calibre11">push</code>事件继承了<code class="calibre11">ExtendableEvent</code>。可以把<code class="calibre11">showNotification()</code>返回的期约传给<code class="calibre11">waitUntil()</code>，这样就会让服务工作者线程一直活动到通知的期约解决。</p>
            <p class="calibre1">下面展示了实现上述逻辑的简单框架：</p>
            <p class="calibre1">
              <strong class="calibre2">main.js</strong>
            </p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">navigator.serviceworker.register('./serviceworker.js')
.then((registration) =&gt; {
  // 请求显示通知的授权
  notification.requestpermission()
  .then((status) =&gt; {
    if (status === 'granted') {
      // 如果获得授权，只订阅推送消息
      registration.pushmanager.subscribe({
        applicationserverkey: key, // 来自服务器的公钥
        uservisibleonly: true
      });
    }
  });
});</code></pre>
            <p class="calibre1">
              <strong class="calibre2">ServiceWorker.js</strong>
            </p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">// 收到推送事件后，在通知中以文本形式显示数据
self.onpush = (pushevent) =&gt; {
  // 保持服务工作者线程活动到通知期约解决
  pushevent.waituntil(
    self.registration.shownotification(pushevent.data.text())
  );
};

// 如果用户单击通知，则打开相应的应用程序页面
self.onnotificationclick = ({notification}) =&gt; {
  clients.openwindow('https://example.com/clicked-notification');
};</code></pre>
          </li>
        </ol>

      </div>

      <div class="calibreToc">
        <h2>
          <a href="../../54m0dfqx.html">Table of contents
          </a>
        </h2>
        <div>
          <ul>
            <li>
              <a href="part0002.html#nav_point_0">版权声明</a>
            </li>
            <li>
              <a href="part0003.html#nav_point_1">献词</a>
            </li>
            <li>
              <a href="part0004.html#nav_point_2">译者序</a>
            </li>
            <li>
              <a href="part0005.html#nav_point_3">序</a>
            </li>
            <li>
              <a href="part0006.html#nav_point_4">前言</a>
            </li>
            <li>
              <a href="part0012.html#nav_point_10">致谢</a>
            </li>
            <li>
              <a href="part0013.html#nav_point_11">第 1 章 什么是JavaScript</a>
            </li>
            <li>
              <a href="part0018.html#nav_point_19">第 2 章 HTML中的JavaScript</a>
            </li>
            <li>
              <a href="part0024.html#nav_point_31">第 3 章 语言基础</a>
            </li>
            <li>
              <a href="part0033.html#nav_point_78">第 4 章 变量、作用域与内存</a>
            </li>
            <li>
              <a href="part0038.html#nav_point_93">第 5 章 基本引用类型</a>
            </li>
            <li>
              <a href="part0044.html#nav_point_111">第 6 章 集合引用类型</a>
            </li>
            <li>
              <a href="part0054.html#nav_point_153">第 7 章 迭代器与生成器</a>
            </li>
            <li>
              <a href="part0059.html#nav_point_166">第 8 章 对象、类与面向对象编程</a>
            </li>
            <li>
              <a href="part0065.html#nav_point_194">第 9 章 代理与反射</a>
            </li>
            <li>
              <a href="part0070.html#nav_point_225">第 10 章 函数</a>
            </li>
            <li>
              <a href="part0088.html#nav_point_258">第 11 章 期约与异步函数</a>
            </li>
            <li>
              <a href="part0093.html#nav_point_273">第 12 章 BOM</a>
            </li>
            <li>
              <a href="part0100.html#nav_point_294">第 13 章 客户端检测</a>
            </li>
            <li>
              <a href="part0105.html#nav_point_306">第 14 章 DOM</a>
            </li>
            <li>
              <a href="part0110.html#nav_point_328">第 15 章 DOM扩展</a>
            </li>
            <li>
              <a href="part0116.html#nav_point_348">第 16 章 DOM2和DOM3</a>
            </li>
            <li>
              <a href="part0122.html#nav_point_370">第 17 章 事件</a>
            </li>
            <li>
              <a href="part0130.html#nav_point_403">第 18 章 动画与Canvas图形</a>
            </li>
            <li>
              <a href="part0136.html#nav_point_428">第 19 章 表单脚本</a>
            </li>
            <li>
              <a href="part0143.html#nav_point_450">第 20 章 JavaScript API</a>
            </li>
            <li>
              <a href="part0157.html#nav_point_500">第 21 章 错误处理与调试</a>
            </li>
            <li>
              <a href="part0163.html#nav_point_526">第 22 章 处理XML</a>
            </li>
            <li>
              <a href="part0168.html#nav_point_542">第 23 章 JSON</a>
            </li>
            <li>
              <a href="part0172.html#nav_point_552">第 24 章 网络请求与远程资源</a>
            </li>
            <li>
              <a href="part0182.html#nav_point_582">第 25 章 客户端存储</a>
            </li>
            <li>
              <a href="part0187.html#nav_point_607">第 26 章 模块</a>
            </li>
            <li>
              <a href="part0193.html#nav_point_633">第 27 章 工作者线程</a>
            </li>
            <li>
              <a href="part0199.html#nav_point_667">第 28 章 最佳实践</a>
            </li>
            <li>
              <a href="part0204.html#nav_point_683">附录 A ES2018和ES2019</a>
            </li>
            <li>
              <a href="part0215.html#nav_point_708">附录 B 严格模式</a>
            </li>
            <li>
              <a href="part0223.html#nav_point_719">附录 C JavaScript库和框架</a>
            </li>
            <li>
              <a href="part0227.html#nav_point_741">附录 D JavaScript工具</a>
            </li>
            <li>
              <a href="part0239.html#nav_point_800">作者简介</a>
            </li>
          </ul>
        </div>

      </div>

      <div class="calibreEbNav">

        <a href="part0196.html" class="calibreAPrev">上一页
        </a>

        <a href="../../54m0dfqx.html" class="calibreAHome">首页
        </a>

        <a href="part0198.html" class="calibreANext">下一页
        </a>

      </div>

    </div>

    <script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6487844781006261" crossorigin="anonymous"></script>
  </body>
</html>