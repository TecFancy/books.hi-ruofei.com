<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>

    <title>JavaScript高级程序设计（第4版）</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" type="text/css" href="../stylesheet.css"/>
    <link rel="stylesheet" type="text/css" href="../page_styles.css"/>

    <link href="../calibreHtmlOutBasicCss.css" type="text/css" rel="stylesheet"/>

  </head>
  <body>

    <div class="calibreMeta">
      <div class="calibreMetaTitle">

        <h1>
          <a href="../../54m0dfqx.html">JavaScript高级程序设计（第4版）
          </a>
        </h1>

      </div>
      <div class="calibreMetaAuthor">
        [美] 马特 • 弗里斯比

      </div>
    </div>

    <div class="calibreMain">

      <div class="calibreEbookContent">

        <div class="calibreEbNavTop">

          <a href="part0176.html" class="calibreAPrev">上一页
          </a>

          <a href="part0178.html" class="calibreANext">下一页
          </a>

        </div>

        <h2 id="nav_point_568" class="calibre9">24.5 Fetch API</h2>
        <p class="calibre1">Fetch API能够执行<code class="calibre11">XMLHttpRequest</code>对象的所有任务，但更容易使用，接口也更现代化，能够在Web工作线程等现代Web工具中使用。<code class="calibre11">XMLHttpRequest</code>可以选择异步，而Fetch API则必须是异步。Fetch API是WHATWG的一个“活标准”（living standard），用规范原文说，就是“Fetch标准定义请求、响应，以及绑定二者的流程：获取（fetch）”。</p>
        <p class="calibre1">Fetch API本身是使用JavaScript请求资源的优秀工具，同时这个API也能够应用在服务线程（service worker）中，提供拦截、重定向和修改通过<code class="calibre11">fetch()</code>生成的请求接口。</p>
        <h3 id="nav_point_569" class="calibre15">24.5.1 基本用法</h3>
        <p class="calibre1">
          <code class="calibre11">fetch()</code>方法是暴露在全局作用域中的，包括主页面执行线程、模块和工作线程。调用这个方法，浏览器就会向给定URL发送请求。</p>
        <ol class="calibre16">
          <li value="1" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">分派请求</strong>
            </p>
            <p class="calibre1">
              <code class="calibre11">fetch()</code>只有一个必需的参数<code class="calibre11">input</code>。多数情况下，这个参数是要获取资源的URL。这个方法返回一个期约：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let r = fetch('/bar');
console.log(r); // promise &lt;pending&gt;</code></pre>
            <p class="calibre1">URL的格式（相对路径、绝对路径等）的解释与XHR对象一样。</p>
            <p class="calibre1">请求完成、资源可用时，期约会解决为一个<code class="calibre11">Response</code>对象。这个对象是API的封装，可以通过它取得相应资源。获取资源要使用这个对象的属性和方法，掌握响应的情况并将负载转换为有用的形式，如下所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">fetch('bar.txt')
  .then((response) =&gt; {
    console.log(response);
  });

// response { type: "basic", url: ...** **}</code></pre>
            <p class="calibre1"></p>
          </li>
          <li value="2" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">读取响应</strong>
            </p>
            <p class="calibre1">读取响应内容的最简单方式是取得纯文本格式的内容，这要用到<code class="calibre11">text()</code>方法。这个方法返回一个期约，会解决为取得资源的完整内容：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">fetch('bar.txt')
  .then((response) =&gt; {
    response.text().then((data) =&gt; {
      console.log(data);
    });
  });

// bar.txt的内容</code></pre>
            <p class="calibre1">内容的结构通常是打平的：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">fetch('bar.txt')
  .then((response) =&gt; response.text())
  .then((data) =&gt; console.log(data));

// bar.txt的内容</code></pre>
            <p class="calibre1"></p>
          </li>
          <li value="3" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">处理状态码和请求失败</strong>
            </p>
            <p class="calibre1">Fetch API支持通过<code class="calibre11">Response</code>的<code class="calibre11">status</code>（状态码）和<code class="calibre11">statusText</code>（状态文本）属性检查响应状态。成功获取响应的请求通常会产生值为200的状态码，如下所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">fetch('/bar')
  .then((response) =&gt; {
    console.log(response.status);     // 200
    console.log(response.statustext); // ok
  });</code></pre>
            <p class="calibre1">请求不存在的资源通常会产生值为404的状态码：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">fetch('/does-not-exist')
  .then((response) =&gt; {
    console.log(response.status);     // 404
    console.log(response.statustext); // not found
  });</code></pre>
            <p class="calibre1">请求的URL如果抛出服务器错误会产生值为500的状态码：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">fetch('/throw-server-error')
  .then((response) =&gt; {
    console.log(response.status);     // 500
    console.log(response.statustext); // internal server error
  });</code></pre>
            <p class="calibre1">可以显式地设置<code class="calibre11">fetch()</code>在遇到重定向时的行为（本章后面会介绍），不过默认行为是跟随重定向并返回状态码不是300~399的响应。跟随重定向时，响应对象的<code class="calibre11">redirected</code>属性会被设置为<code class="calibre11">true</code>，而状态码仍然是200：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">fetch('/permanent-redirect')
  .then((response) =&gt; {
    // 默认行为是跟随重定向直到最终url
    // 这个例子会出现至少两轮网络请求
    // &lt;origin url&gt;/permanent-redirect -&gt; &lt;redirect url&gt;
    console.log(response.status);     // 200
    console.log(response.statustext); // ok
    console.log(response.redirected); // true
  });</code></pre>
            <p class="calibre1">在前面这几个例子中，虽然请求可能失败（如状态码为500），但都只执行了期约的<strong class="calibre2">解决</strong>处理函数。事实上，只要服务器返回了响应，<code class="calibre11">fetch()</code>期约都会解决。这个行为是合理的：系统级网络协议已经成功完成消息的一次往返传输。至于真正的“成功”请求，则需要在处理响应时再定义。</p>
            <p class="calibre1">通常状态码为200时就会被认为成功了，其他情况可以被认为未成功。为区分这两种情况，可以在状态码非200~299时检查<code class="calibre11">Response</code>对象的<code class="calibre11">ok</code>属性：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">fetch('/bar')
  .then((response) =&gt; {
    console.log(response.status); // 200
    console.log(response.ok);     // true
  });
fetch('/does-not-exist')
  .then((response) =&gt; {
    console.log(response.status); // 404
    console.log(response.ok);     // false
  });</code></pre>
            <p class="calibre1">因为服务器没有响应而导致浏览器超时，这样真正的<code class="calibre11">fetch()</code>失败会导致期约被拒绝：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">fetch('/hangs-forever')
  .then((response) =&gt; {
    console.log(response);
  }, (err) =&gt; {
    console.log(err);
  });

//（浏览器超时后）
// typeerror: "networkerror when attempting to fetch resource."</code></pre>
            <p class="calibre1">违反CORS、无网络连接、HTTPS错配及其他浏览器/网络策略问题都会导致期约被拒绝。</p>
            <p class="calibre1">可以通过<code class="calibre11">url</code>属性检查通过<code class="calibre11">fetch()</code>发送请求时使用的完整URL：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">// foo.com/bar/baz发送的请求
console.log(window.location.href); // https://foo.com/bar/baz

fetch('qux').then((response) =&gt; console.log(response.url));
// https://foo.com/bar/qux

fetch('/qux').then((response) =&gt; console.log(response.url));
// https://foo.com/qux

fetch('//qux.com').then((response) =&gt; console.log(response.url));
// https://qux.com

fetch('https://qux.com').then((response) =&gt; console.log(response.url));
// https://qux.com</code></pre>
            <p class="calibre1"></p>
          </li>
          <li value="4" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">自定义选项</strong>
            </p>
            <p class="calibre1">只使用URL时，<code class="calibre11">fetch()</code>会发送GET请求，只包含最低限度的请求头。要进一步配置如何发送请求，需要传入可选的第二个参数<code class="calibre11">init</code>对象。<code class="calibre11">init</code>对象要按照下表中的键/值进行填充。</p>
            <table class="table" width="90%" border="1">
              <tr class="calibre18">
                <th class="calibre19">键</th>
                <th class="calibre19">值</th>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">
                  <code class="calibre27">body</code>
                </td>
                <td class="calibre21">指定使用请求体时请求体的内容<br class="calibre4"/>必须是<code class="calibre27">Blob</code>、<code class="calibre27">BufferSource</code>、<code class="calibre27">FormData</code>、<code class="calibre27">URLSearchParams</code>、<code class="calibre27">ReadableStream</code>或<code class="calibre27">String</code>的实例</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">
                  <code class="calibre27">cache</code>
                </td>
                <td class="calibre21">用于控制浏览器与HTTP缓存的交互。要跟踪缓存的重定向，请求的<code class="calibre27">redirect</code>属性值必须是<code class="calibre27">"follow"</code>，而且必须符合同源策略限制。必须是下列值之一<br class="calibre4"/>
                  <code class="calibre27">Default</code><br class="calibre4"/>•
                  <code class="calibre27">fetch()</code>返回命中的有效缓存。不发送请求<br class="calibre4"/>• 命中无效（stale）缓存会发送条件式请求。如果响应已经改变，则更新缓存的值。然后<code class="calibre27">fetch()</code>返回缓存的值<br class="calibre4"/>• 未命中缓存会发送请求，并缓存响应。然后<code class="calibre27">fetch()</code>返回响应<br class="calibre4"/>
                  <code class="calibre27">no-store</code><br class="calibre4"/>• 浏览器不检查缓存，直接发送请求<br class="calibre4"/>• 不缓存响应，直接通过<code class="calibre27">fetch()</code>返回<br class="calibre4"/>
                  <code class="calibre27">reload</code><br class="calibre4"/>• 浏览器不检查缓存，直接发送请求<br class="calibre4"/>• 缓存响应，再通过<code class="calibre27">fetch()</code>返回<br class="calibre4"/>
                  <code class="calibre27">no-cache</code><br class="calibre4"/>• 无论命中有效缓存还是无效缓存都会发送条件式请求。如果响应已经改变，则更新缓存的值。然后<code class="calibre27">fetch()</code>返回缓存的值<br class="calibre4"/>• 未命中缓存会发送请求，并缓存响应。然后<code class="calibre27">fetch()</code>返回响应<br class="calibre4"/>
                  <code class="calibre27">force-cache</code><br class="calibre4"/>• 无论命中有效缓存还是无效缓存都通过<code class="calibre27">fetch()</code>返回。不发送请求<br class="calibre4"/>• 未命中缓存会发送请求，并缓存响应。然后<code class="calibre27">fetch()</code>返回响应<br class="calibre4"/>
                  <code class="calibre27">only-if-cached</code><br class="calibre4"/>• 只在请求模式为<code class="calibre27">same-origin</code>时使用缓存<br class="calibre4"/>• 无论命中有效缓存还是无效缓存都通过<code class="calibre27">fetch()</code>返回。不发送请求<br class="calibre4"/>• 未命中缓存返回状态码为504（网关超时）的响应<br class="calibre4"/>默认为<code class="calibre27">default</code>
                </td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">
                  <code class="calibre27">credentials</code>
                </td>
                <td class="calibre21">用于指定在外发请求中如何包含cookie。与<code class="calibre27">XMLHttpRequest</code>的<code class="calibre27">withCredentials</code>标签类似<br class="calibre4"/>必须是下列字符串值之一<br class="calibre4"/>•
                  <code class="calibre27">omit</code>：不发送cookie<br class="calibre4"/>•
                  <code class="calibre27">same-origin</code>：只在请求URL与发送<code class="calibre27">fetch()</code>请求的页面同源时发送cookie<br class="calibre4"/>•
                  <code class="calibre27">include</code>：无论同源还是跨源都包含cookie<br class="calibre4"/>在支持Credential Management API的浏览器中，也可以是一个<code class="calibre27">FederatedCredential</code>或<code class="calibre27">PasswordCredential</code>的实例<br class="calibre4"/>默认为<code class="calibre27">same-origin</code>
                </td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">
                  <code class="calibre27">headers</code>
                </td>
                <td class="calibre21">用于指定请求头部<br class="calibre4"/>必须是<code class="calibre27">Headers</code>对象实例或包含字符串格式键/值对的常规对象<br class="calibre4"/>默认值为不包含键/值对的<code class="calibre27">Headers</code>对象。这不意味着请求不包含任何头部，浏览器仍然会随请求发送一些头部。虽然这些头部对JavaScript不可见，但浏览器的网络检查器可以观察到</td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">
                  <code class="calibre27">integrity</code>
                </td>
                <td class="calibre21">用于强制子资源完整性<br class="calibre4"/>必须是包含子资源完整性标识符的字符串<br class="calibre4"/>默认为空字符串</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">
                  <code class="calibre27">keepalive</code>
                </td>
                <td class="calibre21">用于指示浏览器允许请求存在时间超出页面生命周期。适合报告事件或分析，比如页面在<code class="calibre27">fetch()</code>请求后很快卸载。设置<code class="calibre27">keepalive</code>标志的<code class="calibre27">fetch()</code>请求可用于替代<code class="calibre27">Navigator.sendBeacon()</code><br class="calibre4"/>必须是布尔值<br class="calibre4"/>默认为<code class="calibre27">false</code>
                </td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">
                  <code class="calibre27">method</code>
                </td>
                <td class="calibre21">用于指定HTTP请求方法<br class="calibre4"/>基本上就是如下字符串值：<br class="calibre4"/>•
                  <code class="calibre27">GET</code><br class="calibre4"/>•
                  <code class="calibre27">POST</code><br class="calibre4"/>•
                  <code class="calibre27">PUT</code><br class="calibre4"/>•
                  <code class="calibre27">PATCH</code><br class="calibre4"/>•
                  <code class="calibre27">DELETE</code><br class="calibre4"/>•
                  <code class="calibre27">HEAD</code><br class="calibre4"/>•
                  <code class="calibre27">OPTIONS</code><br class="calibre4"/>•
                  <code class="calibre27">CONNECT</code><br class="calibre4"/>•
                  <code class="calibre27">TARCE</code><br class="calibre4"/>默认为<code class="calibre27">GET</code>
                </td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">
                  <code class="calibre27">mode</code>
                </td>
                <td class="calibre21">用于指定请求模式。这个模式决定来自跨源请求的响应是否有效，以及客户端可以读取多少响应。违反这里指定模式的请求会抛出错误<br class="calibre4"/>必须是下列字符串值之一<br class="calibre4"/>•
                  <code class="calibre27">cors</code>：允许遵守CORS协议的跨源请求。响应是“CORS过滤的响应”，意思是响应中可以访问的浏览器头部是经过浏览器强制白名单过滤的<br class="calibre4"/>•
                  <code class="calibre27">no-cors</code>：允许不需要发送预检请求的跨源请求（HEAD、GET和只带有满足CORS请求头部的POST）。响应类型是<code class="calibre27">opaque</code>，意思是不能读取响应内容<br class="calibre4"/>•
                  <code class="calibre27">same-origin</code>：任何跨源请求都不允许发送<br class="calibre4"/>•
                  <code class="calibre27">navigate</code>：用于支持HTML导航，只在文档间导航时使用。基本用不到<br class="calibre4"/>在通过构造函数手动创建<code class="calibre27">Request</code>实例时，默认为<code class="calibre27">cors</code>；否则，默认为<code class="calibre27">no-cors</code>
                </td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">
                  <code class="calibre27">redirect</code>
                </td>
                <td class="calibre21">用于指定如何处理重定向响应（状态码为301、302、303、307或308）<br class="calibre4"/>必须是下列字符串值之一<br class="calibre4"/>•
                  <code class="calibre27">follow</code>：跟踪重定向请求，以最终非重定向URL的响应作为最终响应<br class="calibre4"/>•
                  <code class="calibre27">error</code>：重定向请求会抛出错误<br class="calibre4"/>•
                  <code class="calibre27">manual</code>：不跟踪重定向请求，而是返回<code class="calibre27">opaqueredirect</code>类型的响应，同时仍然暴露期望的重定向URL。允许以手动方式跟踪重定向<br class="calibre4"/>默认为<code class="calibre27">follow</code>
                </td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">
                  <code class="calibre27">referrer</code>
                </td>
                <td class="calibre21">用于指定HTTP的<code class="calibre27">Referer</code>头部的内容<br class="calibre4"/>必须是下列字符串值之一<br class="calibre4"/>•
                  <code class="calibre27">no-referrer</code>：以<code class="calibre27">no-referrer</code>作为值<br class="calibre4"/>•
                  <code class="calibre27">client</code>/<code class="calibre27">about:client</code>：以当前URL或<code class="calibre27">no-referrer</code>（取决于来源策略<code class="calibre27">referrerPolicy</code>）作为值<br class="calibre4"/>•
                  <code class="calibre27">&lt;URL&gt;</code>：以伪造URL作为值。伪造URL的源必须与执行脚本的源匹配<br class="calibre4"/>默认为<code class="calibre27">client</code>/<code class="calibre27">about:client</code>
                </td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">
                  <code class="calibre27">referrerPolicy</code>
                </td>
                <td class="calibre21">用于指定HTTP的<code class="calibre27">Referer</code>头部<br class="calibre4"/>必须是下列字符串值之一<br class="calibre4"/>
                  <code class="calibre27">no-referrer</code><br class="calibre4"/>• 请求中不包含<code class="calibre27">Referer</code>头部<br class="calibre4"/>
                  <code class="calibre27">no-referrer-when-downgrade</code><br class="calibre4"/>• 对于从安全HTTPS上下文发送到HTTP URL的请求，不包含<code class="calibre27">Referer</code>头部<br class="calibre4"/>• 对于所有其他请求，将<code class="calibre27">Referer</code>设置为完整URL<br class="calibre4"/>
                  <code class="calibre27">origin</code><br class="calibre4"/>• 对于所有请求，将<code class="calibre27">Referer</code>设置为只包含源<br class="calibre4"/>
                  <code class="calibre27">same-origin</code><br class="calibre4"/>• 对于跨源请求，不包含<code class="calibre27">Referer</code>头部<br class="calibre4"/>• 对于同源请求，将<code class="calibre27">Referer</code>设置为完整URL<br class="calibre4"/>
                  <code class="calibre27">strict-origin</code><br class="calibre4"/>• 对于从安全HTTPS上下文发送到HTTP URL的请求，不包含<code class="calibre27">Referer</code>头部<br class="calibre4"/>• 对于所有其他请求，将<code class="calibre27">Referer</code>设置为只包含源<br class="calibre4"/>
                  <code class="calibre27">origin-when-cross-origin</code><br class="calibre4"/>• 对于跨源请求，将<code class="calibre27">Referer</code>设置为只包含源<br class="calibre4"/>• 对于同源请求，将<code class="calibre27">Referer</code>设置为完整URL<br class="calibre4"/>
                  <code class="calibre27">strict-origin-when-cross-origin</code><br class="calibre4"/>• 对于从安全HTTPS上下文发送到HTTP URL的请求，不包含<code class="calibre27">Referer</code>头部<br class="calibre4"/>• 对于所有其他跨源请求，将<code class="calibre27">Referer</code>设置为只包含源<br class="calibre4"/>• 对于同源请求，将<code class="calibre27">Referer</code>设置为完整URL<br class="calibre4"/>
                  <code class="calibre27">unsafe-url</code><br class="calibre4"/>• 对于所有请求，将<code class="calibre27">Referer</code>设置为完整URL<br class="calibre4"/>默认为<code class="calibre27">no-referrer-when-downgrade</code>
                </td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">
                  <code class="calibre27">signal</code>
                </td>
                <td class="calibre21">用于支持通过<code class="calibre27">AbortController</code>中断进行中的<code class="calibre27">fetch()</code>请求<br class="calibre4"/>必须是<code class="calibre27">AbortSignal</code>的实例<br class="calibre4"/>默认为未关联控制器的<code class="calibre27">AbortSignal</code>实例</td>
              </tr>
            </table>

          </li>
        </ol>
        <h3 id="nav_point_570" class="calibre15">24.5.2 常见Fetch请求模式</h3>
        <p class="calibre1">与<code class="calibre11">XMLHttpRequest</code>一样，<code class="calibre11">fetch()</code>既可以发送数据也可以接收数据。使用<code class="calibre11">init</code>对象参数，可以配置<code class="calibre11">fetch()</code>在请求体中发送各种序列化的数据。</p>
        <ol class="calibre16">
          <li value="1" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">发送JSON数据</strong>
            </p>
            <p class="calibre1">可以像下面这样发送简单JSON字符串：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let payload = json.stringify({
  foo: 'bar'
});

let jsonheaders = new headers({
  'content-type': 'application/json'
});

fetch('/send-me-json', {
  method: 'post',   // 发送请求体时必须使用一种http方法
  body: payload,
  headers: jsonheaders
});</code></pre>
            <p class="calibre1"></p>
          </li>
          <li value="2" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">在请求体中发送参数</strong>
            </p>
            <p class="calibre1">因为请求体支持任意字符串值，所以可以通过它发送请求参数：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let payload = 'foo=bar&amp;baz=qux';

let paramheaders = new headers({
  'content-type': 'application/x-www-form-urlencoded; charset=utf-8'
});

fetch('/send-me-params', {
  method: 'post',  // 发送请求体时必须使用一种http方法
  body: payload,
  headers: paramheaders
});</code></pre>
            <p class="calibre1"></p>
          </li>
          <li value="3" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">发送文件</strong>
            </p>
            <p class="calibre1">因为请求体支持<code class="calibre11">FormData</code>实现，所以<code class="calibre11">fetch()</code>也可以序列化并发送文件字段中的文件：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let imageformdata = new formdata();
let imageinput = document.queryselector("input[type='file']");

imageformdata.append('image', imageinput.files[0]);

fetch('/img-upload', {
  method: 'post',
  body: imageformdata
});</code></pre>
            <p class="calibre1">这个<code class="calibre11">fetch()</code>实现可以支持多个文件：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let imageformdata = new formdata();
let imageinput = document.queryselector("input[type='file'][multiple]");

for (let i = 0; i &lt; imageinput.files.length; ++i) {
  imageformdata.append('image', imageinput.files[i]);
}

fetch('/img-upload', {
  method: 'post',
  body: imageformdata
});</code></pre>
            <p class="calibre1"></p>
          </li>
          <li value="4" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">加载<code class="calibre11">Blob</code>文件</strong>
            </p>
            <p class="calibre1">Fetch API也能提供<code class="calibre11">Blob</code>类型的响应，而<code class="calibre11">Blob</code>又可以兼容多种浏览器API。一种常见的做法是明确将图片文件加载到内存，然后将其添加到HTML图片元素。为此，可以使用响应对象上暴露的<code class="calibre11">blob()</code>方法。这个方法返回一个期约，解决为一个<code class="calibre11">Blob</code>的实例。然后，可以将这个实例传给<code class="calibre11">URL.createObjectUrl()</code>以生成可以添加给图片元素<code class="calibre11">src</code>属性的值：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">const imageelement = document.queryselector('img');

fetch('my-image.png')
  .then((response) =&gt; response.blob())
  .then((blob) =&gt; {
    imageelement.src = url.createobjecturl(blob);
  });</code></pre>
            <p class="calibre1"></p>
          </li>
          <li value="5" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">发送跨源请求</strong>
            </p>
            <p class="calibre1">从不同的源请求资源，响应要包含CORS头部才能保证浏览器收到响应。没有这些头部，跨源请求会失败并抛出错误。</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">fetch('//cross-origin.com');
// typeerror: failed to fetch
// no 'access-control-allow-origin' header is present on the requested resource.</code></pre>
            <p class="calibre1">如果代码不需要访问响应，也可以发送<code class="calibre11">no-cors</code>请求。此时响应的<code class="calibre11">type</code>属性值为<code class="calibre11">opaque</code>，因此无法读取响应内容。这种方式适合发送探测请求或者将响应缓存起来供以后使用。</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">fetch('//cross-origin.com', { method: 'no-cors' })
  .then((response) =&gt; console.log(response.type));

// opaque</code></pre>
            <p class="calibre1"></p>
          </li>
          <li value="6" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">中断请求</strong>
            </p>
            <p class="calibre1">Fetch API支持通过<code class="calibre11">AbortController</code>/<code class="calibre11">AbortSignal</code>对中断请求。调用<code class="calibre11">AbortController.abort()</code>会中断所有网络传输，特别适合希望停止传输大型负载的情况。中断进行中的<code class="calibre11">fetch()</code>请求会导致包含错误的拒绝。</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let abortcontroller = new abortcontroller();

fetch('wikipedia.zip', { signal: abortcontroller.signal })
  .catch(() =&gt; console.log('aborted!');

// 10毫秒后中断请求
settimeout(() =&gt; abortcontroller.abort(), 10);

// 已经中断</code></pre>
          </li>
        </ol>
        <h3 id="nav_point_571" class="calibre15">24.5.3
          <code class="calibre26">Headers</code>对象</h3>
        <p class="calibre1">
          <code class="calibre11">Headers</code>对象是所有外发请求和入站响应头部的容器。每个外发的<code class="calibre11">Request</code>实例都包含一个空的<code class="calibre11">Headers</code>实例，可以通过<code class="calibre11">Request.prototype.headers</code>访问，每个入站<code class="calibre11">Response</code>实例也可以通过<code class="calibre11">Response.prototype.headers</code>访问包含着响应头部的<code class="calibre11">Headers</code>对象。这两个属性都是可修改属性。另外，使用<code class="calibre11">new Headers()</code>也可以创建一个新实例。</p>
        <ol class="calibre16">
          <li value="1" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">
                <code class="calibre11">Headers</code>与<code class="calibre11">Map</code>的相似之处</strong>
            </p>
            <p class="calibre1">
              <code class="calibre11">Headers</code>对象与<code class="calibre11">Map</code>对象极为相似。这是合理的，因为HTTP头部本质上是序列化后的键/值对，它们的JavaScript表示则是中间接口。<code class="calibre11">Headers</code>与<code class="calibre11">Map</code>类型都有<code class="calibre11">get()</code>、<code class="calibre11">set()</code>、<code class="calibre11">has()</code>和<code class="calibre11">delete()</code>等实例方法，如下面的代码所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let h = new headers();
let m = new map();

// 设置键
h.set('foo', 'bar');
m.set('foo', 'bar');

// 检查键
console.log(h.has('foo')); // true
console.log(m.has('foo')); // true
console.log(h.has('qux')); // false
console.log(m.has('qux')); // false

// 获取值
console.log(h.get('foo')); // bar
console.log(m.get('foo')); // bar

// 更新值
h.set('foo', 'baz');
m.set('foo', 'baz');

// 取得更新的值
console.log(h.get('foo')); // baz
console.log(m.get('foo')); // baz

// 删除值
h.delete('foo');
m.delete('foo');

// 确定值已经删除
console.log(h.get('foo')); // undefined
console.log(m.get('foo')); // undefined</code></pre>
            <p class="calibre1">
              <code class="calibre11">Headers</code>和<code class="calibre11">Map</code>都可以使用一个可迭代对象来初始化，比如：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let seed = [['foo', 'bar']];

let h = new headers(seed);
let m = new map(seed);

console.log(h.get('foo')); // bar
console.log(m.get('foo')); // bar</code></pre>
            <p class="calibre1">而且，它们也都有相同的<code class="calibre11">keys()</code>、<code class="calibre11">values()</code>和<code class="calibre11">entries()</code>迭代器接口：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let seed = [['foo', 'bar'], ['baz', 'qux']];

let h = new headers(seed);
let m = new map(seed);

console.log(...h.keys());    // foo, baz
console.log(...m.keys());    // foo, baz

console.log(...h.values());  // bar, qux
console.log(...m.values());  // bar, qux

console.log(...h.entries()); // ['foo', 'bar'], ['baz', 'qux']
console.log(...m.entries()); // ['foo', 'bar'], ['baz', 'qux']</code></pre>
            <p class="calibre1"></p>
          </li>
          <li value="2" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">
                <code class="calibre11">Headers</code>独有的特性</strong>
            </p>
            <p class="calibre1">
              <code class="calibre11">Headers</code>并不是与<code class="calibre11">Map</code>处处都一样。在初始化<code class="calibre11">Headers</code>对象时，也可以使用键/值对形式的对象，而<code class="calibre11">Map</code>则不可以：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let seed = {foo: 'bar'};

let h = new headers(seed);
console.log(h.get('foo')); // bar

let m = new map(seed);
// typeerror: object is not iterable</code></pre>
            <p class="calibre1">一个HTTP头部字段可以有多个值，而<code class="calibre11">Headers</code>对象通过<code class="calibre11">append()</code>方法支持添加多个值。在<code class="calibre11">Headers</code>实例中还不存在的头部上调用<code class="calibre11">append()</code>方法相当于调用<code class="calibre11">set()</code>。后续调用会以逗号为分隔符拼接多个值：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let h = new headers();

h.append('foo', 'bar');
console.log(h.get('foo')); // "bar"

h.append('foo', 'baz');
console.log(h.get('foo')); // "bar, baz"</code></pre>
            <p class="calibre1"></p>
          </li>
          <li value="3" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">头部护卫</strong>
            </p>
            <p class="calibre1">某些情况下，并非所有HTTP头部都可以被客户端修改，而<code class="calibre11">Headers</code>对象使用护卫来防止不被允许的修改。不同的护卫设置会改变<code class="calibre11">set()</code>、<code class="calibre11">append()</code>和<code class="calibre11">delete()</code>的行为。违反护卫限制会抛出<code class="calibre11">TypeError</code>。</p>
            <p class="calibre1">
              <code class="calibre11">Headers</code>实例会因来源不同而展现不同的行为，它们的行为由护卫来控制。JavaScript可以决定<code class="calibre11">Headers</code>实例的护卫设置。下表列出了不同的护卫设置和每种设置对应的行为。</p>
            <table class="table" width="90%" border="1">
              <tr class="calibre18">
                <th class="calibre19">护卫</th>
                <th class="calibre19">适用情形</th>
                <th class="calibre19">限制</th>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">
                  <code class="calibre27">none</code>
                </td>
                <td class="calibre21">在通过构造函数创建<code class="calibre27">Headers</code>实例时激活</td>
                <td class="calibre21">无</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">
                  <code class="calibre27">request</code>
                </td>
                <td class="calibre21">在通过构造函数初始化<code class="calibre27">Request</code>对象，且<code class="calibre27">mode</code>值为非<code class="calibre27">no-cors</code>时激活</td>
                <td class="calibre21">不允许修改禁止修改的头部（参见MDN文档中的forbidden header name词条）</td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">
                  <code class="calibre27">request-no-cors</code>
                </td>
                <td class="calibre21">在通过构造函数初始化<code class="calibre27">Request</code>对象，且<code class="calibre27">mode</code>值为<code class="calibre27">no-cors</code>时激活</td>
                <td class="calibre21">不允许修改非简单头部（参见MDN文档中的simple header词条）</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">
                  <code class="calibre27">response</code>
                </td>
                <td class="calibre21">在通过构造函数初始化<code class="calibre27">Response</code>对象时激活</td>
                <td class="calibre21">不允许修改禁止修改的响应头部（参见MDN文档中的forbidden response header name词条）</td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">
                  <code class="calibre27">immutable</code>
                </td>
                <td class="calibre21">在通过<code class="calibre27">error()</code>或<code class="calibre27">redirect()</code>静态方法初始化<code class="calibre27">Response</code>对象时激活</td>
                <td class="calibre21">不允许修改任何头部</td>
              </tr>
            </table>

          </li>
        </ol>
        <h3 id="nav_point_572" class="calibre15">24.5.4
          <code class="calibre26">Request</code>对象</h3>
        <p class="calibre1">顾名思义，<code class="calibre11">Request</code>对象是获取资源请求的接口。这个接口暴露了请求的相关信息，也暴露了使用请求体的不同方式。</p>
        <blockquote class="calibre13">
          <p class="calibre1">
            <strong class="calibre2">注意</strong>
            与请求体相关的属性和方法将在本章24.5.6节介绍。</p>
        </blockquote>
        <ol class="calibre16">
          <li value="1" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">创建<code class="calibre11">Request</code>对象</strong>
            </p>
            <p class="calibre1">可以通过构造函数初始化<code class="calibre11">Request</code>对象。为此需要传入一个<code class="calibre11">input</code>参数，一般是URL：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let r = new request('https://foo.com');
console.log(r);
// request {...}</code></pre>
            <p class="calibre1">
              <code class="calibre11">Request</code>构造函数也接收第二个参数——一个<code class="calibre11">init</code>对象。这个<code class="calibre11">init</code>对象与前面介绍的<code class="calibre11">fetch()</code>的<code class="calibre11">init</code>对象一样。没有在<code class="calibre11">init</code>对象中涉及的值则会使用默认值：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">// 用所有默认值创建request对象
console.log(new request(''));

// request {
//   bodyused: false
//   cache: "default"
//   credentials: "same-origin"
//   destination: ""
//   headers: headers {}
//   integrity: ""
//   keepalive: false
//   method: "get"
//   mode: "cors"
//   redirect: "follow"
//   referrer: "about:client"
//   referrerpolicy: ""
//   signal: abortsignal {aborted: false, onabort: null}
//   url: "&lt;current url&gt;"
// }

// 用指定的初始值创建request对象
console.log(new request('https://foo.com',
                        { method: 'post' }));

// request {
//   bodyused: false
//   cache: "default"
//   credentials: "same-origin"
//   destination: ""
//   headers: headers {}
//   integrity: ""
//   keepalive: false
//   method: "post"
//   mode: "cors"
//   redirect: "follow"
//   referrer: "about:client"
//   referrerpolicy: ""
//   signal: abortsignal {aborted: false, onabort: null}
//   url: "https://foo.com/"
// }</code></pre>
            <p class="calibre1"></p>
          </li>
          <li value="2" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">克隆<code class="calibre11">Request</code>对象</strong>
            </p>
            <p class="calibre1">Fetch API提供了两种不太一样的方式用于创建<code class="calibre11">Request</code>对象的副本：使用<code class="calibre11">Request</code>构造函数和使用<code class="calibre11">clone()</code>方法。</p>
            <p class="calibre1">将<code class="calibre11">Request</code>实例作为<code class="calibre11">input</code>参数传给<code class="calibre11">Request</code>构造函数，会得到该请求的一个副本：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let r1 = new request('https://foo.com');
let r2 = new request(r1);

console.log(r2.url); // https://foo.com/</code></pre>
            <p class="calibre1">如果再传入<code class="calibre11">init</code>对象，则<code class="calibre11">init</code>对象的值会覆盖源对象中同名的值：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let r1 = new request('https://foo.com');
let r2 = new request(r1, {method: 'post'});

console.log(r1.method); // get
console.log(r2.method); // post</code></pre>
            <p class="calibre1">这种克隆方式并不总能得到一模一样的副本。最明显的是，第一个请求的请求体会被标记为“已使用”：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let r1 = new request('https://foo.com',
                     { method: 'post', body: 'foobar' });
let r2 = new request(r1);

console.log(r1.bodyused); // true
console.log(r2.bodyused); // false</code></pre>
            <p class="calibre1">如果源对象与创建的新对象不同源，则<code class="calibre11">referrer</code>属性会被清除。此外，如果源对象的<code class="calibre11">mode</code>为<code class="calibre11">navigate</code>，则会被转换为<code class="calibre11">same-origin</code>。</p>
            <p class="calibre1">第二种克隆<code class="calibre11">Request</code>对象的方式是使用<code class="calibre11">clone()</code>方法，这个方法会创建一模一样的副本，任何值都不会被覆盖。与第一种方式不同，这种方法不会将任何请求的请求体标记为“已使用”：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let r1 = new request('https://foo.com', { method: 'post', body: 'foobar' });
let r2 = r1.clone();

console.log(r1.url);      // https://foo.com/
console.log(r2.url);      // https://foo.com/

console.log(r1.bodyused); // false
console.log(r2.bodyused); // false</code></pre>
            <p class="calibre1">如果请求对象的<code class="calibre11">bodyUsed</code>属性为<code class="calibre11">true</code>（即请求体已被读取），那么上述任何一种方式都不能用来创建这个对象的副本。在请求体被读取之后再克隆会导致抛出<code class="calibre11">TypeError</code>。</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let r = new request('https://foo.com');
r.clone();
new request(r);
// 没有错误

r.text();  // 设置bodyused为true
r.clone();
// typeerror: failed to execute 'clone' on 'request': request body is already used

new request(r);
// typeerror: failed to construct 'request': cannot construct a request with a
request object that has already been used.</code></pre>
            <p class="calibre1"></p>
          </li>
          <li value="3" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">在<code class="calibre11">fetch()</code>中使用<code class="calibre11">Request</code>对象</strong>
            </p>
            <p class="calibre1">
              <code class="calibre11">fetch()</code>和<code class="calibre11">Request</code>构造函数拥有相同的函数签名并不是巧合。在调用<code class="calibre11">fetch()</code>时，可以传入已经创建好的<code class="calibre11">Request</code>实例而不是URL。与<code class="calibre11">Request</code>构造函数一样，传给<code class="calibre11">fetch()</code>的<code class="calibre11">init</code>对象会覆盖传入请求对象的值：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let r = new request('https://foo.com');

// 向foo.com发送get请求
fetch(r);

// 向foo.com发送post请求
fetch(r, { method: 'post' });</code></pre>
            <p class="calibre1">
              <code class="calibre11">fetch()</code>会在内部克隆传入的<code class="calibre11">Request</code>对象。与克隆<code class="calibre11">Request</code>一样，<code class="calibre11">fetch()</code>也不能拿请求体已经用过的<code class="calibre11">Request</code>对象来发送请求：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let r = new request('https://foo.com',
                    { method: 'post', body: 'foobar' });

r.text();

fetch(r);
// typeerror: cannot construct a request with a request object that has already
been used.</code></pre>
            <p class="calibre1">关键在于，通过<code class="calibre11">fetch</code>使用<code class="calibre11">Request</code>会将请求体标记为已使用。也就是说，有请求体的<code class="calibre11">Request</code>只能在一次<code class="calibre11">fetch</code>中使用。（不包含请求体的请求不受此限制。）演示如下：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let r = new request('https://foo.com',
                    { method: 'post', body: 'foobar' });

fetch(r);

fetch(r);
// typeerror: cannot construct a request with a request object that has already
been used.</code></pre>
            <p class="calibre1">要想基于包含请求体的相同<code class="calibre11">Request</code>对象多次调用<code class="calibre11">fetch()</code>，必须在第一次发送<code class="calibre11">fetch()</code>请求前调用<code class="calibre11">clone()</code>：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let r = new request('https://foo.com',
                    { method: 'post', body: 'foobar' });

// 3个都会成功
fetch(r.clone());
fetch(r.clone());
fetch(r);</code></pre>
          </li>
        </ol>
        <h3 id="nav_point_573" class="calibre15">24.5.5
          <code class="calibre26">Response</code>对象</h3>
        <p class="calibre1">顾名思义，<code class="calibre11">Response</code>对象是获取资源响应的接口。这个接口暴露了响应的相关信息，也暴露了使用响应体的不同方式。</p>
        <blockquote class="calibre13">
          <p class="calibre1">
            <strong class="calibre2">注意</strong>
            与响应体相关的属性和方法将在本章24.5.6节介绍。</p>
        </blockquote>
        <ol class="calibre16">
          <li value="1" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">创建<code class="calibre11">Response</code>对象</strong>
            </p>
            <p class="calibre1">可以通过构造函数初始化<code class="calibre11">Response</code>对象且不需要参数。此时响应实例的属性均为默认值，因为它并不代表实际的HTTP响应：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let r = new response();
console.log(r);
// response {
//   body: (...)
//   bodyused: false
//   headers: headers {}
//   ok: true
//   redirected: false
//   status: 200
//   statustext: "ok"
//   type: "default"
//   url: ""
// }</code></pre>
            <p class="calibre1">
              <code class="calibre11">Response</code>构造函数接收一个可选的<code class="calibre11">body</code>参数。这个<code class="calibre11">body</code>可以是<code class="calibre11">null</code>，等同于<code class="calibre11">fetch()</code>参数<code class="calibre11">init</code>中的<code class="calibre11">body</code>。还可以接收一个可选的<code class="calibre11">init</code>对象，这个对象可以包含下表所列的键和值。</p>
            <table class="table" width="90%" border="1">
              <tr class="calibre18">
                <th class="calibre19">键</th>
                <th class="calibre19">值</th>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">
                  <code class="calibre27">headers</code>
                </td>
                <td class="calibre21">必须是<code class="calibre27">Headers</code>对象实例或包含字符串键/值对的常规对象实例<br class="calibre4"/>默认为没有键/值对的<code class="calibre27">Headers</code>对象</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">
                  <code class="calibre27">status</code>
                </td>
                <td class="calibre21">表示HTTP响应状态码的整数<br class="calibre4"/>默认为200</td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">
                  <code class="calibre27">statusText</code>
                </td>
                <td class="calibre21">表示HTTP响应状态的字符串<br class="calibre4"/>默认为空字符串</td>
              </tr>
            </table>

            <p class="calibre1">可以像下面这样使用<code class="calibre11">body</code>和<code class="calibre11">init</code>来构建<code class="calibre11">Response</code>对象：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let r = new response('foobar', {
  status: 418,
  statustext: 'i\'m a teapot'
});
console.log(r);

// response {
//   body: (...)
//   bodyused: false
//   headers: headers {}
//   ok: false
//   redirected: false
//   status: 418
//   statustext: "i'm a teapot"
//   type: "default"
//   url: ""
// }</code></pre>
<p class="calibre1">大多数情况下，产生<code class="calibre11">response</code>对象的主要方式是调用<code class="calibre11">fetch()</code>，它返回一个最后会解决为<code class="calibre11">response</code>对象的期约，这个<code class="calibre11">response</code>对象代表实际的http响应。下面的代码展示了这样得到的<code class="calibre11">response</code>对象：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">fetch('https://foo.com')
  .then((response) =&gt; {
    console.log(response);
  });

// response {
//   body: (...)
//   bodyused: false
//   headers: headers {}
//   ok: true
//   redirected: false
//   status: 200
//   statustext: "ok"
//   type: "basic"
//   url: "https://foo.com/"
// }</code></pre>
<p class="calibre1"><code class="calibre11">response</code>类还有两个用于生成<code class="calibre11">response</code>对象的静态方法：<code class="calibre11">response.redirect()</code>和<code class="calibre11">response.error()</code>。前者接收一个url和一个重定向状态码（301、302、303、307或308），返回重定向的<code class="calibre11">response</code>对象：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">
console.log(response.redirect('https://foo.com', 301));
// response {
//   body: (...)
//   bodyused: false
//   headers: headers {}
//   ok: false
//   redirected: false
//   status: 301
//   statustext: ""
//   type: "default"
//   url: ""
// }</code></pre>
<p class="calibre1">提供的状态码必须对应重定向，否则会抛出错误：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">response.redirect('https://foo.com', 200);
// rangeerror: failed to execute 'redirect' on 'response': invalid status code</code></pre>
<p class="calibre1">另一个静态方法<code class="calibre11">response.error()</code>用于产生表示网络错误的<code class="calibre11">response</code>对象（网络错误会导致<code class="calibre11">fetch()</code>期约被拒绝）。</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">console.log(response.error());
// response {
//   body: (...)
//   bodyused: false
//   headers: headers {}
//   ok: false
//   redirected: false
//   status: 0
//   statustext: ""
//   type: "error"
//   url: ""
// }</code></pre>
<p class="calibre1"> </p>
</li>
<li value="2" class="di_1ji_wu_xu_lie_biao"><p class="calibre1"><strong class="calibre2">读取响应状态信息</strong></p>
<p class="calibre1"><code class="calibre11">response</code>对象包含一组只读属性，描述了请求完成后的状态，如下表所示。</p>
<table class="table" width="90%" border="1"><tr class="calibre18"><th class="calibre19">属性</th><th class="calibre19">值</th></tr><tr class="calibre20"><td class="calibre21"><code class="calibre27">headers</code></td><td class="calibre21">响应包含的<code class="calibre27">headers</code>对象</td></tr><tr class="calibre18"><td class="calibre21"><code class="calibre27">ok</code></td><td class="calibre21">布尔值，表示http状态码的含义。200~299的状态码返回<code class="calibre27">true</code>，其他状态码返回<code class="calibre27">false</code></td></tr><tr class="calibre20"><td class="calibre21"><code class="calibre27">redirected</code></td><td class="calibre21">布尔值，表示响应是否至少经过一次重定向</td></tr><tr class="calibre18"><td class="calibre21"><code class="calibre27">status</code></td><td class="calibre21">整数，表示响应的http状态码</td></tr><tr class="calibre20"><td class="calibre21"><code class="calibre27">statustext</code></td><td class="calibre21">字符串，包含对http状态码的正式描述。这个值派生自可选的http reason-phrase字段，因此如果服务器以reason-phrase为由拒绝响应，这个字段可能是空字符串</td></tr><tr class="calibre18"><td class="calibre21"><code class="calibre27">type</code></td><td class="calibre21">字符串，包含响应类型。可能是下列字符串值之一<br class="calibre4"/>• <code class="calibre27">basic</code>：表示标准的同源响应<br class="calibre4"/>• <code class="calibre27">cors</code>：表示标准的跨源响应<br class="calibre4"/>• <code class="calibre27">error</code>：表示响应对象是通过<code class="calibre27">response.error()</code>创建的<br class="calibre4"/>• <code class="calibre27">opaque</code>：表示<code class="calibre27">no-cors</code>的<code class="calibre27">fetch()</code>返回的跨源响应<br class="calibre4"/>• <code class="calibre27">opaqueredirect</code>：表示对<code class="calibre27">redirect</code>设置为<code class="calibre27">manual</code>的请求的响应</td></tr><tr class="calibre20"><td class="calibre21"><code class="calibre27">url</code></td><td class="calibre21">包含响应url的字符串。对于重定向响应，这是最终的url，非重定向响应就是它产生的</td></tr></table>

<p class="calibre1">以下代码演示了返回200、302、404和500状态码的url对应的响应：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">fetch('//foo.com').then(console.log);
// response {
//   body: (...)
//   bodyused: false
//   headers: headers {}
//   ok: true
//   redirected: false
//   status: 200
//   statustext: "ok"
//   type: "basic"
//   url: "https://foo.com/"
// }

fetch('//foo.com/redirect-me').then(console.log);
// response {
//   body: (...)
//   bodyused: false
//   headers: headers {}
//   ok: true
//   redirected: true
//   status: 200
//   statustext: "ok"
//   type: "basic"
//   url: "https://foo.com/redirected-url/"
// }

fetch('//foo.com/does-not-exist').then(console.log);
// response {
//   body: (...)
//   bodyused: false
//   headers: headers {}
//   ok: false
//   redirected: true
//   status: 404
//   statustext: "not found"
//   type: "basic"
//   url: "https://foo.com/does-not-exist/"
// }

fetch('//foo.com/throws-error').then(console.log);
// response {
//   body: (...)
//   bodyused: false
//   headers: headers {}
//   ok: false
//   redirected: true
//   status: 500
//   statustext: "internal server error"
//   type: "basic"
//   url: "https://foo.com/throws-error/"
// }</code></pre>
<p class="calibre1"> </p>
</li>
<li value="3" class="di_1ji_wu_xu_lie_biao"><p class="calibre1"><strong class="calibre2">克隆<code class="calibre11">response</code>对象</strong></p>
<p class="calibre1">克隆<code class="calibre11">response</code>对象的主要方式是使用<code class="calibre11">clone()</code>方法，这个方法会创建一个一模一样的副本，不会覆盖任何值。这样不会将任何请求的请求体标记为已使用：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">let r1 = new response('foobar');
let r2 = r1.clone();

console.log(r1.bodyused); // false
console.log(r2.bodyused); // false</code></pre>
<p class="calibre1">如果响应对象的<code class="calibre11">bodyused</code>属性为<code class="calibre11">true</code>（即响应体已被读取），则不能再创建这个对象的副本。在响应体被读取之后再克隆会导致抛出<code class="calibre11">typeerror</code>。</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">let r = new response('foobar');
r.clone();
// 没有错误

r.text();  // 设置bodyused为true

r.clone();
// typeerror: failed to execute 'clone' on 'response': response body is
already used</code></pre>
<p class="calibre1">有响应体的<code class="calibre11">response</code>对象只能读取一次。（不包含响应体的<code class="calibre11">response</code>对象不受此限制。）比如：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">let r = new response('foobar');

r.text().then(console.log); // foobar

r.text().then(console.log);
// typeerror: failed to execute 'text' on 'response': body stream is locked</code></pre>
<p class="calibre1">要多次读取包含响应体的同一个<code class="calibre11">response</code>对象，必须在第一次读取前调用<code class="calibre11">clone()</code>：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">let r = new response('foobar');

r.clone().text().then(console.log); // foobar
r.clone().text().then(console.log); // foobar
r.text().then(console.log);         // foobar</code></pre>
<p class="calibre1">此外，通过创建带有原始响应体的<code class="calibre11">response</code>实例，可以执行伪克隆操作。关键是这样不会把第一个<code class="calibre11">response</code>实例标记为已读，而是会在两个响应之间<strong class="calibre2">共享</strong>：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">let r1 = new response('foobar');
let r2 = new response(r1.body);

console.log(r1.bodyused);    // false
console.log(r2.bodyused);    // false

r2.text().then(console.log); // foobar
r1.text().then(console.log);
// typeerror: failed to execute 'text' on 'response': body stream is locked</code></pre>
</li>
</ol>
<h3 id="nav_point_574" class="calibre15">24.5.6　<code class="calibre26">request</code>、<code class="calibre26">response</code>及<code class="calibre26">body</code>混入</h3>
<p class="calibre1"><code class="calibre11">request</code>和<code class="calibre11">response</code>都使用了fetch api的<code class="calibre11">body</code>混入，以实现两者承担有效载荷的能力。这个混入为两个类型提供了只读的<code class="calibre11">body</code>属性（实现为<code class="calibre11">readablestream</code>）、只读的<code class="calibre11">bodyused</code>布尔值（表示<code class="calibre11">body</code>流是否已读）和一组方法，用于从流中读取内容并将结果转换为某种javascript对象类型。</p>
<p class="calibre1">通常，将<code class="calibre11">request</code>和<code class="calibre11">response</code>主体作为流来使用主要有两个原因。一个原因是有效载荷的大小可能会导致网络延迟，另一个原因是流api本身在处理有效载荷方面是有优势的。除此之外，最好是一次性获取资源主体。</p>
<p class="calibre1"><code class="calibre11">body</code>混入提供了5个方法，用于将<code class="calibre11">readablestream</code>转存到缓冲区的内存里，将缓冲区转换为某种javascript对象类型，以及通过期约来产生结果。在解决之前，期约会等待主体流报告完成及缓冲被解析。这意味着客户端必须等待响应的资源完全加载才能访问其内容。</p>
<ol class="calibre16">
<li value="1" class="di_1ji_wu_xu_lie_biao"><p class="calibre1"><strong class="calibre2"><code class="calibre11">body.text()</code></strong></p>
<p class="calibre1"><code class="calibre11">body.text()</code>方法返回期约，解决为将缓冲区转存得到的utf-8格式字符串。下面的代码展示了在<code class="calibre11">response</code>对象上使用<code class="calibre11">body.text()</code>：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">fetch('https://foo.com')
  .then((response) =&gt; response.text())
  .then(console.log);

// &lt;!doctype html&gt;&lt;html lang="en"&gt;
//  &lt;head&gt;
//   &lt;meta charset="utf-8"&gt;
//   ...</code></pre>
<p class="calibre1">以下代码展示了在<code class="calibre11">request</code>对象上使用<code class="calibre11">body.text()</code>：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">let request = new request('https://foo.com',
                          { method: 'post', body: 'barbazqux' });

request.text()
  .then(console.log);

// barbazqux</code></pre>
<p class="calibre1"> </p>
</li>
<li value="2" class="di_1ji_wu_xu_lie_biao"><p class="calibre1"><strong class="calibre2"><code class="calibre11">body.json()</code></strong></p>
<p class="calibre1"><code class="calibre11">body.json()</code>方法返回期约，解决为将缓冲区转存得到的json。下面的代码展示了在<code class="calibre11">response</code>对象上使用<code class="calibre11">body.json()</code>：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">fetch('https://foo.com/foo.json')
  .then((response) =&gt; response.json())
  .then(console.log);

// {"foo": "bar"}</code></pre>
<p class="calibre1">以下代码展示了在<code class="calibre11">request</code>对象上使用<code class="calibre11">body.json()</code>：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">let request = new request('https://foo.com',
                          { method:'post', body: json.stringify({ bar: 'baz' }) });

request.json()
  .then(console.log);

// {bar: 'baz'}</code></pre>
<p class="calibre1"> </p>
</li>
<li value="3" class="di_1ji_wu_xu_lie_biao"><p class="calibre1"><strong class="calibre2"><code class="calibre11">body.formdata()</code></strong></p>
<p class="calibre1">浏览器可以将<code class="calibre11">formdata</code>对象序列化/反序列化为主体。例如，下面这个<code class="calibre11">formdata</code>实例：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">let myformdata = new formdata();
myformdata.append('foo', 'bar');</code></pre>
<p class="calibre1">在通过http传送时，webkit浏览器会将其序列化为下列内容：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">------webkitformboundarydr9q2koze6nbn7er
content-disposition: form-data; name="foo"

bar
------webkitformboundarydr9q2koze6nbn7er--</code></pre>
<p class="calibre1"><code class="calibre11">body.formdata()</code>方法返回期约，解决为将缓冲区转存得到的<code class="calibre11">formdata</code>实例。下面的代码展示了在<code class="calibre11">response</code>对象上使用<code class="calibre11">body.formdata()</code>：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">fetch('https://foo.com/form-data')
  .then((response) =&gt; response.formdata())
  .then((formdata) =&gt; console.log(formdata.get('foo'));

// bar</code></pre>
<p class="calibre1">以下代码展示了在<code class="calibre11">request</code>对象上使用<code class="calibre11">body.formdata()</code>：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">let myformdata = new formdata();
myformdata.append('foo', 'bar');

let request = new request('https://foo.com',
                          { method:'post', body: myformdata });

request.formdata()
  .then((formdata) =&gt; console.log(formdata.get('foo'));

// bar</code></pre>
<p class="calibre1"> </p>
</li>
<li value="4" class="di_1ji_wu_xu_lie_biao"><p class="calibre1"><strong class="calibre2"><code class="calibre11">body.arraybuffer()</code></strong></p>
<p class="calibre1">有时候，可能需要以原始二进制格式查看和修改主体。为此，可以使用<code class="calibre11">body.arraybuffer()</code>将主体内容转换为<code class="calibre11">arraybuffer</code>实例。<code class="calibre11">body.arraybuffer()</code>方法返回期约，解决为将缓冲区转存得到的<code class="calibre11">arraybuffer</code>实例。下面的代码展示了在<code class="calibre11">response</code>对象上使用<code class="calibre11">body.arraybuffer()</code>：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">fetch('https://foo.com')
  .then((response) =&gt; response.arraybuffer())
  .then(console.log);

// arraybuffer(...) {}</code></pre>
<p class="calibre1">以下代码展示了在<code class="calibre11">request</code>对象上使用<code class="calibre11">body.arraybuffer()</code>：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">let request = new request('https://foo.com',
                          { method:'post', body: 'abcdefg' });

// 以整数形式打印二进制编码的字符串
request.arraybuffer()
  .then((buf) =&gt; console.log(new int8array(buf)));

// int8array(7) [97, 98, 99, 100, 101, 102, 103]</code></pre>
<p class="calibre1"> </p>
</li>
<li value="5" class="di_1ji_wu_xu_lie_biao"><p class="calibre1"><strong class="calibre2"><code class="calibre11">body.blob()</code></strong></p>
<p class="calibre1">有时候，可能需要以原始二进制格式使用主体，不用查看和修改。为此，可以使用<code class="calibre11">body.blob()</code>将主体内容转换为<code class="calibre11">blob</code>实例。<code class="calibre11">body.blob()</code>方法返回期约，解决为将缓冲区转存得到的<code class="calibre11">blob</code>实例。下面的代码展示了在<code class="calibre11">response</code>对象上使用<code class="calibre11">body.blob()</code>：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">fetch('https://foo.com')
  .then((response) =&gt; response.blob())
  .then(console.log);

// blob(...) {size:..., type: "..."}</code></pre>
<p class="calibre1">以下代码展示了在<code class="calibre11">request</code>对象上使用<code class="calibre11">body.blob()</code>：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">let request = new request('https://foo.com',
                          { method:'post', body: 'abcdefg' });

request.blob()
  .then(console.log);

// blob(7) {size: 7, type: "text/plain;charset=utf-8"}</code></pre>
<p class="calibre1"> </p>
</li>
<li value="6" class="di_1ji_wu_xu_lie_biao"><p class="calibre1"><strong class="calibre2">一次性流</strong></p>
<p class="calibre1">因为<code class="calibre11">body</code>混入是构建在<code class="calibre11">readablestream</code>之上的，所以主体流只能使用一次。这意味着所有主体混入方法都只能调用一次，再次调用就会抛出错误。</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">fetch('https://foo.com')
  .then((response) =&gt; response.blob().then(() =&gt; response.blob()));

// typeerror: failed to execute 'blob' on 'response': body stream is locked
let request = new request('https://foo.com',
                          { method: 'post', body: 'foobar' });

request.blob().then(() =&gt; request.blob());
// typeerror: failed to execute 'blob' on 'request': body stream is locked</code></pre>
<p class="calibre1">即使是在读取流的过程中，所有这些方法也会在它们被调用时给<code class="calibre11">readablestream</code>加锁，以阻止其他读取器访问：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">fetch('https://foo.com')
  .then((response) =&gt; {
    response.blob(); // 第一次调用给流加锁
    response.blob(); // 第二次调用再次加锁会失败
  });

// typeerror: failed to execute 'blob' on 'response': body stream is locked
let request = new request('https://foo.com',
                          { method: 'post', body: 'foobar' });

request.blob(); // 第一次调用给流加锁
request.blob(); // 第二次调用再次加锁会失败
// typeerror: failed to execute 'blob' on 'request': body stream is locked</code></pre>
<p class="calibre1">作为<code class="calibre11">body</code>混入的一部分，<code class="calibre11">bodyused</code>布尔值属性表示<code class="calibre11">readablestream</code>是否已<strong class="calibre2">摄受</strong>（disturbed），意思是读取器是否已经在流上加了锁。这不一定表示流已经被完全读取。下面的代码演示了这个属性：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">let request = new request('https://foo.com',
                          { method: 'post', body: 'foobar' });
let response = new response('foobar');

console.log(request.bodyused);     // false
console.log(response.bodyused);    // false

request.text().then(console.log);  // foobar
response.text().then(console.log); // foobar

console.log(request.bodyused);     // true
console.log(response.bodyused);    // true</code></pre>
<p class="calibre1"> </p>
</li>
<li value="7" class="di_1ji_wu_xu_lie_biao"><p class="calibre1"><strong class="calibre2">使用<code class="calibre11">readablestream</code>主体</strong></p>
<p class="calibre1">javascript编程逻辑很多时候会将访问网络作为原子操作，比如请求是同时创建和发送的，响应数据也是以统一的格式一次性暴露出来的。这种约定隐藏了底层的混乱，让涉及网络的代码变得很清晰。</p>
<p class="calibre1">从tcp/ip角度来看，传输的数据是以分块形式抵达端点的，而且速度受到网速的限制。接收端点会为此分配内存，并将收到的块写入内存。fetch api通过<code class="calibre11">readablestream</code>支持在这些块到达时就实时读取和操作这些数据。</p>
<blockquote class="calibre13">
<p class="calibre1"><strong class="calibre2">注意</strong>　本节会以获取fetch api规范的html为例。这个页面差不多有1mb大小，足以让示例中接收的数据分成多个块。</p>
</blockquote>
<p class="calibre1">正如stream api所定义的，<code class="calibre11">readablestream</code>暴露了<code class="calibre11">getreader()</code>方法，用于产生<code class="calibre11">readablestreamdefaultreader</code>，这个读取器可以用于在数据到达时异步获取数据块。数据流的格式是<code class="calibre11">uint8array</code>。</p>
<p class="calibre1">下面的代码调用了读取器的<code class="calibre11">read()</code>方法，把最早可用的块打印了出来：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">fetch('https://fetch.spec.whatwg.org/')
  .then((response) =&gt; response.body)
  .then((body) =&gt; {
    let reader = body.getreader();

    console.log(reader); // readablestreamdefaultreader {}

    reader.read()
      .then(console.log);
  });

// { value: uint8array{}, done: false }</code></pre>
<p class="calibre1">在随着数据流的到来取得整个有效载荷，可以像下面这样递归调用<code class="calibre11">read()</code>方法：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">fetch('https://fetch.spec.whatwg.org/')
  .then((response) =&gt; response.body)
  .then((body) =&gt; {
    let reader = body.getreader();

    function processnextchunk({value, done}) {
      if (done) {
        return;
      }

      console.log(value);

      return reader.read()
          .then(processnextchunk);
    }

    return reader.read()
        .then(processnextchunk);
  });

// { value: uint8array{}, done: false }
// { value: uint8array{}, done: false }
// { value: uint8array{}, done: false }
// ...</code></pre>
<p class="calibre1">异步函数非常适合这样的<code class="calibre11">fetch()</code>操作。可以通过使用<code class="calibre11">async</code>/<code class="calibre11">await</code>将上面的递归调用打平：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">fetch('https://fetch.spec.whatwg.org/')
  .then((response) =&gt; response.body)
  .then(async function(body) {
    let reader = body.getreader();

    while(true) {
      let { value, done } = await reader.read();

        if (done) {
          break;
        }

        console.log(value);
      }
    });

// { value: uint8array{}, done: false }
// { value: uint8array{}, done: false }
// { value: uint8array{}, done: false }
// ...</code></pre>
<p class="calibre1">另外，<code class="calibre11">read()</code>方法也可以真接封装到<code class="calibre11">iterable</code>接口中。因此就可以在<code class="calibre11">for-await-of</code>循环中方便地实现这种转换：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">fetch('https://fetch.spec.whatwg.org/')
  .then((response) =&gt; response.body)
  .then(async function(body) {
    let reader = body.getreader();

    let asynciterable = {
      [symbol.asynciterator]() {
        return {
          next() {
            return reader.read();
          }
        };
      }
    };

    for await (chunk of asynciterable) {
      console.log(chunk);
    }
  });

// { value: uint8array{}, done: false }
// { value: uint8array{}, done: false }
// { value: uint8array{}, done: false }
// ...</code></pre>
<p class="calibre1">通过将异步逻辑包装到一个生成器函数中，还可以进一步简化代码。而且，这个实现通过支持只读取部分流也变得更稳健。如果流因为耗尽或错误而终止，读取器会释放锁，以允许不同的流读取器继续操作：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">async function* streamgenerator(stream) {
  const reader = stream.getreader();

  try {
    while (true) {
      const { value, done } = await reader.read();

      if (done) {
        break;
      }

      yield value;
    }
  } finally {
    reader.releaselock();
  }
}

fetch('https://fetch.spec.whatwg.org/')
  .then((response) =&gt; response.body)
  .then(async function(body) {
    for await (chunk of streamgenerator(body)) {
      console.log(chunk);
    }
  });</code></pre>
<p class="calibre1">在这些例子中，当读取完<code class="calibre11">uint8array</code>块之后，浏览器会将其标记为可以被垃圾回收。对于需要在不连续的内存中连续检查大量数据的情况，这样可以节省很多内存空间。</p>
<p class="calibre1">缓冲区的大小，以及浏览器是否等待缓冲区被填充后才将其推到流中，要根据javascript运行时的实现。浏览器会控制等待分配的缓冲区被填满，同时会尽快将缓冲区数据（有时候可能未填充数据）发送到流。</p>
<p class="calibre1">不同浏览器中分块大小可能不同，这取决于带宽和网络延迟。此外，浏览器如果决定不等待网络，也可以将部分填充的缓冲区发送到流。最终，我们的代码要准备好处理以下情况：</p>
<ul class="calibre17">
<li class="di_1ji_wu_xu_lie_biao">不同大小的<code class="calibre11">uint8array</code>块；</li>
<li class="di_1ji_wu_xu_lie_biao">部分填充的<code class="calibre11">uint8array</code>块；</li>
<li class="di_1ji_wu_xu_lie_biao">块到达的时间间隔不确定。</li>
</ul>
<p class="calibre1">默认情况下，块是以<code class="calibre11">uint8array</code>格式抵达的。因为块的分割不会考虑编码，所以会出现某些值作为多字节字符被分散到两个连续块中的情况。手动处理这些情况是很麻烦的，但很多时候可以使用encoding api的可插拔方案。</p>
<p class="calibre1">要将<code class="calibre11">uint8array</code>转换为可读文本，可以将缓冲区传给<code class="calibre11">textdecoder</code>，返回转换后的值。通过设置<code class="calibre11">stream: true</code>，可以将之前的缓冲区保留在内存，从而让跨越两个块的内容能够被正确解码：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">let decoder = new textdecoder();

async function* streamgenerator(stream) {
  const reader = stream.getreader();

  try {
    while (true) {
      const { value, done } = await reader.read();

      if (done) {
        break;
      }

      yield value;
    }
  } finally {
    reader.releaselock();
  }
}

fetch('https://fetch.spec.whatwg.org/')
  .then((response) =&gt; response.body)
  .then(async function(body) {
    for await (chunk of streamgenerator(body)) {
      console.log(decoder.decode(chunk, { stream: true }));
    }
  });

// &lt;!doctype html&gt;&lt;html lang="en"&gt; ...
// whether a &lt;a data-link-type="dfn" href="#concept-header" ...
// result to &lt;var&gt;rangevalue&lt;/var&gt;. ...
// ...</code></pre>
<p class="calibre1">因为可以使用<code class="calibre11">readablestream</code>创建<code class="calibre11">response</code>对象，所以就可以在读取流之后，将其通过管道导入另一个流。然后在这个新流上再使用<code class="calibre11">body</code>的方法，如<code class="calibre11">text()</code>。这样就可以随着流的到达实时检查和操作流内容。下面的代码展示了这种双流技术：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">fetch('https://fetch.spec.whatwg.org/')
  .then((response) =&gt; response.body)
  .then((body) =&gt; {
    const reader = body.getreader();

    // 创建第二个流
    return new readablestream({
      async 首页(controller) {
        try {
          while (true) {
            const { value, done } = await reader.read();

            if (done) {
              break;
            }

            // 将主体流的块推到第二个流
            controller.enqueue(value);
          }
        } finally {
          controller.close();
          reader.releaselock();
        }
      }
    })
  })
  .then((secondarystream) =&gt; new response(secondarystream))
  .then(response =&gt; response.text())
  .then(console.log);

// &lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt; ...</code></pre>
</li>
</ol>



  </div>

  
  <div class="calibretoc">
    <h2><a href="../../54m0dfqx.html">table of contents
</a></h2>
    <div>
  <ul>
    <li>
      <a href="part0002.html#nav_point_0">版权声明</a>
    </li>
    <li>
      <a href="part0003.html#nav_point_1">献词</a>
    </li>
    <li>
      <a href="part0004.html#nav_point_2">译者序</a>
    </li>
    <li>
      <a href="part0005.html#nav_point_3">序</a>
    </li>
    <li>
      <a href="part0006.html#nav_point_4">前言</a>
    </li>
    <li>
      <a href="part0012.html#nav_point_10">致谢</a>
    </li>
    <li>
      <a href="part0013.html#nav_point_11">第 1 章 什么是javascript</a>
    </li>
    <li>
      <a href="part0018.html#nav_point_19">第 2 章 html中的javascript</a>
    </li>
    <li>
      <a href="part0024.html#nav_point_31">第 3 章 语言基础</a>
    </li>
    <li>
      <a href="part0033.html#nav_point_78">第 4 章 变量、作用域与内存</a>
    </li>
    <li>
      <a href="part0038.html#nav_point_93">第 5 章 基本引用类型</a>
    </li>
    <li>
      <a href="part0044.html#nav_point_111">第 6 章 集合引用类型</a>
    </li>
    <li>
      <a href="part0054.html#nav_point_153">第 7 章 迭代器与生成器</a>
    </li>
    <li>
      <a href="part0059.html#nav_point_166">第 8 章 对象、类与面向对象编程</a>
    </li>
    <li>
      <a href="part0065.html#nav_point_194">第 9 章 代理与反射</a>
    </li>
    <li>
      <a href="part0070.html#nav_point_225">第 10 章 函数</a>
    </li>
    <li>
      <a href="part0088.html#nav_point_258">第 11 章 期约与异步函数</a>
    </li>
    <li>
      <a href="part0093.html#nav_point_273">第 12 章 bom</a>
    </li>
    <li>
      <a href="part0100.html#nav_point_294">第 13 章 客户端检测</a>
    </li>
    <li>
      <a href="part0105.html#nav_point_306">第 14 章 dom</a>
    </li>
    <li>
      <a href="part0110.html#nav_point_328">第 15 章 dom扩展</a>
    </li>
    <li>
      <a href="part0116.html#nav_point_348">第 16 章 dom2和dom3</a>
    </li>
    <li>
      <a href="part0122.html#nav_point_370">第 17 章 事件</a>
    </li>
    <li>
      <a href="part0130.html#nav_point_403">第 18 章 动画与canvas图形</a>
    </li>
    <li>
      <a href="part0136.html#nav_point_428">第 19 章 表单脚本</a>
    </li>
    <li>
      <a href="part0143.html#nav_point_450">第 20 章 javascript api</a>
    </li>
    <li>
      <a href="part0157.html#nav_point_500">第 21 章 错误处理与调试</a>
    </li>
    <li>
      <a href="part0163.html#nav_point_526">第 22 章 处理xml</a>
    </li>
    <li>
      <a href="part0168.html#nav_point_542">第 23 章 json</a>
    </li>
    <li>
      <a href="part0172.html#nav_point_552">第 24 章 网络请求与远程资源</a>
    </li>
    <li>
      <a href="part0182.html#nav_point_582">第 25 章 客户端存储</a>
    </li>
    <li>
      <a href="part0187.html#nav_point_607">第 26 章 模块</a>
    </li>
    <li>
      <a href="part0193.html#nav_point_633">第 27 章 工作者线程</a>
    </li>
    <li>
      <a href="part0199.html#nav_point_667">第 28 章 最佳实践</a>
    </li>
    <li>
      <a href="part0204.html#nav_point_683">附录 a es2018和es2019</a>
    </li>
    <li>
      <a href="part0215.html#nav_point_708">附录 b 严格模式</a>
    </li>
    <li>
      <a href="part0223.html#nav_point_719">附录 c javascript库和框架</a>
    </li>
    <li>
      <a href="part0227.html#nav_point_741">附录 d javascript工具</a>
    </li>
    <li>
      <a href="part0239.html#nav_point_800">作者简介</a>
    </li>
  </ul>
</div>


  </div>
  

  <div class="calibreebnav">
    
      <a href="part0176.html" class="calibreaprev">上一页
</a>
    

    <a href="../../54m0dfqx.html" class="calibreahome">首页
</a>

    
      <a href="part0178.html" class="calibreanext">下一页
</a>
    
  </div>

</div>

</body>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-6487844781006261"
     data-ad-slot="3432081921"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</html>
