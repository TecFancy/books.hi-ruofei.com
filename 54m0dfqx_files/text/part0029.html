<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>

    <title>JavaScript高级程序设计（第4版）</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" type="text/css" href="../stylesheet.css"/>
    <link rel="stylesheet" type="text/css" href="../page_styles.css"/>

    <link href="../calibreHtmlOutBasicCss.css" type="text/css" rel="stylesheet"/>

  </head>
  <body>

    <div class="calibreMeta">
      <div class="calibreMetaTitle">

        <h1>
          <a href="../../54m0dfqx.html">JavaScript高级程序设计（第4版）
          </a>
        </h1>

      </div>
      <div class="calibreMetaAuthor">
        [美] 马特 • 弗里斯比

      </div>
    </div>

    <div class="calibreMain">

      <div class="calibreEbookContent">

        <div class="calibreEbNavTop">

          <a href="part0028.html" class="calibreAPrev">上一页
          </a>

          <a href="part0030.html" class="calibreANext">下一页
          </a>

        </div>

        <h2 id="nav_point_53" class="calibre9">3.5 操作符</h2>
        <p class="calibre1">ECMA-262描述了一组可用于操作数据值的<strong class="calibre2">操作符</strong>，包括数学操作符（如加、减）、位操作符、关系操作符和相等操作符等。ECMAScript中的操作符是独特的，因为它们可用于各种值，包括字符串、数值、布尔值，甚至还有对象。在应用给对象时，操作符通常会调用<code class="calibre11">valueOf()</code>和<code class="calibre11">/</code>或<code class="calibre11">toString()</code>方法来取得可以计算的值。</p>
        <h3 id="nav_point_54" class="calibre15">3.5.1 一元操作符</h3>
        <p class="calibre1">只操作一个值的操作符叫<strong class="calibre2">一元操作符</strong>（unary operator）。一元操作符是ECMAScript中最简单的操作符。</p>
        <ol class="calibre16">
          <li value="1" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">递增/递减操作符</strong>
            </p>
            <p class="calibre1">递增和递减操作符直接照搬自C语言，但有两个版本：前缀版和后缀版。顾名思义，前缀版就是位于要操作的变量前头，后缀版就是位于要操作的变量后头。前缀递增操作符会给数值加1，把两个加号（<code class="calibre11">++</code>）放到变量前头即可：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let age = 29;
++age;</code></pre>
            <p class="calibre1">在这个例子中，前缀递增操作符把<code class="calibre11">age</code>的值变成了30（给之前的值29加1）。因此，它实际上等于如下表达式：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let age = 29;
age = age + 1;</code></pre>
            <p class="calibre1">前缀递减操作符也类似，只不过是从一个数值减1。使用前缀递减操作符，只要把两个减号（<code class="calibre11">--</code>）放到变量前头即可：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let age = 29;
--age;</code></pre>
            <p class="calibre1">执行操作后，变量<code class="calibre11">age</code>的值变成了28（从29减1）。</p>
            <p class="calibre1">无论使用前缀递增还是前缀递减操作符，变量的值都会在语句被求值之前改变。（在计算机科学中，这通常被称为具有<strong class="calibre2">副作用</strong>。）请看下面的例子：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let age = 29;
let anotherage = --age + 2;

console.log(age);         // 28
console.log(anotherage);  // 30</code></pre>
            <p class="calibre1">在这个例子中，变量<code class="calibre11">anotherAge</code>以<code class="calibre11">age</code>减1后的值再加2进行初始化。因为递减操作先发生，所以<code class="calibre11">age</code>的值先变成28，然后再加2，结果是30。</p>
            <p class="calibre1">前缀递增和递减在语句中的优先级是相等的，因此会从左到右依次求值。比如：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let num1 = 2;
let num2 = 20;
let num3 = --num1 + num2;
let num4 = num1 + num2;
console.log(num3);  // 21
console.log(num4);  // 21</code></pre>
            <p class="calibre1">这里，<code class="calibre11">num3</code>等于21是因为<code class="calibre11">num1</code>先减1之后才加<code class="calibre11">num2</code>。变量<code class="calibre11">num4</code>也是21，那是因为加法使用的也是递减后的值。</p>
            <p class="calibre1">递增和递减的后缀版语法一样（分别是<code class="calibre11">++</code>和<code class="calibre11">--</code>），只不过要放在变量后面。后缀版与前缀版的主要区别在于，后缀版递增和递减在语句被求值后才发生。在某些情况下，这种差异没什么影响，比如：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let age = 29;
age++;</code></pre>
            <p class="calibre1">把递增操作符放到变量后面不会改变语句执行的结果，因为递增是唯一的操作。可是，在跟其他操作混合时，差异就会变明显，比如：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let num1 = 2;
let num2 = 20;
let num3 = num1-- + num2;
let num4 = num1 + num2;
console.log(num3);  // 22
console.log(num4);  // 21</code></pre>
            <p class="calibre1">这个例子跟前面的那个一样，只是把前缀递减改成了后缀递减，区别很明显。在使用前缀版的例子中，<code class="calibre11">num3</code>和<code class="calibre11">num4</code>的值都是21。而在这个例子中，<code class="calibre11">num3</code>的值是22，<code class="calibre11">num4</code>的值是21。这里的不同之处在于，计算<code class="calibre11">num3</code>时使用的是<code class="calibre11">num1</code>的原始值（2），而计算<code class="calibre11">num4</code>时使用的是<code class="calibre11">num1</code>递减后的值（1）。</p>
            <p class="calibre1">这4个操作符可以作用于任何值，意思是不限于整数——字符串、布尔值、浮点值，甚至对象都可以。递增和递减操作符遵循如下规则。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">对于字符串，如果是有效的数值形式，则转换为数值再应用改变。变量类型从字符串变成数值。</li>
              <li class="di_1ji_wu_xu_lie_biao">对于字符串，如果不是有效的数值形式，则将变量的值设置为<code class="calibre11">NaN</code>。变量类型从字符串变成数值。</li>
              <li class="di_1ji_wu_xu_lie_biao">对于布尔值，如果是<code class="calibre11">false</code>，则转换为0再应用改变。变量类型从布尔值变成数值。</li>
              <li class="di_1ji_wu_xu_lie_biao">对于布尔值，如果是<code class="calibre11">true</code>，则转换为1再应用改变。变量类型从布尔值变成数值。</li>
              <li class="di_1ji_wu_xu_lie_biao">对于浮点值，加1或减1。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果是对象，则调用其（第5章会详细介绍的）<code class="calibre11">valueOf()</code>方法取得可以操作的值。对得到的值应用上述规则。如果是<code class="calibre11">NaN</code>，则调用<code class="calibre11">toString()</code>并再次应用其他规则。变量类型从对象变成数值。</li>
            </ul>
            <p class="calibre1">下面的例子演示了这些规则：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let s1 = "2";
let s2 = "z";
let b = false;
let f = 1.1;
let o = {
  valueof() {
    return -1;
  }
};

s1++;  // 值变成数值3
s2++;  // 值变成nan
b++;   // 值变成数值1
f--;   // 值变成0.10000000000000009（因为浮点数不精确）
o--;   // 值变成-2</code></pre>
            <p class="calibre1"></p>
          </li>
          <li value="2" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">一元加和减</strong>
            </p>
            <p class="calibre1">
              <strong class="calibre2">一元加和减操作符</strong>对大多数开发者来说并不陌生，它们在ECMAScript中跟在高中数学中的用途一样。一元加由一个加号（<code class="calibre11">+</code>）表示，放在变量前头，对数值没有任何影响：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let num = 25;
num = +num;
console.log(num); // 25</code></pre>
            <p class="calibre1">如果将一元加应用到非数值，则会执行与使用<code class="calibre11">Number()</code>转型函数一样的类型转换：布尔值<code class="calibre11">false</code>和<code class="calibre11">true</code>转换为0和1，字符串根据特殊规则进行解析，对象会调用它们的<code class="calibre11">valueOf()</code>和/或<code class="calibre11">toString()</code>方法以得到可以转换的值。</p>
            <p class="calibre1">下面的例子演示了一元加在应用到不同数据类型时的行为：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let s1 = "01";
let s2 = "1.1";
let s3 = "z";
let b = false;
let f = 1.1;
let o = {
  valueof() {
    return -1;
  }
};

s1 = +s1;  // 值变成数值1
s2 = +s2;  // 值变成数值1.1
s3 = +s3;  // 值变成nan
b = +b;    // 值变成数值0
f = +f;    // 不变，还是1.1
o = +o;    // 值变成数值-1</code></pre>
            <p class="calibre1">一元减由一个减号（<code class="calibre11">-</code>）表示，放在变量前头，主要用于把数值变成负值，如把1转换为-1。示例如下：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let num = 25;
num = -num;
console.log(num);  // -25</code></pre>
            <p class="calibre1">对数值使用一元减会将其变成相应的负值（如上面的例子所示）。在应用到非数值时，一元减会遵循与一元加同样的规则，先对它们进行转换，然后再取负值：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let s1 = "01";
let s2 = "1.1";
let s3 = "z";
let b = false;
let f = 1.1;
let o = {
  valueof() {
    return -1;
  }
};

s1 = -s1;  // 值变成数值-1
s2 = -s2;  // 值变成数值-1.1
s3 = -s3;  // 值变成nan
b = -b;    // 值变成数值0
f = -f;    // 变成-1.1
o = -o;    // 值变成数值1</code></pre>
            <p class="calibre1">一元加和减操作符主要用于基本的算术，但也可以像上面的例子那样，用于数据类型转换。</p>
          </li>
        </ol>
        <h3 id="nav_point_55" class="calibre15">3.5.2 位操作符</h3>
        <p class="calibre1">接下来要介绍的操作符用于数值的底层操作，也就是操作内存中表示数据的比特（位）。ECMAScript中的所有数值都以IEEE 754 64位格式存储，但位操作并不直接应用到64位表示，而是先把值转换为32位整数，再进行位操作，之后再把结果转换为64位。对开发者而言，就好像只有32位整数一样，因为64位整数存储格式是不可见的。既然知道了这些，就只需要考虑32位整数即可。</p>
        <p class="calibre1">有符号整数使用32位的前31位表示整数值。第32位表示数值的符号，如0表示正，1表示负。这一位称为<strong class="calibre2">符号位</strong>（sign bit），它的值决定了数值其余部分的格式。正值以真正的二进制格式存储，即31位中的每一位都代表2的幂。第一位（称为第0位）表示2<sup class="calibre29">0</sup>，第二位表示2<sup class="calibre29">1</sup>，依此类推。如果一个位是空的，则以0填充，相当于忽略不计。比如，数值18的二进制格式为00000000000000000000000000010010，或更精简的10010。后者是用到的5个有效位，决定了实际的值（如图3-1所示）。</p>
        <p class="calibre7"><img src="../images/00075.gif" alt="" width="50%" class="calibre14"/></p>
        <p class="calibre1">
          <strong class="calibre2">图 3-1</strong>
        </p>
        <p class="calibre1">负值以一种称为<strong class="calibre2">二补数</strong>（或补码）的二进制编码存储。一个数值的二补数通过如下3个步骤计算得到：</p>
        <p class="calibre1">(1) 确定绝对值的二进制表示（如，对于-18，先确定18的二进制表示）；</p>
        <p class="calibre1">(2) 找到数值的一补数（或反码），换句话说，就是每个0都变成1，每个1都变成0；</p>
        <p class="calibre1">(3) 给结果加1。</p>
        <p class="calibre1">基于上述步骤确定-18的二进制表示，首先从18的二进制表示开始：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">0000  0000  0000  0000  0000  0000  0001  0010</code></pre>
        <p class="calibre1">然后，计算一补数，即反转每一位的二进制值：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">1111  1111  1111  1111  1111  1111  1110  1101</code></pre>
        <p class="calibre1">最后，给一补数加1：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">1111  1111  1111  1111  1111  1111  1110  1101
                        1
----------------------------------------------
1111  1111  1111  1111  1111  1111  1110  1110</code></pre>
        <p class="calibre1">那么，-18的二进制表示就是11111111111111111111111111101110。要注意的是，在处理有符号整数时，我们无法访问第31位。</p>
        <p class="calibre1">ECMAScript会帮我们记录这些信息。在把负值输出为一个二进制字符串时，我们会得到一个前面加了减号的绝对值，如下所示：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let num = -18;
console.log(num.tostring(2)); // "-10010"</code></pre>
        <p class="calibre1">在将-18转换为二进制字符串时，结果得到-10010。转换过程会求得二补数，然后再以更符合逻辑的形式表示出来。</p>
        <blockquote class="calibre13">
          <p class="calibre1">
            <strong class="calibre2">注意</strong>
            默认情况下，ECMAScript中的所有整数都表示为有符号数。不过，确实存在无符号整数。对无符号整数来说，第32位不表示符号，因为只有正值。无符号整数比有符号整数的范围更大，因为符号位被用来表示数值了。</p>
        </blockquote>
        <p class="calibre1">在对ECMAScript中的数值应用位操作符时，后台会发生转换：64位数值会转换为32位数值，然后执行位操作，最后再把结果从32位转换为64位存储起来。整个过程就像处理32位数值一样，这让二进制操作变得与其他语言中类似。但这个转换也导致了一个奇特的副作用，即特殊值<code class="calibre11">NaN</code>和<code class="calibre11">Infinity</code>在位操作中都会被当成0处理。</p>
        <p class="calibre1">如果将位操作符应用到非数值，那么首先会使用<code class="calibre11">Number()</code>函数将该值转换为数值（这个过程是自动的），然后再应用位操作。最终结果是数值。</p>
        <ol class="calibre16">
          <li value="1" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">按位非</strong>
            </p>
            <p class="calibre1">按位非操作符用波浪符（<code class="calibre11">~</code>）表示，它的作用是返回数值的一补数。按位非是ECMAScript中为数不多的几个二进制数学操作符之一。看下面的例子：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let num1 = 25;      // 二进制00000000000000000000000000011001
let num2 = ~num1;   // 二进制11111111111111111111111111100110
console.log(num2);  // -26</code></pre>
            <p class="calibre1">这里，按位非操作符作用到了数值25，得到的结果是-26。由此可以看出，按位非的最终效果是对数值取反并减1，就像执行如下操作的结果一样：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let num1 = 25;
let num2 = -num1 - 1;
console.log(num2);   // "-26"</code></pre>
            <p class="calibre1">实际上，尽管两者返回的结果一样，但位操作的速度快得多。这是因为位操作是在数值的底层表示上完成的。<br class="calibre4"/>
            </p>
          </li>
          <li value="2" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">按位与</strong>
            </p>
            <p class="calibre1">按位与操作符用和号（<code class="calibre11">&amp;</code>）表示，有两个操作数。本质上，按位与就是将两个数的每一个位对齐，然后基于真值表中的规则，对每一位执行相应的与操作。</p>
            <table class="table" width="90%" border="1">
              <tr class="calibre18">
                <th class="calibre19">第一个数值的位</th>
                <th class="calibre19">第二个数值的位</th>
                <th class="calibre19">结果</th>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">1</td>
                <td class="calibre21">1</td>
                <td class="calibre21">1</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">1</td>
                <td class="calibre21">0</td>
                <td class="calibre21">0</td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">0</td>
                <td class="calibre21">1</td>
                <td class="calibre21">0</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">0</td>
                <td class="calibre21">0</td>
                <td class="calibre21">0</td>
              </tr>
            </table>

            <p class="calibre1">按位与操作在两个位都是1时返回1，在任何一位是0时返回0。</p>
            <p class="calibre1">下面看一个例子，我们对数值25和3求与操作，如下所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let result = 25 &amp; 3;
console.log(result); // 1</code></pre>
            <p class="calibre1">25和3的按位与操作的结果是1。为什么呢？看下面的二进制计算过程：</p>
            <pre class="dai_ma_wu_xing_hao">
 25 = 0000 0000 0000 0000 0000 0000 0001 1001
  3 = 0000 0000 0000 0000 0000 0000 0000 0011
---------------------------------------------
and = 0000 0000 0000 0000 0000 0000 0000 0001
</pre>

            <p class="calibre1">如上所示，25和3的二进制表示中，只有第0位上的两个数都是1。于是结果数值的所有其他位都会以0填充，因此结果就是1。<br class="calibre4"/>
            </p>
          </li>
          <li value="3" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">按位或</strong>
            </p>
            <p class="calibre1">按位或操作符用管道符（<code class="calibre11">|</code>）表示，同样有两个操作数。按位或遵循如下真值表：</p>
            <table class="table" width="90%" border="1">
              <tr class="calibre18">
                <th class="calibre19">第一个数值的位</th>
                <th class="calibre19">第二个数值的位</th>
                <th class="calibre19">结果</th>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">1</td>
                <td class="calibre21">1</td>
                <td class="calibre21">1</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">1</td>
                <td class="calibre21">0</td>
                <td class="calibre21">1</td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">0</td>
                <td class="calibre21">1</td>
                <td class="calibre21">1</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">0</td>
                <td class="calibre21">0</td>
                <td class="calibre21">0</td>
              </tr>
            </table>

            <p class="calibre1">按位或操作在至少一位是1时返回1，两位都是0时返回0。</p>
            <p class="calibre1">仍然用按位与的示例，如果对25和3执行按位或，代码如下所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let result = 25 | 3;
console.log(result); // 27</code></pre>
            <p class="calibre1">可见25和3的按位或操作的结果是27：</p>
            <pre class="dai_ma_wu_xing_hao">
 25 = 0000 0000 0000 0000 0000 0000 0001 1001
  3 = 0000 0000 0000 0000 0000 0000 0000 0011
---------------------------------------------
 or = 0000 0000 0000 0000 0000 0000 0001 1011
</pre>

            <p class="calibre1">在参与计算的两个数中，有4位都是1，因此它们直接对应到结果上。二进制码11011等于27。<br class="calibre4"/>
            </p>
          </li>
          <li value="4" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">按位异或</strong>
            </p>
            <p class="calibre1">按位异或用脱字符（<code class="calibre11">^</code>）表示，同样有两个操作数。下面是按位异或的真值表：</p>
            <table class="table" width="90%" border="1">
              <tr class="calibre18">
                <th class="calibre19">第一个数的位</th>
                <th class="calibre19">第二个数的位</th>
                <th class="calibre19">结果</th>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">1</td>
                <td class="calibre21">1</td>
                <td class="calibre21">0</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">1</td>
                <td class="calibre21">0</td>
                <td class="calibre21">1</td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">0</td>
                <td class="calibre21">1</td>
                <td class="calibre21">1</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">0</td>
                <td class="calibre21">0</td>
                <td class="calibre21">0</td>
              </tr>
            </table>

            <p class="calibre1">按位异或与按位或的区别是，它只在一位上是1的时候返回1（两位都是1或0，则返回0）。</p>
            <p class="calibre1">对数值25和3执行按位异或操作：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let result = 25 ^ 3;
console.log(result); // 26</code></pre>
            <p class="calibre1">可见，25和3的按位异或操作结果为26，如下所示：</p>
            <pre class="dai_ma_wu_xing_hao">
 25 = 0000 0000 0000 0000 0000 0000 0001 1001
  3 = 0000 0000 0000 0000 0000 0000 0000 0011
---------------------------------------------
xor = 0000 0000 0000 0000 0000 0000 0001 1010
</pre>

            <p class="calibre1">两个数在4位上都是1，但两个数的第0位都是1，因此那一位在结果中就变成了0。其余位上的1在另一个数上没有对应的1，因此会直接传递到结果中。二进制码11010等于26。（注意，这比对同样两个值执行按位或操作得到的结果小1。）<br class="calibre4"/>
            </p>
          </li>
          <li value="5" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">左移</strong>
            </p>
            <p class="calibre1">左移操作符用两个小于号（<code class="calibre11">&lt;&lt;</code>）表示，会按照指定的位数将数值的所有位向左移动。比如，如果数值2（二进制10）向左移5位，就会得到64（二进制1000000），如下所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let oldvalue = 2;              // 等于二进制10
let newvalue = oldvalue &lt;&lt; 5;  // 等于二进制1000000，即十进制64</code></pre>
            <p class="calibre1">注意在移位后，数值右端会空出5位。左移会以0填充这些空位，让结果是完整的32位数值（见图3-2）。</p>
            <p class="calibre1"><img src="../images/00059.gif" alt="{%}" class="calibre12"/></p>
            <p class="calibre1">
              <strong class="calibre2">图 3-2</strong>
            </p>
            <p class="calibre1">注意，左移会保留它所操作数值的符号。比如，如果-2左移5位，将得到-64，而不是正64。<br class="calibre4"/>
            </p>
          </li>
          <li value="6" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">有符号右移</strong>
            </p>
            <p class="calibre1">有符号右移由两个大于号（<code class="calibre11">&gt;&gt;</code>）表示，会将数值的所有32位都向右移，同时保留符号（正或负）。有符号右移实际上是左移的逆运算。比如，如果将64右移5位，那就是2：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let oldvalue = 64;             // 等于二进制1000000
let newvalue = oldvalue &gt;&gt; 5;  // 等于二进制10，即十进制2</code></pre>
            <p class="calibre1">同样，移位后就会出现空位。不过，右移后空位会出现在左侧，且在符号位之后（见图3-3）。ECMAScript会用符号位的值来填充这些空位，以得到完整的数值。</p>
            <p class="calibre1"><img src="../images/00063.gif" alt="{%}" class="calibre12"/></p>
            <p class="calibre1">
              <strong class="calibre2">图 3-3</strong><br class="calibre4"/>
            </p>
          </li>
          <li value="7" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">无符号右移</strong>
            </p>
            <p class="calibre1">无符号右移用3个大于号表示（<code class="calibre11">&gt;&gt;&gt;</code>），会将数值的所有32位都向右移。对于正数，无符号右移与有符号右移结果相同。仍然以前面有符号右移的例子为例，64向右移动5位，会变成2：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let oldvalue = 64;              // 等于二进制1000000
let newvalue = oldvalue &gt;&gt;&gt; 5;  // 等于二进制10，即十进制2</code></pre>
            <p class="calibre1">对于负数，有时候差异会非常大。与有符号右移不同，无符号右移会给空位补0，而不管符号位是什么。对正数来说，这跟有符号右移效果相同。但对负数来说，结果就差太多了。无符号右移操作符将负数的二进制表示当成正数的二进制表示来处理。因为负数是其绝对值的二补数，所以右移之后结果变得非常之大，如下面的例子所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let oldvalue = -64;              // 等于二进制11111111111111111111111111000000
let newvalue = oldvalue &gt;&gt;&gt; 5;   // 等于十进制134217726</code></pre>
            <p class="calibre1">在对-64无符号右移5位后，结果是134 217 726。这是因为-64的二进制表示是11111111111111111111111111000000，无符号右移却将它当成正值，也就是4 294 967 232。把这个值右移5位后，结果是00000111111111111111111111111110，即134 217 726。</p>
          </li>
        </ol>
        <h3 id="nav_point_56" class="calibre15">3.5.3 布尔操作符</h3>
        <p class="calibre1">对于编程语言来说，布尔操作符跟相等操作符几乎同样重要。如果没有能力测试两个值的关系，那么像<code class="calibre11">if-else</code>和循环这样的语句也没什么用了。布尔操作符一共有3个：逻辑非、逻辑与和逻辑或。</p>
        <ol class="calibre16">
          <li value="1" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">逻辑非</strong>
            </p>
            <p class="calibre1">逻辑非操作符由一个叹号（<code class="calibre11">!</code>）表示，可应用给ECMAScript中的任何值。这个操作符始终返回布尔值，无论应用到的是什么数据类型。逻辑非操作符首先将操作数转换为布尔值，然后再对其取反。换句话说，逻辑非操作符会遵循如下规则。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">如果操作数是对象，则返回<code class="calibre11">false</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果操作数是空字符串，则返回<code class="calibre11">true</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果操作数是非空字符串，则返回<code class="calibre11">false</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果操作数是数值0，则返回<code class="calibre11">true</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果操作数是非0数值（包括<code class="calibre11">Infinity</code>），则返回<code class="calibre11">false</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果操作数是<code class="calibre11">null</code>，则返回<code class="calibre11">true</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果操作数是<code class="calibre11">NaN</code>，则返回<code class="calibre11">true</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果操作数是<code class="calibre11">undefined</code>，则返回<code class="calibre11">true</code>。</li>
            </ul>
            <p class="calibre1">以下示例验证了上述行为：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">console.log(!false);   // true
console.log(!"blue");  // false
console.log(!0);       // true
console.log(!nan);     // true
console.log(!"");      // true
console.log(!12345);   // false</code></pre>
            <p class="calibre1">逻辑非操作符也可以用于把任意值转换为布尔值。同时使用两个叹号（<code class="calibre11">!!</code>），相当于调用了转型函数<code class="calibre11">Boolean()</code>。无论操作数是什么类型，第一个叹号总会返回布尔值。第二个叹号对该布尔值取反，从而给出变量真正对应的布尔值。结果与对同一个值使用<code class="calibre11">Boolean()</code>函数是一样的：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">console.log(!!"blue"); // true
console.log(!!0);      // false
console.log(!!nan);    // false
console.log(!!"");     // false
console.log(!!12345);  // true</code></pre>
            <p class="calibre1"></p>
          </li>
          <li value="2" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">逻辑与</strong>
            </p>
            <p class="calibre1">逻辑与操作符由两个和号（<code class="calibre11">&amp;&amp;</code>）表示，应用到两个值，如下所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let result = true &amp;&amp; false;</code></pre>
            <p class="calibre1">逻辑与操作符遵循如下真值表：</p>
            <table class="table" width="90%" border="1">
              <tr class="calibre18">
                <th class="calibre19">第一个操作数</th>
                <th class="calibre19">第二个操作数</th>
                <th class="calibre19">结果</th>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">
                  <code class="calibre27">true</code>
                </td>
                <td class="calibre21">
                  <code class="calibre27">true</code>
                </td>
                <td class="calibre21">
                  <code class="calibre27">true</code>
                </td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">
                  <code class="calibre27">true</code>
                </td>
                <td class="calibre21">
                  <code class="calibre27">false</code>
                </td>
                <td class="calibre21">
                  <code class="calibre27">false</code>
                </td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">
                  <code class="calibre27">false</code>
                </td>
                <td class="calibre21">
                  <code class="calibre27">true</code>
                </td>
                <td class="calibre21">
                  <code class="calibre27">false</code>
                </td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">
                  <code class="calibre27">false</code>
                </td>
                <td class="calibre21">
                  <code class="calibre27">false</code>
                </td>
                <td class="calibre21">
                  <code class="calibre27">false</code>
                </td>
              </tr>
            </table>

            <p class="calibre1">逻辑与操作符可用于任何类型的操作数，不限于布尔值。如果有操作数不是布尔值，则逻辑与并不一定会返回布尔值，而是遵循如下规则。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">如果第一个操作数是对象，则返回第二个操作数。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果第二个操作数是对象，则只有第一个操作数求值为<code class="calibre11">true</code>才会返回该对象。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果两个操作数都是对象，则返回第二个操作数。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果有一个操作数是<code class="calibre11">null</code>，则返回<code class="calibre11">null</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果有一个操作数是<code class="calibre11">NaN</code>，则返回<code class="calibre11">NaN</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果有一个操作数是<code class="calibre11">undefined</code>，则返回<code class="calibre11">undefined</code>。</li>
            </ul>
            <p class="calibre1">逻辑与操作符是一种短路操作符，意思就是如果第一个操作数决定了结果，那么永远不会对第二个操作数求值。对逻辑与操作符来说，如果第一个操作数是<code class="calibre11">false</code>，那么无论第二个操作数是什么值，结果也不可能等于<code class="calibre11">true</code>。看下面的例子：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let found = true;
let result = (found &amp;&amp; someundeclaredvariable); // 这里会出错
console.log(result); // 不会执行这一行</code></pre>
            <p class="calibre1">上面的代码之所以会出错，是因为<code class="calibre11">someUndeclaredVariable</code>没有事先声明，所以当逻辑与操作符对它求值时就会报错。变量<code class="calibre11">found</code>的值是<code class="calibre11">true</code>，逻辑与操作符会继续求值变量<code class="calibre11">someUndeclaredVariable</code>。但是由于<code class="calibre11">someUndeclaredVariable</code>没有定义，不能对它应用逻辑与操作符，因此就报错了。假如变量<code class="calibre11">found</code>的值是<code class="calibre11">false</code>，那么就不会报错了：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let found = false;
let result = (found &amp;&amp; someundeclaredvariable);  // 不会出错
console.log(result);  // 会执行</code></pre>
            <p class="calibre1">这里，<code class="calibre11">console.log</code>会成功执行。即使变量<code class="calibre11">someUndeclaredVariable</code>没有定义，由于第一个操作数是<code class="calibre11">false</code>，逻辑与操作符也不会对它求值，因为此时对<code class="calibre11">&amp;&amp;</code>右边的操作数求值是没有意义的。在使用逻辑与操作符时，一定别忘了它的这个短路的特性。<br class="calibre4"/>
            </p>
          </li>
          <li value="3" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">逻辑或</strong>
            </p>
            <p class="calibre1">逻辑或操作符由两个管道符（<code class="calibre11">||</code>）表示，比如：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let result = true || false;</code></pre>
            <p class="calibre1">逻辑或操作符遵循如下真值表：</p>
            <table class="table" width="90%" border="1">
              <tr class="calibre18">
                <th class="calibre19">第一个操作数</th>
                <th class="calibre19">第二个操作数</th>
                <th class="calibre19">结果</th>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">
                  <code class="calibre27">true</code>
                </td>
                <td class="calibre21">
                  <code class="calibre27">true</code>
                </td>
                <td class="calibre21">
                  <code class="calibre27">true</code>
                </td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">
                  <code class="calibre27">true</code>
                </td>
                <td class="calibre21">
                  <code class="calibre27">false</code>
                </td>
                <td class="calibre21">
                  <code class="calibre27">true</code>
                </td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">
                  <code class="calibre27">false</code>
                </td>
                <td class="calibre21">
                  <code class="calibre27">true</code>
                </td>
                <td class="calibre21">
                  <code class="calibre27">true</code>
                </td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">
                  <code class="calibre27">false</code>
                </td>
                <td class="calibre21">
                  <code class="calibre27">false</code>
                </td>
                <td class="calibre21">
                  <code class="calibre27">false</code>
                </td>
              </tr>
            </table>

            <p class="calibre1">与逻辑与类似，如果有一个操作数不是布尔值，那么逻辑或操作符也不一定返回布尔值。它遵循如下规则。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">如果第一个操作数是对象，则返回第一个操作数。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果第一个操作数求值为<code class="calibre11">false</code>，则返回第二个操作数。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果两个操作数都是对象，则返回第一个操作数。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果两个操作数都是<code class="calibre11">null</code>，则返回<code class="calibre11">null</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果两个操作数都是<code class="calibre11">NaN</code>，则返回<code class="calibre11">NaN</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果两个操作数都是<code class="calibre11">undefined</code>，则返回<code class="calibre11">undefined</code>。</li>
            </ul>
            <p class="calibre1">同样与逻辑与类似，逻辑或操作符也具有短路的特性。只不过对逻辑或而言，第一个操作数求值为<code class="calibre11">true</code>，第二个操作数就不会再被求值了。看下面的例子：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let found = true;
let result = (found || someundeclaredvariable); // 不会出错
console.log(result); // 会执行</code></pre>
            <p class="calibre1">跟前面的例子一样，变量<code class="calibre11">someUndeclaredVariable</code>也没有定义。但是，因为变量<code class="calibre11">found</code>的值为<code class="calibre11">true</code>，所以逻辑或操作符不会对变量<code class="calibre11">someUndeclaredVariable</code>求值，而直接返回<code class="calibre11">true</code>。假如把<code class="calibre11">found</code>的值改为<code class="calibre11">false</code>，那就会报错了：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let found = false;
let result = (found || someundeclaredvariable); // 这里会出错
console.log(result); // 不会执行这一行</code></pre>
            <p class="calibre1">利用这个行为，可以避免给变量赋值<code class="calibre11">null</code>或<code class="calibre11">undefined</code>。比如：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let myobject = preferredobject || backupobject;</code></pre>
            <p class="calibre1">在这个例子中，变量<code class="calibre11">myObject</code>会被赋予两个值中的一个。其中，<code class="calibre11">preferredObject</code>变量包含首选的值，<code class="calibre11">backupObject</code>变量包含备用的值。如果<code class="calibre11">preferredObject</code>不是<code class="calibre11">null</code>，则它的值就会赋给<code class="calibre11">myObject</code>；如果<code class="calibre11">preferredObject</code>是<code class="calibre11">null</code>，则<code class="calibre11">backupObject</code>的值就会赋给<code class="calibre11">myObject</code>。这种模式在ECMAScript代码中经常用于变量赋值，本书后面的代码示例中也会经常用到。</p>
          </li>
        </ol>
        <h3 id="nav_point_57" class="calibre15">3.5.4 乘性操作符</h3>
        <p class="calibre1">ECMAScript定义了3个乘性操作符：乘法、除法和取模。这些操作符跟它们在Java、C语言及Perl中对应的操作符作用一样，但在处理非数值时，它们也会包含一些自动的类型转换。如果乘性操作符有不是数值的操作数，则该操作数会在后台被使用<code class="calibre11">Number()</code>转型函数转换为数值。这意味着空字符串会被当成0，而布尔值<code class="calibre11">true</code>会被当成1。</p>
        <ol class="calibre16">
          <li value="1" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">乘法操作符</strong>
            </p>
            <p class="calibre1">乘法操作符由一个星号（<code class="calibre11">*</code>）表示，可以用于计算两个数值的乘积。其语法类似于C语言，比如：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let result = 34 * 56;</code></pre>
            <p class="calibre1">不过，乘法操作符在处理特殊值时也有一些特殊的行为。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">如果操作数都是数值，则执行常规的乘法运算，即两个正值相乘是正值，两个负值相乘也是正值，正负符号不同的值相乘得到负值。如果ECMAScript不能表示乘积，则返回<code class="calibre11">Infinity</code>或<code class="calibre11">-Infinity</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果有任一操作数是<code class="calibre11">NaN</code>，则返回<code class="calibre11">NaN</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果是<code class="calibre11">Infinity</code>乘以0，则返回<code class="calibre11">NaN</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果是<code class="calibre11">Infinity</code>乘以非0的有限数值，则根据第二个操作数的符号返回<code class="calibre11">Infinity</code>或<code class="calibre11">-Infinity</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果是<code class="calibre11">Infinity</code>乘以<code class="calibre11">Infinity</code>，则返回<code class="calibre11">Infinity</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果有不是数值的操作数，则先在后台用<code class="calibre11">Number()</code>将其转换为数值，然后再应用上述规则。<br class="calibre4"/>
              </li>
            </ul>
          </li>
          <li value="2" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">除法操作符</strong>
            </p>
            <p class="calibre1">除法操作符由一个斜杠（<code class="calibre11">/</code>）表示，用于计算第一个操作数除以第二个操作数的商，比如：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let result = 66 / 11;</code></pre>
            <p class="calibre1">跟乘法操作符一样，除法操作符针对特殊值也有一些特殊的行为。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">如果操作数都是数值，则执行常规的除法运算，即两个正值相除是正值，两个负值相除也是正值，符号不同的值相除得到负值。如果ECMAScript不能表示商，则返回<code class="calibre11">Infinity</code>或<code class="calibre11">-Infinity</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果有任一操作数是<code class="calibre11">NaN</code>，则返回<code class="calibre11">NaN</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果是<code class="calibre11">Infinity</code>除以<code class="calibre11">Infinity</code>，则返回<code class="calibre11">NaN</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果是0除以0，则返回<code class="calibre11">NaN</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果是非0的有限值除以0，则根据第一个操作数的符号返回<code class="calibre11">Infinity</code>或<code class="calibre11">-Infinity</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果是<code class="calibre11">Infinity</code>除以任何数值，则根据第二个操作数的符号返回<code class="calibre11">Infinity</code>或<code class="calibre11">-Infinity</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果有不是数值的操作数，则先在后台用<code class="calibre11">Number()</code>函数将其转换为数值，然后再应用上述规则。<br class="calibre4"/>
              </li>
            </ul>
          </li>
          <li value="3" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">取模操作符</strong>
            </p>
            <p class="calibre1">取模（余数）操作符由一个百分比符号（<code class="calibre11">%</code>）表示，比如：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let result = 26 % 5; // 等于1</code></pre>
            <p class="calibre1">与其他乘性操作符一样，取模操作符对特殊值也有一些特殊的行为。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">如果操作数是数值，则执行常规除法运算，返回余数。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果被除数是无限值，除数是有限值，则返回<code class="calibre11">NaN</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果被除数是有限值，除数是0，则返回<code class="calibre11">NaN</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果是<code class="calibre11">Infinity</code>除以<code class="calibre11">Infinity</code>，则返回<code class="calibre11">NaN</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果被除数是有限值，除数是无限值，则返回被除数。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果被除数是0，除数不是0，则返回0。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果有不是数值的操作数，则先在后台用<code class="calibre11">Number()</code>函数将其转换为数值，然后再应用上述规则。</li>
            </ul>
          </li>
        </ol>
        <h3 id="nav_point_58" class="calibre15">3.5.5 指数操作符</h3>
        <p class="calibre1">ECMAScript 7新增了指数操作符，<code class="calibre11">Math.pow()</code>现在有了自己的操作符<code class="calibre11">**</code>，结果是一样的：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">console.log(math.pow(3, 2);    // 9
console.log(3 ** 2);           // 9

console.log(math.pow(16, 0.5); // 4
console.log(16** 0.5);         // 4</code></pre>
        <p class="calibre1">不仅如此，指数操作符也有自己的指数赋值操作符<code class="calibre11">**=</code>，该操作符执行指数运算和结果的赋值操作：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let squared = 3;
squared **= 2;
console.log(squared); // 9

let sqrt = 16;
sqrt **= 0.5;
console.log(sqrt); // 4</code></pre>
        <h3 id="nav_point_59" class="calibre15">3.5.6 加性操作符</h3>
        <p class="calibre1">加性操作符，即加法和减法操作符，一般都是编程语言中最简单的操作符。不过，在ECMAScript中，这两个操作符拥有一些特殊的行为。与乘性操作符类似，加性操作符在后台会发生不同数据类型的转换。只不过对这两个操作符来说，转换规则不是那么直观。</p>
        <ol class="calibre16">
          <li value="1" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">加法操作符</strong>
            </p>
            <p class="calibre1">加法操作符（<code class="calibre11">+</code>）用于求两个数的和，比如：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let result = 1 + 2;</code></pre>
            <p class="calibre1">如果两个操作数都是数值，加法操作符执行加法运算并根据如下规则返回结果：</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">如果有任一操作数是<code class="calibre11">NaN</code>，则返回<code class="calibre11">NaN</code>；</li>
              <li class="di_1ji_wu_xu_lie_biao">如果是<code class="calibre11">Infinity</code>加<code class="calibre11">Infinity</code>，则返回<code class="calibre11">Infinity</code>；</li>
              <li class="di_1ji_wu_xu_lie_biao">如果是<code class="calibre11">-Infinity</code>加<code class="calibre11">-Infinity</code>，则返回<code class="calibre11">-Infinity</code>；</li>
              <li class="di_1ji_wu_xu_lie_biao">如果是<code class="calibre11">Infinity</code>加<code class="calibre11">-Infinity</code>，则返回<code class="calibre11">NaN</code>；</li>
              <li class="di_1ji_wu_xu_lie_biao">如果是<code class="calibre11">+0</code>加<code class="calibre11">+0</code>，则返回<code class="calibre11">+0</code>；</li>
              <li class="di_1ji_wu_xu_lie_biao">如果是<code class="calibre11">-0</code>加<code class="calibre11">+0</code>，则返回<code class="calibre11">+0</code>；</li>
              <li class="di_1ji_wu_xu_lie_biao">如果是<code class="calibre11">-0</code>加<code class="calibre11">-0</code>，则返回<code class="calibre11">-0</code>。</li>
            </ul>
            <p class="calibre1">不过，如果有一个操作数是字符串，则要应用如下规则：</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">如果两个操作数都是字符串，则将第二个字符串拼接到第一个字符串后面；</li>
              <li class="di_1ji_wu_xu_lie_biao">如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再将两个字符串拼接在一起。</li>
            </ul>
            <p class="calibre1">如果有任一操作数是对象、数值或布尔值，则调用它们的<code class="calibre11">toString()</code>方法以获取字符串，然后再应用前面的关于字符串的规则。对于<code class="calibre11">undefined</code>和<code class="calibre11">null</code>，则调用<code class="calibre11">String()</code>函数，分别获取<code class="calibre11">"undefined"</code>和<code class="calibre11">"null"</code>。</p>
            <p class="calibre1">看下面的例子：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let result1 = 5 + 5;        // 两个数值
console.log(result1);       // 10
let result2 = 5 + "5";      // 一个数值和一个字符串
console.log(result2);       // "55"</code></pre>
            <p class="calibre1">以上代码展示了加法操作符的两种运算模式。正常情况下，<code class="calibre11">5 + 5</code>等于10（数值），如前两行代码所示。但是，如果将一个操作数改为字符串，比如<code class="calibre11">"5"</code>，则相加的结果就变成了<code class="calibre11">"55"</code>（原始字符串值），因为第一个操作数也会被转换为字符串。</p>
            <p class="calibre1">ECMAScript中最常犯的一个错误，就是忽略加法操作中涉及的数据类型。比如下面这个例子：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let num1 = 5;
let num2 = 10;
let message = "the sum of 5 and 10 is " + num1 + num2;
console.log(message);  // "the sum of 5 and 10 is 510"</code></pre>
            <p class="calibre1">这里，变量<code class="calibre11">message</code>中保存的是一个字符串，是执行两次加法操作之后的结果。有人可能会认为最终得到的字符串是<code class="calibre11">"The sum of 5 and 10 is 15"</code>。可是，实际上得到的是<code class="calibre11">"The sum of 5 and 10 is 510"</code>。这是因为每次加法运算都是独立完成的。第一次加法的操作数是一个字符串和一个数值（5），结果还是一个字符串。第二次加法仍然是用一个字符串去加一个数值（10），同样也会得到一个字符串。如果想真正执行数学计算，然后把结果追加到字符串末尾，只要使用一对括号即可：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let num1 = 5;
let num2 = 10;
let message = "the sum of 5 and 10 is " + (num1 + num2);
console.log(message); // "the sum of 5 and 10 is 15"</code></pre>
            <p class="calibre1">在此，我们用括号把两个数值变量括了起来，意思是让解释器先执行两个数值的加法，然后再把结果追加给字符串。因此，最终得到的字符串变成了<code class="calibre11">"The sum of 5 and 10 is 15"</code>。<br class="calibre4"/>
            </p>
          </li>
          <li value="2" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">减法操作符</strong>
            </p>
            <p class="calibre1">减法操作符（<code class="calibre11">-</code>）也是使用很频繁的一种操作符，比如：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let result = 2 - 1;</code></pre>
            <p class="calibre1">与加法操作符一样，减法操作符也有一组规则用于处理ECMAScript中不同类型之间的转换。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">如果两个操作数都是数值，则执行数学减法运算并返回结果。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果有任一操作数是<code class="calibre11">NaN</code>，则返回<code class="calibre11">NaN</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果是<code class="calibre11">Infinity</code>减<code class="calibre11">Infinity</code>，则返回<code class="calibre11">NaN</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果是<code class="calibre11">-Infinity</code>减<code class="calibre11">-Infinity</code>，则返回<code class="calibre11">NaN</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果是<code class="calibre11">Infinity</code>减<code class="calibre11">-Infinity</code>，则返回<code class="calibre11">Infinity</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果是<code class="calibre11">-Infinity</code>减<code class="calibre11">Infinity</code>，则返回<code class="calibre11">-Infinity</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果是<code class="calibre11">+0</code>减<code class="calibre11">+0</code>，则返回<code class="calibre11">+0</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果是<code class="calibre11">+0</code>减<code class="calibre11">-0</code>，则返回<code class="calibre11">-0</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果是<code class="calibre11">-0</code>减<code class="calibre11">-0</code>，则返回<code class="calibre11">+0</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果有任一操作数是字符串、布尔值、<code class="calibre11">null</code>或<code class="calibre11">undefined</code>，则先在后台使用<code class="calibre11">Number()</code>将其转换为数值，然后再根据前面的规则执行数学运算。如果转换结果是<code class="calibre11">NaN</code>，则减法计算的结果是<code class="calibre11">NaN</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果有任一操作数是对象，则调用其<code class="calibre11">valueOf()</code>方法取得表示它的数值。如果该值是<code class="calibre11">NaN</code>，则减法计算的结果是<code class="calibre11">NaN</code>。如果对象没有<code class="calibre11">valueOf()</code>方法，则调用其<code class="calibre11">toString()</code>方法，然后再将得到的字符串转换为数值。</li>
            </ul>
            <p class="calibre1">以下示例演示了上面的规则：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let result1 = 5 - true; // true被转换为1，所以结果是4
let result2 = nan - 1;  // nan
let result3 = 5 - 3;    // 2
let result4 = 5 - "";   // ""被转换为0，所以结果是5
let result5 = 5 - "2";  // "2"被转换为2，所以结果是3
let result6 = 5 - null; // null被转换为0，所以结果是5</code></pre>
          </li>
        </ol>
        <h3 id="nav_point_60" class="calibre15">3.5.7 关系操作符</h3>
        <p class="calibre1">关系操作符执行比较两个值的操作，包括小于（<code class="calibre11">&lt;</code>）、大于（<code class="calibre11">&gt;</code>）、小于等于（<code class="calibre11">&lt;=</code>）和大于等于（<code class="calibre11">&gt;=</code>），用法跟数学课上学的一样。这几个操作符都返回布尔值，如下所示：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let result1 = 5 &gt; 3; // true
let result2 = 5 &lt; 3; // false</code></pre>
        <p class="calibre1">与ECMAScript中的其他操作符一样，在将它们应用到不同数据类型时也会发生类型转换和其他行为。</p>
        <ul class="calibre10">
          <li class="di_1ji_wu_xu_lie_biao">如果操作数都是数值，则执行数值比较。</li>
          <li class="di_1ji_wu_xu_lie_biao">如果操作数都是字符串，则逐个比较字符串中对应字符的编码。</li>
          <li class="di_1ji_wu_xu_lie_biao">如果有任一操作数是数值，则将另一个操作数转换为数值，执行数值比较。</li>
          <li class="di_1ji_wu_xu_lie_biao">如果有任一操作数是对象，则调用其<code class="calibre11">valueOf()</code>方法，取得结果后再根据前面的规则执行比较。如果没有<code class="calibre11">valueOf()</code>操作符，则调用<code class="calibre11">toString()</code>方法，取得结果后再根据前面的规则执行比较。</li>
          <li class="di_1ji_wu_xu_lie_biao">如果有任一操作数是布尔值，则将其转换为数值再执行比较。</li>
        </ul>
        <p class="calibre1">在使用关系操作符比较两个字符串时，会发生一个有趣的现象。很多人认为小于意味着“字母顺序靠前”，而大于意味着“字母顺序靠后”，实际上不是这么回事。对字符串而言，关系操作符会比较字符串中对应字符的编码，而这些编码是数值。比较完之后，会返回布尔值。问题的关键在于，大写字母的编码都小于小写字母的编码，因此以下这种情况就会发生：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let result = "brick" &lt; "alphabet"; // true</code></pre>
        <p class="calibre1">在这里，字符串<code class="calibre11">"Brick"</code>被认为小于字符串<code class="calibre11">"alphabet"</code>，因为字母B的编码是66，字母a的编码是97。要得到确实按字母顺序比较的结果，就必须把两者都转换为相同的大小写形式（全大写或全小写），然后再比较：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let result = "brick".tolowercase() &lt; "alphabet".tolowercase(); // false</code></pre>
        <p class="calibre1">将两个操作数都转换为小写，就能保证按照字母表顺序判定<code class="calibre11">"alphabet"</code>在<code class="calibre11">"Brick"</code>前头。</p>
        <p class="calibre1">另一个奇怪的现象是在比较两个数值字符串的时候，比如下面这个例子：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let result = "23" &lt; "3"; // true</code></pre>
        <p class="calibre1">这里在比较字符串<code class="calibre11">"23"</code>和<code class="calibre11">"3"</code>时返回<code class="calibre11">true</code>。因为两个操作数都是字符串，所以会逐个比较它们的字符编码（字符<code class="calibre11">"2"</code>的编码是50，而字符<code class="calibre11">"3"</code>的编码是51）。不过，如果有一个操作数是数值，那么比较的结果就对了：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let result = "23" &lt; 3; // false</code></pre>
        <p class="calibre1">因为这次会将字符串<code class="calibre11">"23"</code>转换为数值23，然后再跟3比较，结果当然对了。只要是数值和字符串比较，字符串就会先被转换为数值，然后进行数值比较。对于数值字符串而言，这样能保证结果正确。但如果字符串不能转换成数值呢？比如下面这个例子：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let result = "a" &lt; 3; // 因为"a"会转换为nan，所以结果是false</code></pre>
        <p class="calibre1">因为字符<code class="calibre11">"a"</code>不能转换成任何有意义的数值，所以只能转换为<code class="calibre11">NaN</code>。这里有一个规则，即任何关系操作符在涉及比较<code class="calibre11">NaN</code>时都返回<code class="calibre11">false</code>。这样一来，下面的例子有趣了：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let result1 = nan &lt; 3;  // false
let result2 = nan &gt;= 3; // false</code></pre>
        <p class="calibre1">在大多数比较的场景中，如果一个值不小于另一个值，那就一定大于或等于它。但在比较<code class="calibre11">NaN</code>时，无论是小于还是大于等于，比较的结果都会返回<code class="calibre11">false</code>。</p>
        <h3 id="nav_point_61" class="calibre15">3.5.8 相等操作符</h3>
        <p class="calibre1">判断两个变量是否相等是编程中最重要的操作之一。在比较字符串、数值和布尔值是否相等时，过程都很直观。但是在比较两个对象是否相等时，情形就比较复杂了。ECMAScript中的相等和不相等操作符，原本在比较之前会执行类型转换，但很快就有人质疑这种转换是否应该发生。最终，ECMAScript提供了两组操作符。第一组是<strong class="calibre2">等于</strong>和<strong class="calibre2">不等于</strong>，它们在比较之前执行转换。第二组是<strong class="calibre2">全等</strong>和<strong class="calibre2">不全等</strong>，它们在比较之前不执行转换。</p>
        <ol class="calibre16">
          <li value="1" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">等于和不等于</strong>
            </p>
            <p class="calibre1">ECMAScript中的等于操作符用两个等于号（<code class="calibre11">==</code>）表示，如果操作数相等，则会返回<code class="calibre11">true</code>。不等于操作符用叹号和等于号（<code class="calibre11">!=</code>）表示，如果两个操作数不相等，则会返回<code class="calibre11">true</code>。这两个操作符都会先进行类型转换（通常称为<strong class="calibre2">强制类型转换</strong>）再确定操作数是否相等。</p>
            <p class="calibre1">在转换操作数的类型时，相等和不相等操作符遵循如下规则。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">如果任一操作数是布尔值，则将其转换为数值再比较是否相等。<code class="calibre11">false</code>转换为0，<code class="calibre11">true</code>转换为1。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果一个操作数是对象，另一个操作数不是，则调用对象的<code class="calibre11">valueOf()</code>方法取得其原始值，再根据前面的规则进行比较。</li>
            </ul>
            <p class="calibre1">在进行比较时，这两个操作符会遵循如下规则。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">null</code>和<code class="calibre11">undefined</code>相等。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">null</code>和<code class="calibre11">undefined</code>不能转换为其他类型的值再进行比较。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果有任一操作数是<code class="calibre11">NaN</code>，则相等操作符返回<code class="calibre11">false</code>，不相等操作符返回<code class="calibre11">true</code>。记住：即使两个操作数都是<code class="calibre11">NaN</code>，相等操作符也返回<code class="calibre11">false</code>，因为按照规则，<code class="calibre11">NaN</code>不等于<code class="calibre11">NaN</code>。</li>
              <li class="di_1ji_wu_xu_lie_biao">如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回<code class="calibre11">true</code>。否则，两者不相等。</li>
            </ul>
            <p class="calibre1">下表总结了一些特殊情况及比较的结果。</p>
            <table class="table" width="90%" border="1">
              <tr class="calibre18">
                <th class="calibre19">表达式</th>
                <th class="calibre19">结果</th>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">
                  <code class="calibre27">null == undefined</code>
                </td>
                <td class="calibre21">
                  <code class="calibre27">true</code>
                </td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">
                  <code class="calibre27">"NaN" == NaN</code>
                </td>
                <td class="calibre21">
                  <code class="calibre27">false</code>
                </td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">
                  <code class="calibre27">5 == NaN</code>
                </td>
                <td class="calibre21">
                  <code class="calibre27">false</code>
                </td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">
                  <code class="calibre27">NaN == NaN</code>
                </td>
                <td class="calibre21">
                  <code class="calibre27">false</code>
                </td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">
                  <code class="calibre27">NaN != NaN</code>
                </td>
                <td class="calibre21">
                  <code class="calibre27">true</code>
                </td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">
                  <code class="calibre27">false == 0</code>
                </td>
                <td class="calibre21">
                  <code class="calibre27">true</code>
                </td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">
                  <code class="calibre27">true == 1</code>
                </td>
                <td class="calibre21">
                  <code class="calibre27">true</code>
                </td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">
                  <code class="calibre27">true == 2</code>
                </td>
                <td class="calibre21">
                  <code class="calibre27">false</code>
                </td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">
                  <code class="calibre27">undefined == 0</code>
                </td>
                <td class="calibre21">
                  <code class="calibre27">false</code>
                </td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">
                  <code class="calibre27">null == 0</code>
                </td>
                <td class="calibre21">
                  <code class="calibre27">false</code>
                </td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">
                  <code class="calibre27">"5" == 5</code>
                </td>
                <td class="calibre21">
                  <code class="calibre27">true</code>
                </td>
              </tr>
            </table>

            <p class="calibre1"></p>
          </li>
          <li value="2" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">全等和不全等</strong>
            </p>
            <p class="calibre1">全等和不全等操作符与相等和不相等操作符类似，只不过它们在比较相等时不转换操作数。全等操作符由3个等于号（<code class="calibre11">===</code>）表示，只有两个操作数在不转换的前提下相等才返回<code class="calibre11">true</code>，比如：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let result1 = ("55" == 55);   // true，转换后相等
let result2 = ("55" === 55);  // false，不相等，因为数据类型不同</code></pre>
            <p class="calibre1">在这个例子中，第一个比较使用相等操作符，比较的是字符串<code class="calibre11">"55"</code>和数值<code class="calibre11">55</code>。如前所述，因为字符串<code class="calibre11">"55"</code>会被转换为数值55，然后再与数值55进行比较，所以返回<code class="calibre11">true</code>。第二个比较使用全等操作符，因为没有转换，字符串和数值当然不能相等，所以返回<code class="calibre11">false</code>。</p>
            <p class="calibre1">不全等操作符用一个叹号和两个等于号（<code class="calibre11">!==</code>）表示，只有两个操作数在不转换的前提下不相等才返回<code class="calibre11">true</code>。比如：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let result1 = ("55" != 55);  // false，转换后相等
let result2 = ("55" !== 55); // true，不相等，因为数据类型不同</code></pre>
            <p class="calibre1">这一次，第一个比较使用不相等操作符，它会把字符串<code class="calibre11">"55"</code>转换为数值<code class="calibre11">55</code>，跟第二个操作数相等。既然转换后两个值相等，那就返回<code class="calibre11">false</code>。第二个比较使用不全等操作符。这时候可以这么问：“字符串55和数值55有区别吗？”答案是“有”（<code class="calibre11">true</code>）。</p>
            <p class="calibre1">另外，虽然<code class="calibre11">null == undefined</code>是<code class="calibre11">true</code>（因为这两个值类似），但<code class="calibre11">null === undefined</code>是<code class="calibre11">false</code>，因为它们不是相同的数据类型。</p>
            <blockquote class="calibre13">
              <p class="calibre1">
                <strong class="calibre2">注意</strong>
                由于相等和不相等操作符存在类型转换问题，因此推荐使用全等和不全等操作符。这样有助于在代码中保持数据类型的完整性。</p>
            </blockquote>
          </li>
        </ol>
        <h3 id="nav_point_62" class="calibre15">3.5.9 条件操作符</h3>
        <p class="calibre1">条件操作符是ECMAScript中用途最为广泛的操作符之一，语法跟Java中一样：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">variable = boolean_expression ? true_value : false_value;</code></pre>
        <p class="calibre1">上面的代码执行了条件赋值操作，即根据条件表达式<code class="calibre11">boolean_expression</code>的值决定将哪个值赋给变量<code class="calibre11">variable</code>。如果<code class="calibre11">boolean_expression</code>是<code class="calibre11">true</code>，则赋值<code class="calibre11">true_value</code>；如果<code class="calibre11">boolean_expression</code>是<code class="calibre11">false</code>，则赋值<code class="calibre11">false_value</code>。比如：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let max = (num1 &gt; num2) ? num1 : num2;</code></pre>
        <p class="calibre1">在这个例子中，<code class="calibre11">max</code>将被赋予一个最大值。这个表达式的意思是，如果<code class="calibre11">num1</code>大于<code class="calibre11">num2</code>（条件表达式为<code class="calibre11">true</code>），则将<code class="calibre11">num1</code>赋给<code class="calibre11">max</code>。否则，将<code class="calibre11">num2</code>赋给<code class="calibre11">max</code>。</p>
        <h3 id="nav_point_63" class="calibre15">3.5.10 赋值操作符</h3>
        <p class="calibre1">简单赋值用等于号（<code class="calibre11">=</code>）表示，将右手边的值赋给左手边的变量，如下所示：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let num = 10;</code></pre>
        <p class="calibre1">复合赋值使用乘性、加性或位操作符后跟等于号（<code class="calibre11">=</code>）表示。这些赋值操作符是类似如下常见赋值操作的简写形式：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let num = 10;
num = num + 10;</code></pre>
        <p class="calibre1">以上代码的第二行可以通过复合赋值来完成：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let num = 10;
num += 10;</code></pre>
        <p class="calibre1">每个数学操作符以及其他一些操作符都有对应的复合赋值操作符：</p>
        <ul class="calibre10">
          <li class="di_1ji_wu_xu_lie_biao">乘后赋值（<code class="calibre11">*=</code>）</li>
          <li class="di_1ji_wu_xu_lie_biao">除后赋值（<code class="calibre11">/=</code>）</li>
          <li class="di_1ji_wu_xu_lie_biao">取模后赋值（<code class="calibre11">%=</code>）</li>
          <li class="di_1ji_wu_xu_lie_biao">加后赋值（<code class="calibre11">+=</code>）</li>
          <li class="di_1ji_wu_xu_lie_biao">减后赋值（<code class="calibre11">-=</code>）</li>
          <li class="di_1ji_wu_xu_lie_biao">左移后赋值（<code class="calibre11">&lt;&lt;=</code>）</li>
          <li class="di_1ji_wu_xu_lie_biao">右移后赋值（<code class="calibre11">&gt;&gt;=</code>）</li>
          <li class="di_1ji_wu_xu_lie_biao">无符号右移后赋值（<code class="calibre11">&gt;&gt;&gt;=</code>）</li>
        </ul>
        <p class="calibre1">这些操作符仅仅是简写语法，使用它们不会提升性能。</p>
        <h3 id="nav_point_64" class="calibre15">3.5.11 逗号操作符</h3>
        <p class="calibre1">逗号操作符可以用来在一条语句中执行多个操作，如下所示：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let num1 = 1, num2 = 2, num3 = 3;</code></pre>
        <p class="calibre1">在一条语句中同时声明多个变量是逗号操作符最常用的场景。不过，也可以使用逗号操作符来辅助赋值。在赋值时使用逗号操作符分隔值，最终会返回表达式中最后一个值：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let num = (5, 1, 4, 8, 0); // num的值为0</code></pre>
        <p class="calibre1">在这个例子中，<code class="calibre11">num</code>将被赋值为0，因为0是表达式中最后一项。逗号操作符的这种使用场景并不多见，但这种行为的确存在。</p>

      </div>

      <div class="calibreToc">
        <h2>
          <a href="../../54m0dfqx.html">Table of contents
          </a>
        </h2>
        <div>
          <ul>
            <li>
              <a href="part0002.html#nav_point_0">版权声明</a>
            </li>
            <li>
              <a href="part0003.html#nav_point_1">献词</a>
            </li>
            <li>
              <a href="part0004.html#nav_point_2">译者序</a>
            </li>
            <li>
              <a href="part0005.html#nav_point_3">序</a>
            </li>
            <li>
              <a href="part0006.html#nav_point_4">前言</a>
            </li>
            <li>
              <a href="part0012.html#nav_point_10">致谢</a>
            </li>
            <li>
              <a href="part0013.html#nav_point_11">第 1 章 什么是JavaScript</a>
            </li>
            <li>
              <a href="part0018.html#nav_point_19">第 2 章 HTML中的JavaScript</a>
            </li>
            <li>
              <a href="part0024.html#nav_point_31">第 3 章 语言基础</a>
            </li>
            <li>
              <a href="part0033.html#nav_point_78">第 4 章 变量、作用域与内存</a>
            </li>
            <li>
              <a href="part0038.html#nav_point_93">第 5 章 基本引用类型</a>
            </li>
            <li>
              <a href="part0044.html#nav_point_111">第 6 章 集合引用类型</a>
            </li>
            <li>
              <a href="part0054.html#nav_point_153">第 7 章 迭代器与生成器</a>
            </li>
            <li>
              <a href="part0059.html#nav_point_166">第 8 章 对象、类与面向对象编程</a>
            </li>
            <li>
              <a href="part0065.html#nav_point_194">第 9 章 代理与反射</a>
            </li>
            <li>
              <a href="part0070.html#nav_point_225">第 10 章 函数</a>
            </li>
            <li>
              <a href="part0088.html#nav_point_258">第 11 章 期约与异步函数</a>
            </li>
            <li>
              <a href="part0093.html#nav_point_273">第 12 章 BOM</a>
            </li>
            <li>
              <a href="part0100.html#nav_point_294">第 13 章 客户端检测</a>
            </li>
            <li>
              <a href="part0105.html#nav_point_306">第 14 章 DOM</a>
            </li>
            <li>
              <a href="part0110.html#nav_point_328">第 15 章 DOM扩展</a>
            </li>
            <li>
              <a href="part0116.html#nav_point_348">第 16 章 DOM2和DOM3</a>
            </li>
            <li>
              <a href="part0122.html#nav_point_370">第 17 章 事件</a>
            </li>
            <li>
              <a href="part0130.html#nav_point_403">第 18 章 动画与Canvas图形</a>
            </li>
            <li>
              <a href="part0136.html#nav_point_428">第 19 章 表单脚本</a>
            </li>
            <li>
              <a href="part0143.html#nav_point_450">第 20 章 JavaScript API</a>
            </li>
            <li>
              <a href="part0157.html#nav_point_500">第 21 章 错误处理与调试</a>
            </li>
            <li>
              <a href="part0163.html#nav_point_526">第 22 章 处理XML</a>
            </li>
            <li>
              <a href="part0168.html#nav_point_542">第 23 章 JSON</a>
            </li>
            <li>
              <a href="part0172.html#nav_point_552">第 24 章 网络请求与远程资源</a>
            </li>
            <li>
              <a href="part0182.html#nav_point_582">第 25 章 客户端存储</a>
            </li>
            <li>
              <a href="part0187.html#nav_point_607">第 26 章 模块</a>
            </li>
            <li>
              <a href="part0193.html#nav_point_633">第 27 章 工作者线程</a>
            </li>
            <li>
              <a href="part0199.html#nav_point_667">第 28 章 最佳实践</a>
            </li>
            <li>
              <a href="part0204.html#nav_point_683">附录 A ES2018和ES2019</a>
            </li>
            <li>
              <a href="part0215.html#nav_point_708">附录 B 严格模式</a>
            </li>
            <li>
              <a href="part0223.html#nav_point_719">附录 C JavaScript库和框架</a>
            </li>
            <li>
              <a href="part0227.html#nav_point_741">附录 D JavaScript工具</a>
            </li>
            <li>
              <a href="part0239.html#nav_point_800">作者简介</a>
            </li>
          </ul>
        </div>

      </div>

      <div class="calibreEbNav">

        <a href="part0028.html" class="calibreAPrev">上一页
        </a>

        <a href="../../54m0dfqx.html" class="calibreAHome">首页
        </a>

        <a href="part0030.html" class="calibreANext">下一页
        </a>

      </div>

    </div>

    <script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6487844781006261" crossorigin="anonymous"></script>
  </body>
</html>