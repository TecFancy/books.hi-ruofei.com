<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>

    <title>JavaScript高级程序设计（第4版）</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" type="text/css" href="../stylesheet.css"/>
    <link rel="stylesheet" type="text/css" href="../page_styles.css"/>

    <link href="../calibreHtmlOutBasicCss.css" type="text/css" rel="stylesheet"/>

  </head>
  <body>

    <div class="calibreMeta">
      <div class="calibreMetaTitle">

        <h1>
          <a href="../../54m0dfqx.html">JavaScript高级程序设计（第4版）
          </a>
        </h1>

      </div>
      <div class="calibreMetaAuthor">
        [美] 马特 • 弗里斯比

      </div>
    </div>

    <div class="calibreMain">

      <div class="calibreEbookContent">

        <div class="calibreEbNavTop">

          <a href="part0105.html" class="calibreAPrev">上一页
          </a>

          <a href="part0107.html" class="calibreANext">下一页
          </a>

        </div>

        <h2 id="nav_point_307" class="calibre9">14.1 节点层级</h2>
        <p class="calibre1">任何HTML或XML文档都可以用DOM表示为一个由节点构成的层级结构。节点分很多类型，每种类型对应着文档中不同的信息和（或）标记，也都有自己不同的特性、数据和方法，而且与其他类型有某种关系。这些关系构成了层级，让标记可以表示为一个以特定节点为根的树形结构。以下面的HTML为例：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;sample page&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;hello world!&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
        <p class="calibre1">如果表示为层级结构，则如图14-1所示。</p>
        <p class="calibre7"><img src="../images/00049.gif" alt="" width="52%" class="calibre38"/></p>
        <p class="calibre1">
          <strong class="calibre2">图 14-1</strong>
        </p>
        <p class="calibre1">其中，<code class="calibre11">document</code>节点表示每个文档的根节点。在这里，根节点的唯一子节点是<code class="calibre11">&lt;html&gt;</code>元素，我们称之为<strong class="calibre2">文档元素</strong>（<code class="calibre11">documentElement</code>）。文档元素是文档最外层的元素，所有其他元素都存在于这个元素之内。每个文档只能有一个文档元素。在HTML页面中，文档元素始终是<code class="calibre11">&lt;html&gt;</code>元素。在XML文档中，则没有这样预定义的元素，任何元素都可能成为文档元素。</p>
        <p class="calibre1">HTML中的每段标记都可以表示为这个树形结构中的一个节点。元素节点表示HTML元素，属性节点表示属性，文档类型节点表示文档类型，注释节点表示注释。DOM中总共有12种节点类型，这些类型都继承一种基本类型。</p>
        <h3 id="nav_point_308" class="calibre15">14.1.1
          <code class="calibre26">Node</code>类型</h3>
        <p class="calibre1">DOM Level 1描述了名为<code class="calibre11">Node</code>的接口，这个接口是所有DOM节点类型都必须实现的。<code class="calibre11">Node</code>接口在JavaScript中被实现为<code class="calibre11">Node</code>类型，在除IE之外的所有浏览器中都可以直接访问这个类型。在JavaScript中，所有节点类型都继承<code class="calibre11">Node</code>类型，因此所有类型都共享相同的基本属性和方法。</p>
        <p class="calibre1">每个节点都有<code class="calibre11">nodeType</code>属性，表示该节点的类型。节点类型由定义在<code class="calibre11">Node</code>类型上的12个数值常量表示：</p>
        <ul class="calibre10">
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">Node.ELEMENT_NODE</code>（1）</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">Node.ATTRIBUTE_NODE</code>（2）</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">Node.TEXT_NODE</code>（3）</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">Node.CDATA_SECTION_NODE</code>（4）</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">Node.ENTITY_REFERENCE_NODE</code>（5）</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">Node.ENTITY_NODE</code>（6）</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">Node.PROCESSING_INSTRUCTION_NODE</code>（7）</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">Node.COMMENT_NODE</code>（8）</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">Node.DOCUMENT_NODE</code>（9）</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">Node.DOCUMENT_TYPE_NODE</code>（10）</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">Node.DOCUMENT_FRAGMENT_NODE</code>（11）</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">Node.NOTATION_NODE</code>（12）</li>
        </ul>
        <p class="calibre1">节点类型可通过与这些常量比较来确定，比如：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">if (somenode.nodetype == node.element_node){
  alert("node is an element.");
}</code></pre>
        <p class="calibre1">这个例子比较了<code class="calibre11">someNode.nodeType</code>与<code class="calibre11">Node.ELEMENT_NODE</code>常量。如果两者相等，则意味着someNode是一个元素节点。</p>
        <p class="calibre1">浏览器并不支持所有节点类型。开发者最常用到的是元素节点和文本节点。本章后面会讨论每种节点受支持的程度及其用法。</p>
        <ol class="calibre16">
          <li value="1" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">
                <code class="calibre11">nodeName</code>与<code class="calibre11">nodeValue</code>
              </strong>
            </p>
            <p class="calibre1">
              <code class="calibre11">nodeName</code>与<code class="calibre11">nodeValue</code>保存着有关节点的信息。这两个属性的值完全取决于节点类型。在使用这两个属性前，最好先检测节点类型，如下所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">if (somenode.nodetype == 1){
  value = somenode.nodename; // 会显示元素的标签名
}</code></pre>
            <p class="calibre1">在这个例子中，先检查了节点是不是元素。如果是，则将其<code class="calibre11">nodeName</code>的值赋给一个变量。对元素而言，<code class="calibre11">nodeName</code>始终等于元素的标签名，而<code class="calibre11">nodeValue</code>则始终为<code class="calibre11">null</code>。<br class="calibre4"/>
            </p>
          </li>
          <li value="2" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">节点关系</strong>
            </p>
            <p class="calibre1">文档中的所有节点都与其他节点有关系。这些关系可以形容为家族关系，相当于把文档树比作家谱。在HTML中，<code class="calibre11">&lt;body&gt;</code>元素是<code class="calibre11">&lt;html&gt;</code>元素的子元素，而<code class="calibre11">&lt;html&gt;</code>元素则是<code class="calibre11">&lt;body&gt;</code>元素的父元素。<code class="calibre11">&lt;head&gt;</code>元素是<code class="calibre11">&lt;body&gt;</code>元素的同胞元素，因为它们有共同的父元素<code class="calibre11">&lt;html&gt;</code>。</p>
            <p class="calibre1">每个节点都有一个<code class="calibre11">childNodes</code>属性，其中包含一个<code class="calibre11">NodeList</code>的实例。<code class="calibre11">NodeList</code>是一个类数组对象，用于存储可以按位置存取的有序节点。注意，<code class="calibre11">NodeList</code>并不是<code class="calibre11">Array</code>的实例，但可以使用中括号访问它的值，而且它也有<code class="calibre11">length</code>属性。<code class="calibre11">NodeList</code>对象独特的地方在于，它其实是一个对DOM结构的查询，因此DOM结构的变化会自动地在<code class="calibre11">NodeList</code>中反映出来。我们通常说<code class="calibre11">NodeList</code>是实时的活动对象，而不是第一次访问时所获得内容的快照。</p>
            <p class="calibre1">下面的例子展示了如何使用中括号或使用<code class="calibre11">item()</code>方法访问<code class="calibre11">NodeList</code>中的元素：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let firstchild = somenode.childnodes[0];
let secondchild = somenode.childnodes.item(1);
let count = somenode.childnodes.length;</code></pre>
            <p class="calibre1">无论是使用中括号还是<code class="calibre11">item()</code>方法都是可以的，但多数开发者倾向于使用中括号，因为它是一个类数组对象。注意，<code class="calibre11">length</code>属性表示那一时刻<code class="calibre11">NodeList</code>中节点的数量。使用<code class="calibre11">Array.prototype.slice()</code>可以像前面介绍<code class="calibre11">arguments</code>时一样把<code class="calibre11">NodeList</code>对象转换为数组。比如：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let arrayofnodes = array.prototype.slice.call(somenode.childnodes,0);</code></pre>
            <p class="calibre1">当然，使用ES6的<code class="calibre11">Array.from()</code>静态方法，可以替换这种笨拙的方式：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let arrayofnodes = array.from(somenode.childnodes);</code></pre>
            <p class="calibre1">每个节点都有一个<code class="calibre11">parentNode</code>属性，指向其DOM树中的父元素。<code class="calibre11">childNodes</code>中的所有节点都有同一个父元素，因此它们的<code class="calibre11">parentNode</code>属性都指向同一个节点。此外，<code class="calibre11">childNodes</code>列表中的每个节点都是同一列表中其他节点的同胞节点。而使用<code class="calibre11">previousSibling</code>和<code class="calibre11">nextSibling</code>可以在这个列表的节点间导航。这个列表中第一个节点的<code class="calibre11">previousSibling</code>属性是<code class="calibre11">null</code>，最后一个节点的<code class="calibre11">nextSibling</code>属性也是<code class="calibre11">null</code>，如下所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">if (somenode.nextsibling === null){
  alert("last node in the parent's childnodes list.");
} else if (somenode.previoussibling === null){
  alert("first node in the parent's childnodes list.");
}</code></pre>
            <p class="calibre1">注意，如果<code class="calibre11">childNodes</code>中只有一个节点，则它的<code class="calibre11">previousSibling</code>和<code class="calibre11">nextSibling</code>属性都是<code class="calibre11">null</code>。</p>
            <p class="calibre1">父节点和它的第一个及最后一个子节点也有专门属性：<code class="calibre11">firstChild</code>和<code class="calibre11">lastChild</code>分别指向<code class="calibre11">childNodes</code>中的第一个和最后一个子节点。<code class="calibre11">someNode.firstChild</code>的值始终等于<code class="calibre11">someNode.childNodes[0]</code>，而<code class="calibre11">someNode.lastChild</code>的值始终等于<code class="calibre11">someNode.childNodes[someNode.childNodes.length-1]</code>。如果只有一个子节点，则<code class="calibre11">firstChild</code>和<code class="calibre11">lastChild</code>指向同一个节点。如果没有子节点，则<code class="calibre11">firstChild</code>和<code class="calibre11">lastChild</code>都是<code class="calibre11">null</code>。上述这些节点之间的关系为在文档树的节点之间导航提供了方便。图14-2形象地展示了这些关系。</p>
            <p class="calibre1"><img src="../images/00057.gif" alt="" width="85%" class="calibre33"/></p>
            <p class="calibre1">
              <strong class="calibre2">图 14-2</strong>
            </p>
            <p class="calibre1">有了这些关系，<code class="calibre11">childNodes</code>属性的作用远远不止是必备属性那么简单了。这是因为利用这些关系指针，几乎可以访问到文档树中的任何节点，而这种便利性是<code class="calibre11">childNodes</code>的最大亮点。还有一个便利的方法是<code class="calibre11">hasChildNodes()</code>，这个方法如果返回<code class="calibre11">true</code>则说明节点有一个或多个子节点。相比查询<code class="calibre11">childNodes</code>的<code class="calibre11">length</code>属性，这个方法无疑更方便。</p>
            <p class="calibre1">最后还有一个所有节点都共享的关系。<code class="calibre11">ownerDocument</code>属性是一个指向代表整个文档的文档节点的指针。所有节点都被创建它们（或自己所在）的文档所拥有，因为一个节点不可能同时存在于两个或者多个文档中。这个属性为迅速访问文档节点提供了便利，因为无需在文档结构中逐层上溯了。</p>
            <blockquote class="calibre13">
              <p class="calibre1">
                <strong class="calibre2">注意</strong>
                虽然所有节点类型都继承了<code class="calibre11">Node</code>，但并非所有节点都有子节点。本章后面会讨论不同节点类型的差异。</p>
            </blockquote>
            <p class="calibre1"></p>
          </li>
          <li value="3" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">操纵节点</strong>
            </p>
            <p class="calibre1">因为所有关系指针都是只读的，所以DOM又提供了一些操纵节点的方法。最常用的方法是<code class="calibre11">appendChild()</code>，用于在<code class="calibre11">childNodes</code>列表末尾添加节点。添加新节点会更新相关的关系指针，包括父节点和之前的最后一个子节点。<code class="calibre11">appendChild()</code>方法返回新添加的节点，如下所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let returnednode = somenode.appendchild(newnode);
alert(returnednode == newnode);        // true
alert(somenode.lastchild == newnode);  // true</code></pre>
            <p class="calibre1">如果把文档中已经存在的节点传给<code class="calibre11">appendChild()</code>，则这个节点会从之前的位置被转移到新位置。即使DOM树通过各种关系指针维系，一个节点也不会在文档中同时出现在两个或更多个地方。因此，如果调用<code class="calibre11">appendChild()</code>传入父元素的第一个子节点，则这个节点会成为父元素的最后一个子节点，如下所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">// 假设somenode有多个子节点
let returnednode = somenode.appendchild(somenode.firstchild);
alert(returnednode == somenode.firstchild);  // false
alert(returnednode == somenode.lastchild);   // true</code></pre>
            <p class="calibre1">如果想把节点放到<code class="calibre11">childNodes</code>中的特定位置而不是末尾，则可以使用<code class="calibre11">insertBefore()</code>方法。这个方法接收两个参数：要插入的节点和参照节点。调用这个方法后，要插入的节点会变成参照节点的前一个同胞节点，并被返回。如果参照节点是<code class="calibre11">null</code>，则<code class="calibre11">insertBefore()</code>与<code class="calibre11">appendChild()</code>效果相同，如下面的例子所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">// 作为最后一个子节点插入
returnednode = somenode.insertbefore(newnode, null);
alert(newnode == somenode.lastchild);  // true

// 作为新的第一个子节点插入
returnednode = somenode.insertbefore(newnode, somenode.firstchild);
alert(returnednode == newnode);         // true
alert(newnode == somenode.firstchild);  // true

// 插入最后一个子节点前面
returnednode = somenode.insertbefore(newnode, somenode.lastchild);
alert(newnode == somenode.childnodes[somenode.childnodes.length - 2]); // true</code></pre>
            <p class="calibre1">
              <code class="calibre11">appendChild()</code>和<code class="calibre11">insertBefore()</code>在插入节点时不会删除任何已有节点。相对地，<code class="calibre11">replaceChild()</code>方法接收两个参数：要插入的节点和要替换的节点。要替换的节点会被返回并从文档树中完全移除，要插入的节点会取而代之。下面看一个例子：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">// 替换第一个子节点
let returnednode = somenode.replacechild(newnode, somenode.firstchild);

// 替换最后一个子节点
returnednode = somenode.replacechild(newnode, somenode.lastchild);</code></pre>
            <p class="calibre1">使用<code class="calibre11">replaceChild()</code>插入一个节点后，所有关系指针都会从被替换的节点复制过来。虽然被替换的节点从技术上说仍然被同一个文档所拥有，但文档中已经没有它的位置。</p>
            <p class="calibre1">要移除节点而不是替换节点，可以使用<code class="calibre11">removeChild()</code>方法。这个方法接收一个参数，即要移除的节点。被移除的节点会被返回，如下面的例子所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">// 删除第一个子节点
let formerfirstchild = somenode.removechild(somenode.firstchild);

// 删除最后一个子节点
let formerlastchild = somenode.removechild(somenode.lastchild);</code></pre>
            <p class="calibre1">与<code class="calibre11">replaceChild()</code>方法一样，通过<code class="calibre11">removeChild()</code>被移除的节点从技术上说仍然被同一个文档所拥有，但文档中已经没有它的位置。</p>
            <p class="calibre1">上面介绍的4个方法都用于操纵某个节点的子元素，也就是说使用它们之前必须先取得父节点（使用前面介绍的<code class="calibre11">parentNode</code>属性）。并非所有节点类型都有子节点，如果在不支持子节点的节点上调用这些方法，则会导致抛出错误。<br class="calibre4"/>
            </p>
          </li>
          <li value="4" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">其他方法</strong>
            </p>
            <p class="calibre1">所有节点类型还共享了两个方法。第一个是<code class="calibre11">cloneNode()</code>，会返回与调用它的节点一模一样的节点。<code class="calibre11">cloneNode()</code>方法接收一个布尔值参数，表示是否深复制。在传入<code class="calibre11">true</code>参数时，会进行深复制，即复制节点及其整个子DOM树。如果传入<code class="calibre11">false</code>，则只会复制调用该方法的节点。复制返回的节点属于文档所有，但尚未指定父节点，所以可称为孤儿节点（orphan）。可以通过<code class="calibre11">appendChild()</code>、<code class="calibre11">insertBefore()</code>或<code class="calibre11">replaceChild()</code>方法把孤儿节点添加到文档中。以下面的HTML片段为例：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">&lt;ul&gt;
  &lt;li&gt;item 1&lt;/li&gt;
  &lt;li&gt;item 2&lt;/li&gt;
  &lt;li&gt;item 3&lt;/li&gt;
&lt;/ul&gt;</code></pre>
            <p class="calibre1">如果<code class="calibre11">myList</code>保存着对这个<code class="calibre11">&lt;ul&gt;</code>元素的引用，则下列代码展示了使用<code class="calibre11">cloneNode()</code>方法的两种方式：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let deeplist = mylist.clonenode(true);
alert(deeplist.childnodes.length);    // 3（ie9之前的版本）或7（其他浏览器）

let shallowlist = mylist.clonenode(false);
alert(shallowlist.childnodes.length); // 0</code></pre>
            <p class="calibre1">在这个例子中，<code class="calibre11">deepList</code>保存着<code class="calibre11">myList</code>的副本。这意味着<code class="calibre11">deepList</code>有3个列表项，每个列表项又各自包含文本。变量<code class="calibre11">shallowList</code>则保存着<code class="calibre11">myList</code>的浅副本，因此没有子节点。<code class="calibre11">deepList.childNodes.length</code>的值会因IE8及更低版本和其他浏览器对空格的处理方式而不同。IE9之前的版本不会为空格创建节点。</p>
            <blockquote class="calibre13">
              <p class="calibre1">
                <strong class="calibre2">注意</strong>
                <code class="calibre11">cloneNode()</code>方法不会复制添加到DOM节点的JavaScript属性，比如事件处理程序。这个方法只复制HTML属性，以及可选地复制子节点。除此之外则一概不会复制。IE在很长时间内会复制事件处理程序，这是一个bug，所以推荐在复制前先删除事件处理程序。</p>
            </blockquote>
            <p class="calibre1">本节要介绍的最后一个方法是<code class="calibre11">normalize()</code>。这个方法唯一的任务就是处理文档子树中的文本节点。由于解析器实现的差异或DOM操作等原因，可能会出现并不包含文本的文本节点，或者文本节点之间互为同胞关系。在节点上调用<code class="calibre11">normalize()</code>方法会检测这个节点的所有后代，从中搜索上述两种情形。如果发现空文本节点，则将其删除；如果两个同胞节点是相邻的，则将其合并为一个文本节点。这个方法将在本章后面进一步讨论。</p>
          </li>
        </ol>
        <h3 id="nav_point_309" class="calibre15">14.1.2
          <code class="calibre26">Document</code>类型</h3>
        <p class="calibre1">
          <code class="calibre11">Document</code>类型是JavaScript中表示文档节点的类型。在浏览器中，文档对象<code class="calibre11">document</code>是<code class="calibre11">HTMLDocument</code>的实例（<code class="calibre11">HTMLDocument</code>继承<code class="calibre11">Document</code>），表示整个HTML页面。<code class="calibre11">document</code>是<code class="calibre11">window</code>对象的属性，因此是一个全局对象。<code class="calibre11">Document</code>类型的节点有以下特征：</p>
        <ul class="calibre10">
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">nodeType</code>等于9；</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">nodeName</code>值为<code class="calibre11">"#document"</code>；</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">nodeValue</code>值为<code class="calibre11">null</code>；</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">parentNode</code>值为<code class="calibre11">null</code>；</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">ownerDocument</code>值为<code class="calibre11">null</code>；</li>
          <li class="di_1ji_wu_xu_lie_biao">子节点可以是<code class="calibre11">DocumentType</code>（最多一个）、<code class="calibre11">Element</code>（最多一个）、<code class="calibre11">ProcessingInstruction</code>或<code class="calibre11">Comment</code>类型。</li>
        </ul>
        <p class="calibre1">
          <code class="calibre11">Document</code>类型可以表示HTML页面或其他XML文档，但最常用的还是通过<code class="calibre11">HTMLDocument</code>的实例取得<code class="calibre11">document</code>对象。<code class="calibre11">document</code>对象可用于获取关于页面的信息以及操纵其外观和底层结构。</p>
        <ol class="calibre16">
          <li value="1" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">文档子节点</strong>
            </p>
            <p class="calibre1">虽然DOM规范规定<code class="calibre11">Document</code>节点的子节点可以是<code class="calibre11">DocumentType</code>、<code class="calibre11">Element</code>、<code class="calibre11">ProcessingInstruction</code>或<code class="calibre11">Comment</code>，但也提供了两个访问子节点的快捷方式。第一个是<code class="calibre11">documentElement</code>属性，始终指向HTML页面中的<code class="calibre11">&lt;html&gt;</code>元素。虽然<code class="calibre11">document.childNodes</code>中始终有<code class="calibre11">&lt;html&gt;</code>元素，但使用<code class="calibre11">documentElement</code>属性可以更快更直接地访问该元素。假如有以下简单的页面：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">&lt;html&gt;
  &lt;body&gt;

  &lt;/body&gt;
&lt;/html&gt;</code></pre>
            <p class="calibre1">浏览器解析完这个页面之后，文档只有一个子节点，即<code class="calibre11">&lt;html&gt;</code>元素。这个元素既可以通过<code class="calibre11">documentElement</code>属性获取，也可以通过<code class="calibre11">childNodes</code>列表访问，如下所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let html = document.documentelement;     // 取得对&lt;html&gt;的引用
alert(html === document.childnodes[0]);  // true
alert(html === document.firstchild);     // true</code></pre>
            <p class="calibre1">这个例子表明<code class="calibre11">documentElement</code>、
              <code class="calibre11">firstChild</code>和<code class="calibre11">childNodes[0]</code>都指向同一个值，即<code class="calibre11">&lt;html&gt;</code>元素。</p>
            <p class="calibre1">作为<code class="calibre11">HTMLDocument</code>的实例，<code class="calibre11">document</code>对象还有一个<code class="calibre11">body</code>属性，直接指向<code class="calibre11">&lt;body&gt;</code>元素。因为这个元素是开发者使用最多的元素，所以JavaScript代码中经常可以看到<code class="calibre11">document.body</code>，比如：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let body = document.body; // 取得对&lt;body&gt;的引用</code></pre>
            <p class="calibre1">所有主流浏览器都支持<code class="calibre11">document.documentElement</code>和<code class="calibre11">document.body</code>。</p>
            <p class="calibre1">
              <code class="calibre11">Document</code>类型另一种可能的子节点是<code class="calibre11">DocumentType</code>。<code class="calibre11">&lt;!doctype&gt;</code>标签是文档中独立的部分，其信息可以通过<code class="calibre11">doctype</code>属性（在浏览器中是<code class="calibre11">document.doctype</code>）来访问，比如：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let doctype = document.doctype; // 取得对&lt;!doctype&gt;的引用</code></pre>
            <p class="calibre1">另外，严格来讲出现在<code class="calibre11">&lt;html&gt;</code>元素外面的注释也是文档的子节点，它们的类型是<code class="calibre11">Comment</code>。不过，由于浏览器实现不同，这些注释不一定能被识别，或者表现可能不一致。比如以下HTML页面：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">&lt;!-- 第一条注释 --&gt;
&lt;html&gt;
  &lt;body&gt;

  &lt;/body&gt;
&lt;/html&gt;
&lt;!-- 第二条注释 --&gt;</code></pre>
            <p class="calibre1">这个页面看起来有3个子节点：注释、<code class="calibre11">&lt;html&gt;</code>元素、注释。逻辑上讲，<code class="calibre11">document.childNodes</code>应该包含3项，对应代码中的每个节点。但实际上，浏览器有可能以不同方式对待<code class="calibre11">&lt;html&gt;</code>元素外部的注释，比如忽略一个或两个注释。</p>
            <p class="calibre1">一般来说，<code class="calibre11">appendChild()</code>、<code class="calibre11">removeChild()</code>和<code class="calibre11">replaceChild()</code>方法不会用在<code class="calibre11">document</code>对象上。这是因为文档类型（如果存在）是只读的，而且只能有一个<code class="calibre11">Element</code>类型的子节点（即<code class="calibre11">&lt;html&gt;</code>，已经存在了）。<span class="zhu_shi_bian_hao">1</span><br class="calibre4"/>
            </p>
          </li>
          <li value="2" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">文档信息</strong>
            </p>
            <p class="calibre1">
              <code class="calibre11">document</code>作为<code class="calibre11">HTMLDocument</code>的实例，还有一些标准<code class="calibre11">Document</code>对象上所没有的属性。这些属性提供浏览器所加载网页的信息。其中第一个属性是<code class="calibre11">title</code>，包含<code class="calibre11">&lt;title&gt;</code>元素中的文本，通常显示在浏览器窗口或标签页的标题栏。通过这个属性可以读写页面的标题，修改后的标题也会反映在浏览器标题栏上。不过，修改<code class="calibre11">title</code>属性并不会改变<code class="calibre11">&lt;title&gt;</code>元素。下面是一个例子：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">// 读取文档标题
let originaltitle = document.title;

// 修改文档标题
document.title = "new page title";</code></pre>
            <p class="calibre1">接下来要介绍的3个属性是<code class="calibre11">URL</code>、<code class="calibre11">domain</code>和<code class="calibre11">referrer</code>。其中，<code class="calibre11">URL</code>包含当前页面的完整URL（地址栏中的URL），<code class="calibre11">domain</code>包含页面的域名，而<code class="calibre11">referrer</code>包含链接到当前页面的那个页面的URL。如果当前页面没有来源，则<code class="calibre11">referrer</code>属性包含空字符串。所有这些信息都可以在请求的HTTP头部信息中获取，只是在JavaScript中通过这几个属性暴露出来而已，如下面的例子所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">// 取得完整的url
let url = document.url;

// 取得域名
let domain = document.domain;

// 取得来源
let referrer = document.referrer;</code></pre>
            <p class="calibre1">URL跟域名是相关的。比如，如果<code class="calibre11">document.URL</code>是<code class="calibre11">http://www.wrox.com/WileyCDA/</code>，则<code class="calibre11">document.domain</code>就是<code class="calibre11">www.wrox.com</code>。</p>
            <p class="calibre1">在这些属性中，只有<code class="calibre11">domain</code>属性是可以设置的。出于安全考虑，给<code class="calibre11">domain</code>属性设置的值是有限制的。如果URL包含子域名如<code class="calibre11">p2p.wrox.com</code>，则可以将<code class="calibre11">domain</code>设置为<code class="calibre11">"wrox.com"</code>（URL包含“www”时也一样，比如<code class="calibre11">www.wrox.com</code>）。不能给这个属性设置URL中不包含的值，比如：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">// 页面来自p2p.wrox.com

document.domain = "wrox.com";      // 成功

document.domain = "nczonline.net"; // 出错！</code></pre>
            <p class="calibre1">当页面中包含来自某个不同子域的窗格（<code class="calibre11">&lt;frame&gt;</code>）或内嵌窗格（<code class="calibre11">&lt;iframe&gt;</code>）时，设置<code class="calibre11">document.domain</code>是有用的。因为跨源通信存在安全隐患，所以不同子域的页面间无法通过JavaScript通信。此时，在每个页面上把<code class="calibre11">document.domain</code>设置为相同的值，这些页面就可以访问对方的JavaScript对象了。比如，一个加载自<code class="calibre11">www.wrox.com</code>的页面中包含一个内嵌窗格，其中的页面加载自<code class="calibre11">p2p.wrox.com</code>。这两个页面的<code class="calibre11">document.domain</code>包含不同的字符串，内部和外部页面相互之间不能访问对方的JavaScript对象。如果每个页面都把<code class="calibre11">document.domain</code>设置为<code class="calibre11">wrox.com</code>，那这两个页面之间就可以通信了。</p>
            <p class="calibre1">浏览器对<code class="calibre11">domain</code>属性还有一个限制，即这个属性一旦放松就不能再收紧。比如，把<code class="calibre11">document.domain</code>
              设置为<code class="calibre11">"wrox.com"</code>之后，就不能再将其设置回<code class="calibre11">"p2p.wrox.com"</code>，后者会导致错误，比如：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">// 页面来自p2p.wrox.com

document.domain = "wrox.com";     // 放松，成功

document.domain = "p2p.wrox.com"; // 收紧，错误！</code></pre>
            <p class="calibre1"></p>
          </li>
          <li value="3" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">定位元素</strong>
            </p>
            <p class="calibre1">使用DOM最常见的情形可能就是获取某个或某组元素的引用，然后对它们执行某些操作。<code class="calibre11">document</code>对象上暴露了一些方法，可以实现这些操作。<code class="calibre11">getElementById()</code>和<code class="calibre11">getElementsByTagName()</code>就是<code class="calibre11">Document</code>类型提供的两个方法。</p>
            <p class="calibre1">
              <code class="calibre11">getElementById()</code>方法接收一个参数，即要获取元素的ID，如果找到了则返回这个元素，如果没找到则返回<code class="calibre11">null</code>。参数ID必须跟元素在页面中的<code class="calibre11">id</code>属性值完全匹配，包括大小写。比如页面中有以下元素：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">&lt;div id="mydiv"&gt;some text&lt;/div&gt;</code></pre>
            <p class="calibre1">可以使用如下代码取得这个元素：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let div = document.getelementbyid("mydiv"); // 取得对这个&lt;div&gt;元素的引用</code></pre>
            <p class="calibre1">但参数大小写不匹配会返回<code class="calibre11">null</code>：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let div = document.getelementbyid("mydiv"); // null</code></pre>
            <p class="calibre1">如果页面中存在多个具有相同ID的元素，则<code class="calibre11">getElementById()</code>返回在文档中出现的第一个元素。</p>
            <p class="calibre1">
              <code class="calibre11">getElementsByTagName()</code>是另一个常用来获取元素引用的方法。这个方法接收一个参数，即要获取元素的标签名，返回包含零个或多个元素的<code class="calibre11">NodeList</code>。在HTML文档中，这个方法返回一个<code class="calibre11">HTMLCollection</code>对象。考虑到二者都是“实时”列表，<code class="calibre11">HTMLCollection</code>与<code class="calibre11">NodeList</code>是很相似的。例如，下面的代码会取得页面中所有的<code class="calibre11">&lt;img&gt;</code>元素并返回包含它们的<code class="calibre11">HTMLCollection</code>：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let images = document.getelementsbytagname("img");</code></pre>
            <p class="calibre1">这里把返回的<code class="calibre11">HTMLCollection</code>对象保存在了变量<code class="calibre11">images</code>中。与<code class="calibre11">NodeList</code>对象一样，也可以使用中括号或<code class="calibre11">item()</code>方法从<code class="calibre11">HTMLCollection</code>取得特定的元素。而取得元素的数量同样可以通过<code class="calibre11">length</code>属性得知，如下所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">alert(images.length);       // 图片数量
alert(images[0].src);       // 第一张图片的src属性
alert(images.item(0).src);  // 同上</code></pre>
            <p class="calibre1">
              <code class="calibre11">HTMLCollection</code>对象还有一个额外的方法<code class="calibre11">namedItem()</code>，可通过标签的<code class="calibre11">name</code>属性取得某一项的引用。例如，假设页面中包含如下的<code class="calibre11">&lt;img&gt;</code>元素：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">&lt;img src="myimage.gif" name="myimage"&gt;</code></pre>
            <p class="calibre1">那么也可以像这样从<code class="calibre11">images</code>中取得对这个<code class="calibre11">&lt;img&gt;</code>元素的引用：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let myimage = images.nameditem("myimage");</code></pre>
            <p class="calibre1">这样，<code class="calibre11">HTMLCollection</code>就提供了除索引之外的另一种获取列表项的方式，从而为取得元素提供了便利。对于<code class="calibre11">name</code>属性的元素，还可以直接使用中括号来获取，如下面的例子所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let myimage = images["myimage"];</code></pre>
            <p class="calibre1">对<code class="calibre11">HTMLCollection</code>对象而言，中括号既可以接收数值索引，也可以接收字符串索引。而在后台，数值索引会调用<code class="calibre11">item()</code>，字符串索引会调用<code class="calibre11">namedItem()</code>。</p>
            <p class="calibre1">要取得文档中的所有元素，可以给<code class="calibre11">getElementsByTagName()</code>传入<code class="calibre11">*</code>。在JavaScript和CSS中，<code class="calibre11">*</code>一般被认为是匹配一切的字符。来看下面的例子：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let allelements = document.getelementsbytagname("*");</code></pre>
            <p class="calibre1">这行代码可以返回包含页面中所有元素的<code class="calibre11">HTMLCollection</code>对象，顺序就是它们在页面中出现的顺序。因此第一项是<code class="calibre11">&lt;html&gt;</code>元素，第二项是<code class="calibre11">&lt;head&gt;</code>元素，以此类推。</p>
            <blockquote class="calibre13">
              <p class="calibre1">
                <strong class="calibre2">注意</strong>
                对于<code class="calibre11">document.getElementsByTagName()</code>方法，虽然规范要求区分标签的大小写，但为了最大限度兼容原有HTML页面，实际上是不区分大小写的。如果是在XML页面（如XHTML）中使用，那么<code class="calibre11">document.getElementsByTagName()</code>就是区分大小写的。</p>
            </blockquote>
            <p class="calibre1">
              <code class="calibre11">HTMLDocument</code>类型上定义的获取元素的第三个方法是<code class="calibre11">getElementsByName()</code>。顾名思义，这个方法会返回具有给定<code class="calibre11">name</code>属性的所有元素。<code class="calibre11">getElementsByName()</code>方法最常用于单选按钮，因为同一字段的单选按钮必须具有相同的<code class="calibre11">name</code>属性才能确保把正确的值发送给服务器，比如下面的例子：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">&lt;fieldset&gt;
  &lt;legend&gt;which color do you prefer?&lt;/legend&gt;
  &lt;ul&gt;
    &lt;li&gt;
      &lt;input type="radio" value="red" name="color" id="colorred"&gt;
      &lt;label for="colorred"&gt;red&lt;/label&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;input type="radio" value="green" name="color" id="colorgreen"&gt;
      &lt;label for="colorgreen"&gt;green&lt;/label&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;input type="radio" value="blue" name="color" id="colorblue"&gt;
      &lt;label for="colorblue"&gt;blue&lt;/label&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/fieldset&gt;</code></pre>
            <p class="calibre1">这里所有的单选按钮都有名为<code class="calibre11">"color"</code>的<code class="calibre11">name</code>属性，但它们的ID都不一样。这是因为ID是为了匹配对应的<code class="calibre11">&lt;label&gt;</code>元素，而<code class="calibre11">name</code>相同是为了保证只将三个中的一个值发送给服务器。然后就可以像下面这样取得所有单选按钮：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let radios = document.getelementsbyname("color");</code></pre>
            <p class="calibre1">与<code class="calibre11">getElementsByTagName()</code>一样，<code class="calibre11">getElementsByName()</code>方法也返回<code class="calibre11">HTMLCollection</code>。不过在这种情况下，<code class="calibre11">namedItem()</code>方法只会取得第一项（因为所有项的<code class="calibre11">name</code>属性都一样）。<br class="calibre4"/>
            </p>
          </li>
          <li value="4" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">特殊集合</strong>
            </p>
            <p class="calibre1">
              <code class="calibre11">document</code>对象上还暴露了几个特殊集合，这些集合也都是<code class="calibre11">HTMLCollection</code>的实例。这些集合是访问文档中公共部分的快捷方式，列举如下。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">document.anchors</code>包含文档中所有带<code class="calibre11">name</code>属性的<code class="calibre11">&lt;a&gt;</code>元素。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">document.applets</code>包含文档中所有<code class="calibre11">&lt;applet&gt;</code>元素（因为<code class="calibre11">&lt;applet&gt;</code>元素已经不建议使用，所以这个集合已经废弃）。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">document.forms</code>包含文档中所有<code class="calibre11">&lt;form&gt;</code>元素（与<code class="calibre11">document.getElementsByTagName ("form")</code>返回的结果相同）。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">document.images</code>包含文档中所有<code class="calibre11">&lt;img&gt;</code>元素（与<code class="calibre11">document.getElementsByTagName ("img")</code>返回的结果相同）。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">document.links</code>包含文档中所有带<code class="calibre11">href</code>属性的<code class="calibre11">&lt;a&gt;</code>元素。</li>
            </ul>
            <p class="calibre1">这些特殊集合始终存在于<code class="calibre11">HTMLDocument</code>对象上，而且与所有<code class="calibre11">HTMLCollection</code>对象一样，其内容也会实时更新以符合当前文档的内容。<br class="calibre4"/>
            </p>
          </li>
          <li value="5" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">DOM兼容性检测</strong>
            </p>
            <p class="calibre1">由于DOM有多个Level和多个部分，因此确定浏览器实现了DOM的哪些部分是很必要的。<code class="calibre11">document.implementation</code>属性是一个对象，其中提供了与浏览器DOM实现相关的信息和能力。DOM Level 1在<code class="calibre11">document.implementation</code>上只定义了一个方法，即<code class="calibre11">hasFeature()</code>。这个方法接收两个参数：特性名称和DOM版本。如果浏览器支持指定的特性和版本，则<code class="calibre11">hasFeature()</code>方法返回<code class="calibre11">true</code>，如下面的例子所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let hasxmldom = document.implementation.hasfeature("xml", "1.0");</code></pre>
            <p class="calibre1">可以使用<code class="calibre11">hasFeature()</code>方法测试的特性及版本如下表所列。</p>
            <table class="table" width="90%" border="1">
              <tr class="calibre18">
                <th class="calibre19">特性</th>
                <th class="calibre19">支持的版本</th>
                <th class="calibre19">说明</th>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">
                  <code class="calibre27">Core</code>
                </td>
                <td class="calibre21">1.0、2.0、3.0</td>
                <td class="calibre21">定义树形文档结构的基本DOM</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">
                  <code class="calibre27">XML</code>
                </td>
                <td class="calibre21">1.0、2.0、3.0</td>
                <td class="calibre21">
                  <code class="calibre27">Core</code>的XML扩展，增加了对CDATA区块、处理指令和实体的支持</td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">
                  <code class="calibre27">HTML</code>
                </td>
                <td class="calibre21">1.0、2.0</td>
                <td class="calibre21">
                  <code class="calibre27">XML</code>的HTML扩展，增加了HTML特定的元素和实体</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">
                  <code class="calibre27">Views</code>
                </td>
                <td class="calibre21">2.0</td>
                <td class="calibre21">文档基于某些样式的实现格式</td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">
                  <code class="calibre27">StyleSheets</code>
                </td>
                <td class="calibre21">2.0</td>
                <td class="calibre21">文档的相关样式表</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">
                  <code class="calibre27">CSS</code>
                </td>
                <td class="calibre21">2.0</td>
                <td class="calibre21">Cascading Style Sheets Level 1</td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">
                  <code class="calibre27">CSS2</code>
                </td>
                <td class="calibre21">2.0</td>
                <td class="calibre21">Cascading Style Sheets Level 2</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">
                  <code class="calibre27">Events</code>
                </td>
                <td class="calibre21">2.0、3.0</td>
                <td class="calibre21">通用DOM事件</td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">
                  <code class="calibre27">UIEvents</code>
                </td>
                <td class="calibre21">2.0、3.0</td>
                <td class="calibre21">用户界面事件</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">
                  <code class="calibre27">TextEvents</code>
                </td>
                <td class="calibre21">3.0</td>
                <td class="calibre21">文本输入设备触发的事件</td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">
                  <code class="calibre27">MouseEvents</code>
                </td>
                <td class="calibre21">2.0、3.0</td>
                <td class="calibre21">鼠标导致的事件（单击、悬停等）</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">
                  <code class="calibre27">MutationEvents</code>
                </td>
                <td class="calibre21">2.0、3.0</td>
                <td class="calibre21">DOM树变化时触发的事件</td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">
                  <code class="calibre27">MutationNameEvents</code>
                </td>
                <td class="calibre21">3.0</td>
                <td class="calibre21">DOM元素或元素属性被重命名时触发的事件</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">
                  <code class="calibre27">HTMLEvents</code>
                </td>
                <td class="calibre21">2.0</td>
                <td class="calibre21">HTML 4.01事件</td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">
                  <code class="calibre27">Range</code>
                </td>
                <td class="calibre21">2.0</td>
                <td class="calibre21">在DOM树中操作一定范围的对象和方法</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">
                  <code class="calibre27">Traversal</code>
                </td>
                <td class="calibre21">2.0</td>
                <td class="calibre21">遍历DOM树的方法</td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">
                  <code class="calibre27">LS</code>
                </td>
                <td class="calibre21">3.0</td>
                <td class="calibre21">文件与DOM树之间的同步加载与保存</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">
                  <code class="calibre27">LS-Async</code>
                </td>
                <td class="calibre21">3.0</td>
                <td class="calibre21">文件与DOM树之间的异步加载与保存</td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">
                  <code class="calibre27">Validation</code>
                </td>
                <td class="calibre21">3.0</td>
                <td class="calibre21">修改DOM树并保证其继续有效的方法</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">
                  <code class="calibre27">XPath</code>
                </td>
                <td class="calibre21">3.0</td>
                <td class="calibre21">访问XML文档不同部分的语言</td>
              </tr>
            </table>

            <p class="calibre1">由于实现不一致，因此<code class="calibre11">hasFeature()</code>的返回值并不可靠。目前这个方法已经被废弃，不再建议使用。为了向后兼容，目前主流浏览器仍然支持这个方法，但无论检测什么都一律返回<code class="calibre11">true</code>。<br class="calibre4"/>
            </p>
          </li>
          <li value="6" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">文档写入</strong>
            </p>
            <p class="calibre1">
              <code class="calibre11">document</code>对象有一个古老的能力，即向网页输出流中写入内容。这个能力对应4个方法：<code class="calibre11">write()</code>、<code class="calibre11">writeln()</code>、<code class="calibre11">open()</code>和<code class="calibre11">close()</code>。其中，<code class="calibre11">write()</code>和<code class="calibre11">writeln()</code>方法都接收一个字符串参数，可以将这个字符串写入网页中。<code class="calibre11">write()</code>简单地写入文本，而<code class="calibre11">writeln()</code>还会在字符串末尾追加一个换行符（<code class="calibre11">\n</code>）。这两个方法可以用来在页面加载期间向页面中动态添加内容，如下所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;document.write() example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;the current date and time is:
  &lt;script type="text/javascript"&gt;
    document.write("&lt;strong&gt;" + (new date()).tostring() + "&lt;/strong&gt;");
  &lt;/script&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
            <p class="calibre1">这个例子会在页面加载过程中输出当前日期和时间。日期放在了<code class="calibre11">&lt;strong&gt;</code>元素中，如同它们之前就包含在HTML页面中一样。这意味着会创建一个DOM元素，以后也可以访问。通过<code class="calibre11">write()</code>和<code class="calibre11">writeln()</code>输出的任何HTML都会以这种方式来处理。</p>
            <p class="calibre1">
              <code class="calibre11">write()</code>和<code class="calibre11">writeln()</code>方法经常用于动态包含外部资源，如JavaScript文件。在包含JavaScript文件时，记住不能像下面的例子中这样直接包含字符串<code class="calibre11">"&lt;/script&gt;"</code>，因为这个字符串会被解释为脚本块的结尾，导致后面的代码不能执行：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;document.write() example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script type="text/javascript"&gt;
    document.write("&lt;script type=\"text/javascript\" src=\"file.js\"&gt;" +
      "&lt;/script&gt;");
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
            <p class="calibre1">虽然这样写看起来没错，但输出之后的<code class="calibre11">"&lt;/script&gt;"</code>会匹配最外层的<code class="calibre11">&lt;script&gt;</code>标签，导致页面中显示出<code class="calibre11">");</code>。为避免出现这个问题，需要对前面的例子稍加修改：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;document.write() example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script type="text/javascript"&gt;
    document.write("&lt;script type=\"text/javascript\" src=\"file.js\"&gt;" +
      "&lt;\/script&gt;");
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
            <p class="calibre1">这里的字符串<code class="calibre11">"&lt;\/script&gt;"</code>不会再匹配最外层的<code class="calibre11">&lt;script&gt;</code>标签，因此不会在页面中输出额外内容。</p>
            <p class="calibre1">前面的例子展示了在页面渲染期间通过<code class="calibre11">document.write()</code>向文档中输出内容。如果是在页面加载完之后再调用<code class="calibre11">document.write()</code>，则输出的内容会重写整个页面，如下面的例子所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;document.write() example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;this is some content that you won't get to see because it will be
  overwritten.&lt;/p&gt;
  &lt;script type="text/javascript"&gt;
    window.onload = function(){
      document.write("hello world!");
    };
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p class="calibre1">这个例子使用了<code class="calibre11">window.onload</code>事件处理程序，将调用<code class="calibre11">document.write()</code>的函数推迟到页面加载完毕后执行。执行之后，字符串<code class="calibre11">"hello world!"</code>会重写整个页面内容。</p>
<p class="calibre1"><code class="calibre11">open()</code>和<code class="calibre11">close()</code>方法分别用于打开和关闭网页输出流。在调用<code class="calibre11">write()</code>和<code class="calibre11">writeln()</code>时，这两个方法都不是必需的。</p>
<blockquote class="calibre13">
<p class="calibre1"><strong class="calibre2">注意</strong>　严格的xhtml文档不支持文档写入。对于内容类型为<code class="calibre11">application</code>/<code class="calibre11">xml</code>+<code class="calibre11">xhtml</code>的页面，这些方法不起作用。</p>
</blockquote>
</li>
</ol>
<p class="zhu_shi_nei_rong"><span class="zhu_shi_bian_hao_xia">1</span>元素是<code class="calibre11">htmlhtmlelement</code>的实例，<code class="calibre11">htmlhtmlelement</code>继承<code class="calibre11">htmlelement</code>，<code class="calibre11">htmlelement</code>继承<code class="calibre11">element</code>，因此html文档可以包含子节点，但不能多于一个。——译者注</p>
<h3 id="nav_point_310" class="calibre15">14.1.3　<code class="calibre26">element</code>类型</h3>
<p class="calibre1">除了<code class="calibre11">document</code>类型，<code class="calibre11">element</code>类型就是web开发中最常用的类型了。<code class="calibre11">element</code>表示xml或html元素，对外暴露出访问元素标签名、子节点和属性的能力。<code class="calibre11">element</code>类型的节点具有以下特征：</p>
<ul class="calibre10">
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">nodetype</code>等于1；</li>
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">nodename</code>值为元素的标签名；</li>
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">nodevalue</code>值为<code class="calibre11">null</code>；</li>
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">parentnode</code>值为<code class="calibre11">document</code>或<code class="calibre11">element</code>对象；</li>
<li class="di_1ji_wu_xu_lie_biao">子节点可以是<code class="calibre11">element</code>、<code class="calibre11">text</code>、<code class="calibre11">comment</code>、<code class="calibre11">processinginstruction</code>、<code class="calibre11">cdatasection</code>、<code class="calibre11">entityreference</code>类型。</li>
</ul>
<p class="calibre1">可以通过<code class="calibre11">nodename</code>或<code class="calibre11">tagname</code>属性来获取元素的标签名。这两个属性返回同样的值（添加后一个属性明显是为了不让人误会）。比如有下面的元素：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">&lt;div id="mydiv"&gt;&lt;/div&gt;</code></pre>
<p class="calibre1">可以像这样取得这个元素的标签名：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">let div = document.getelementbyid("mydiv");
alert(div.tagname); // "div"
alert(div.tagname == div.nodename); // true</code></pre>
<p class="calibre1">例子中的元素标签名为<code class="calibre11">div</code>，id为<code class="calibre11">"mydiv"</code>。注意，<code class="calibre11">div.tagname</code>实际上返回的是<code class="calibre11">"div"</code>而不是<code class="calibre11">"div"</code>。在html中，元素标签名始终以全大写表示；在xml（包括xhtml）中，标签名始终与源代码中的大小写一致。如果不确定脚本是在html文档还是xml文档中运行，最好将标签名转换为小写形式，以便于比较：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">if (element.tagname == "div"){ // 不要这样做，可能出错！
  // do something here
}

if (element.tagname.tolowercase() == "div"){ // 推荐，适用于所有文档
  // 做点什么
}</code></pre>
<p class="calibre1">这个例子演示了比较<code class="calibre11">tagname</code>属性的情形。第一个是容易出错的写法，因为html文档中<code class="calibre11">tagname</code>返回大写形式的标签名。第二个先把标签名转换为全部小写后再比较，这是推荐的做法，因为这对html和xml都适用。</p>
<ol class="calibre16">
<li value="1" class="di_1ji_wu_xu_lie_biao"><p class="calibre1"><strong class="calibre2">html元素</strong></p>
<p class="calibre1">所有html元素都通过<code class="calibre11">htmlelement</code>类型表示，包括其直接实例和间接实例。另外，<code class="calibre11">htmlelement</code>直接继承<code class="calibre11">element</code>并增加了一些属性。每个属性都对应下列属性之一，它们是所有html元素上都有的标准属性：</p>
<ul class="calibre17">
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">id</code>，元素在文档中的唯一标识符；</li>
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">title</code>，包含元素的额外信息，通常以提示条形式展示；</li>
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">lang</code>，元素内容的语言代码（很少用）；</li>
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">dir</code>，语言的书写方向（<code class="calibre11">"ltr"</code>表示从左到右，<code class="calibre11">"rtl"</code>表示从右到左，同样很少用）；</li>
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">classname</code>，相当于<code class="calibre11">class</code>属性，用于指定元素的css类（因为<code class="calibre11">class</code>是ecmascript关键字，所以不能直接用这个名字）。</li>
</ul>
<p class="calibre1">所有这些都可以用来获取对应的属性值，也可以用来修改相应的值。比如有下面的html元素：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">&lt;div id="mydiv" class="bd" title="body text" lang="en" dir="ltr"&gt;&lt;/div&gt;</code></pre>
<p class="calibre1">这个元素中的所有属性都可以使用下列javascript代码读取：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">let div = document.getelementbyid("mydiv");
alert(div.id);         // "mydiv"
alert(div.classname);  // "bd"
alert(div.title);      // "body text"
alert(div.lang);       // "en"
alert(div.dir);        // "ltr"</code></pre>
<p class="calibre1">而且，可以使用下列代码修改元素的属性：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">div.id = "someotherid";
div.classname = "ft";
div.title = "some other text";
div.lang = "fr";
div.dir ="rtl";</code></pre>
<p class="calibre1">并非所有这些属性的修改都会对页面产生影响。比如，把<code class="calibre11">id</code>或<code class="calibre11">lang</code>改成其他值对用户是不可见的（假设没有基于这两个属性应用css样式），而修改<code class="calibre11">title</code>属性则只会在鼠标移到这个元素上时才会反映出来。修改<code class="calibre11">dir</code>会导致页面文本立即向左或向右对齐。修改<code class="calibre11">classname</code>会立即反映应用到新类名的css样式（如果定义了不同的样式）。</p>
<p class="calibre1">如前所述，所有html元素都是<code class="calibre11">htmlelement</code>或其子类型的实例。下表列出了所有html元素及其对应的类型（斜体表示已经废弃的元素）。</p>
<table class="table" width="90%" border="1"><tr class="calibre18"><th class="calibre19">元素</th><th class="calibre19">类型</th><th class="calibre19">元素</th><th class="calibre19">类型</th></tr><tr class="calibre20"><td class="calibre21">a</td><td class="calibre21"><code class="calibre27">htmlanchorelement</code></td><td class="calibre21">col</td><td class="calibre21"><code class="calibre27">htmltablecolelement</code></td></tr><tr class="calibre18"><td class="calibre21">abbr</td><td class="calibre21"><code class="calibre27">htmlelement</code></td><td class="calibre21">colgroup</td><td class="calibre21"><code class="calibre27">htmltablecolelement</code></td></tr><tr class="calibre20"><td class="calibre21">acronym</td><td class="calibre21"><code class="calibre27">htmlelement</code></td><td class="calibre21">dd</td><td class="calibre21"><code class="calibre27">htmlelement</code></td></tr><tr class="calibre18"><td class="calibre21">address</td><td class="calibre21"><code class="calibre27">htmlelement</code></td><td class="calibre21">del</td><td class="calibre21"><code class="calibre27">htmlmodelement</code></td></tr><tr class="calibre20"><td class="calibre21"><i class="calibre6">applet</i></td><td class="calibre21"><code class="calibre27"><i class="calibre6">htmlappletelement</i></code></td><td class="calibre21">dfn</td><td class="calibre21"><code class="calibre27">htmlelement</code></td></tr><tr class="calibre18"><td class="calibre21">area</td><td class="calibre21"><code class="calibre27">htmlareaelement</code></td><td class="calibre21"><i class="calibre6">dir</i></td><td class="calibre21"><code class="calibre27"><i class="calibre6">htmldirectoryelement</i></code></td></tr><tr class="calibre20"><td class="calibre21">b</td><td class="calibre21"><code class="calibre27">htmlelement</code></td><td class="calibre21">div</td><td class="calibre21"><code class="calibre27">htmldivelement</code></td></tr><tr class="calibre18"><td class="calibre21">base</td><td class="calibre21"><code class="calibre27">htmlbaseelement</code></td><td class="calibre21">dl</td><td class="calibre21"><code class="calibre27">htmldlistelement</code></td></tr><tr class="calibre20"><td class="calibre21"><i class="calibre6">basefont</i></td><td class="calibre21"><code class="calibre27"><i class="calibre6">htmlbasefontelement</i></code></td><td class="calibre21">dt</td><td class="calibre21"><code class="calibre27">htmlelement</code></td></tr><tr class="calibre18"><td class="calibre21">bdo</td><td class="calibre21"><code class="calibre27">htmlelement</code></td><td class="calibre21">em</td><td class="calibre21"><code class="calibre27">htmlelement</code></td></tr><tr class="calibre20"><td class="calibre21">big</td><td class="calibre21"><code class="calibre27">htmlelement</code></td><td class="calibre21">fieldset</td><td class="calibre21"><code class="calibre27">htmlfieldsetelement</code></td></tr><tr class="calibre18"><td class="calibre21">blockquote</td><td class="calibre21"><code class="calibre27">htmlquoteelement</code></td><td class="calibre21"><i class="calibre6">font</i></td><td class="calibre21"><code class="calibre27"><i class="calibre6">htmlfontelement</i></code></td></tr><tr class="calibre20"><td class="calibre21">body</td><td class="calibre21"><code class="calibre27">htmlbodyelement</code></td><td class="calibre21">form</td><td class="calibre21"><code class="calibre27">htmlformelement</code></td></tr><tr class="calibre18"><td class="calibre21">br</td><td class="calibre21"><code class="calibre27">htmlbrelement</code></td><td class="calibre21">frame</td><td class="calibre21"><code class="calibre27">htmlframeelement</code></td></tr><tr class="calibre20"><td class="calibre21">button</td><td class="calibre21"><code class="calibre27">htmlbuttonelement</code></td><td class="calibre21">frameset</td><td class="calibre21"><code class="calibre27">htmlframesetelement</code></td></tr><tr class="calibre18"><td class="calibre21">caption</td><td class="calibre21"><code class="calibre27">htmltablecaptionelement</code></td><td class="calibre21">h1</td><td class="calibre21"><code class="calibre27">htmlheadingelement</code></td></tr><tr class="calibre20"><td class="calibre21"><i class="calibre6">center</i></td><td class="calibre21"><code class="calibre27"><i class="calibre6">htmlelement</i></code></td><td class="calibre21">h2</td><td class="calibre21"><code class="calibre27">htmlheadingelement</code></td></tr><tr class="calibre18"><td class="calibre21">cite</td><td class="calibre21"><code class="calibre27">htmlelement</code></td><td class="calibre21">h3</td><td class="calibre21"><code class="calibre27">htmlheadingelement</code></td></tr><tr class="calibre20"><td class="calibre21">code</td><td class="calibre21"><code class="calibre27">htmlelement</code></td><td class="calibre21">h4</td><td class="calibre21"><code class="calibre27">htmlheadingelement</code></td></tr><tr class="calibre18"><td class="calibre21">h5</td><td class="calibre21"><code class="calibre27">htmlheadingelement</code></td><td class="calibre21">pre</td><td class="calibre21"><code class="calibre27">htmlpreelement</code></td></tr><tr class="calibre20"><td class="calibre21">h6</td><td class="calibre21"><code class="calibre27">htmlheadingelement</code></td><td class="calibre21">q</td><td class="calibre21"><code class="calibre27">htmlquoteelement</code></td></tr><tr class="calibre18"><td class="calibre21">head</td><td class="calibre21"><code class="calibre27">htmlheadelement</code></td><td class="calibre21"><i class="calibre6">s</i></td><td class="calibre21"><code class="calibre27"><i class="calibre6">htmlelement</i></code></td></tr><tr class="calibre20"><td class="calibre21">hr</td><td class="calibre21"><code class="calibre27">htmlhrelement</code></td><td class="calibre21">samp</td><td class="calibre21"><code class="calibre27">htmlelement</code></td></tr><tr class="calibre18"><td class="calibre21">html</td><td class="calibre21"><code class="calibre27">htmlhtmlelement</code></td><td class="calibre21">script</td><td class="calibre21"><code class="calibre27">htmlscriptelement</code></td></tr><tr class="calibre20"><td class="calibre21">i</td><td class="calibre21"><code class="calibre27">htmlelement</code></td><td class="calibre21">select</td><td class="calibre21"><code class="calibre27">htmlselectelement</code></td></tr><tr class="calibre18"><td class="calibre21">iframe</td><td class="calibre21"><code class="calibre27">htmliframeelement</code></td><td class="calibre21">small</td><td class="calibre21"><code class="calibre27">htmlelement</code></td></tr><tr class="calibre20"><td class="calibre21">img</td><td class="calibre21"><code class="calibre27">htmlimageelement</code></td><td class="calibre21">span</td><td class="calibre21"><code class="calibre27">htmlelement</code></td></tr><tr class="calibre18"><td class="calibre21">input</td><td class="calibre21"><code class="calibre27">htmlinputelement</code></td><td class="calibre21"><i class="calibre6">strike</i></td><td class="calibre21"><code class="calibre27"><i class="calibre6">htmlelement</i></code></td></tr><tr class="calibre20"><td class="calibre21">ins</td><td class="calibre21"><code class="calibre27">htmlmodelement</code></td><td class="calibre21">strong</td><td class="calibre21"><code class="calibre27">htmlelement</code></td></tr><tr class="calibre18"><td class="calibre21"><i class="calibre6">isindex</i></td><td class="calibre21"><code class="calibre27"><i class="calibre6">htmlisindexelement</i></code></td><td class="calibre21">style</td><td class="calibre21"><code class="calibre27">htmlstyleelement</code></td></tr><tr class="calibre20"><td class="calibre21">kbd</td><td class="calibre21"><code class="calibre27">htmlelement</code></td><td class="calibre21">sub</td><td class="calibre21"><code class="calibre27">htmlelement</code></td></tr><tr class="calibre18"><td class="calibre21">label</td><td class="calibre21"><code class="calibre27">htmllabelelement</code></td><td class="calibre21">sup</td><td class="calibre21"><code class="calibre27">htmlelement</code></td></tr><tr class="calibre20"><td class="calibre21">legend</td><td class="calibre21"><code class="calibre27">htmllegendelement</code></td><td class="calibre21">table</td><td class="calibre21"><code class="calibre27">htmltableelement</code></td></tr><tr class="calibre18"><td class="calibre21">li</td><td class="calibre21"><code class="calibre27">htmllielement</code></td><td class="calibre21">tbody</td><td class="calibre21"><code class="calibre27">htmltablesectionelement</code></td></tr><tr class="calibre20"><td class="calibre21">link</td><td class="calibre21"><code class="calibre27">htmllinkelement</code></td><td class="calibre21">td</td><td class="calibre21"><code class="calibre27">htmltablecellelement</code></td></tr><tr class="calibre18"><td class="calibre21">map</td><td class="calibre21"><code class="calibre27">htmlmapelement</code></td><td class="calibre21">textarea</td><td class="calibre21"><code class="calibre27">htmltextareaelement</code></td></tr><tr class="calibre20"><td class="calibre21"><i class="calibre6">menu</i></td><td class="calibre21"><code class="calibre27"><i class="calibre6">htmlmenuelement</i></code></td><td class="calibre21">tfoot</td><td class="calibre21"><code class="calibre27">htmltablesectionelement</code></td></tr><tr class="calibre18"><td class="calibre21">meta</td><td class="calibre21"><code class="calibre27">htmlmetaelement</code></td><td class="calibre21">th</td><td class="calibre21"><code class="calibre27">htmltablecellelement</code></td></tr><tr class="calibre20"><td class="calibre21">noframes</td><td class="calibre21"><code class="calibre27">htmlelement</code></td><td class="calibre21">thead</td><td class="calibre21"><code class="calibre27">htmltablesectionelement</code></td></tr><tr class="calibre18"><td class="calibre21">noscript</td><td class="calibre21"><code class="calibre27">htmlelement</code></td><td class="calibre21">title</td><td class="calibre21"><code class="calibre27">htmltitleelement</code></td></tr><tr class="calibre20"><td class="calibre21">object</td><td class="calibre21"><code class="calibre27">htmlobjectelement</code></td><td class="calibre21">tr</td><td class="calibre21"><code class="calibre27">htmltablerowelement</code></td></tr><tr class="calibre18"><td class="calibre21">ol</td><td class="calibre21"><code class="calibre27">htmlolistelement</code></td><td class="calibre21">tt</td><td class="calibre21"><code class="calibre27">htmlelement</code></td></tr><tr class="calibre20"><td class="calibre21">optgroup</td><td class="calibre21"><code class="calibre27">htmloptgroupelement</code></td><td class="calibre21"><i class="calibre6">u</i></td><td class="calibre21"><code class="calibre27"><i class="calibre6">htmlelement</i></code></td></tr><tr class="calibre18"><td class="calibre21">option</td><td class="calibre21"><code class="calibre27">htmloptionelement</code></td><td class="calibre21">ul</td><td class="calibre21"><code class="calibre27">htmlulistelement</code></td></tr><tr class="calibre20"><td class="calibre21">p</td><td class="calibre21"><code class="calibre27">htmlparagraphelement</code></td><td class="calibre21">var</td><td class="calibre21"><code class="calibre27">htmlelement</code></td></tr><tr class="calibre18"><td class="calibre21">param</td><td class="calibre21"><code class="calibre27">htmlparamelement</code></td><td class="calibre21"/><td class="calibre21"/></tr></table>

<p class="calibre1">这里列出的每种类型都有关联的属性和方法。本书会涉及其中的很多类型。<br class="calibre4"/> </p>
</li>
<li value="2" class="di_1ji_wu_xu_lie_biao"><p class="calibre1"><strong class="calibre2">取得属性</strong></p>
<p class="calibre1">每个元素都有零个或多个属性，通常用于为元素或其内容附加更多信息。与属性相关的dom方法主要有3个：<code class="calibre11">getattribute()</code>、<code class="calibre11">setattribute()</code>和<code class="calibre11">removeattribute()</code>。这些方法主要用于操纵属性，包括在<code class="calibre11">htmlelement</code>类型上定义的属性。下面看一个例子：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">let div = document.getelementbyid("mydiv");
alert(div.getattribute("id"));     // "mydiv"
alert(div.getattribute("class"));  // "bd"
alert(div.getattribute("title"));  // "body text"
alert(div.getattribute("lang"));   // "en"
alert(div.getattribute("dir"));    // "ltr"</code></pre>
<p class="calibre1">注意传给<code class="calibre11">getattribute()</code>的属性名与它们实际的属性名是一样的，因此这里要传<code class="calibre11">"class"</code>而非<code class="calibre11">"classname"</code>（<code class="calibre11">classname</code>是作为对象属性时才那么拼写的）。如果给定的属性不存在，则<code class="calibre11">getattribute()</code>返回<code class="calibre11">null</code>。</p>
<p class="calibre1"><code class="calibre11">getattribute()</code>方法也能取得不是html语言正式属性的自定义属性的值。比如下面的元素：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">&lt;div id="mydiv" my_special_attribute="hello!"&gt;&lt;/div&gt;</code></pre>
<p class="calibre1">这个元素有一个自定义属性<code class="calibre11">my_special_attribute</code>，值为<code class="calibre11">"hello!"</code>。可以像其他属性一样使用<code class="calibre11">getattribute()</code>取得这个属性的值：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">let value = div.getattribute("my_special_attribute");</code></pre>
<p class="calibre1">注意，属性名不区分大小写，因此<code class="calibre11">"id"</code>和<code class="calibre11">"id"</code>被认为是同一个属性。另外，根据html5规范的要求，自定义属性名应该前缀<code class="calibre11">data-</code>以方便验证。</p>
<p class="calibre1">元素的所有属性也可以通过相应dom元素对象的属性来取得。当然，这包括<code class="calibre11">htmlelement</code>上定义的直接映射对应属性的5个属性，还有所有公认（非自定义）的属性也会被添加为dom对象的属性。比如下面的例子：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">&lt;div id="mydiv" align="left" my_special_attribute="hello"&gt;&lt;/div&gt;</code></pre>
<p class="calibre1">因为<code class="calibre11">id</code>和<code class="calibre11">align</code>在html中是<code class="calibre11">&lt;div&gt;</code>元素公认的属性，所以dom对象上也会有这两个属性。但<code class="calibre11">my_special_attribute</code>是自定义属性，因此不会成为dom对象的属性。</p>
<p class="calibre1">通过dom对象访问的属性中有两个返回的值跟使用<code class="calibre11">getattribute</code>()取得的值不一样。首先是<code class="calibre11">style</code>属性，这个属性用于为元素设定css样式。在使用<code class="calibre11">getattribute()</code>访问style属性时，返回的是css字符串。而在通过dom对象的属性访问时，<code class="calibre11">style</code>属性返回的是一个（<code class="calibre11">cssstyledeclaration</code>）对象。dom对象的<code class="calibre11">style</code>属性用于以编程方式读写元素样式，因此不会直接映射为元素中<code class="calibre11">style</code>属性的字符串值。</p>
<p class="calibre1">第二个属性其实是一类，即事件处理程序（或者事件属性），比如<code class="calibre11">onclick</code>。在元素上使用事件属性时（比如<code class="calibre11">onclick</code>），属性的值是一段javascript代码。如果使用<code class="calibre11">getattribute()</code>访问事件属性，则返回的是字符串形式的源代码。而通过dom对象的属性访问事件属性时返回的则是一个javascript函数（未指定该属性则返回<code class="calibre11">null</code>）。这是因为<code class="calibre11">onclick</code>及其他事件属性是可以接受函数作为值的。</p>
<p class="calibre1">考虑到以上差异，开发者在进行dom编程时通常会放弃使用<code class="calibre11">getattribute()</code>而只使用对象属性。<code class="calibre11">getattribute()</code>主要用于取得自定义属性的值。<br class="calibre4"/> </p>
</li>
<li value="3" class="di_1ji_wu_xu_lie_biao"><p class="calibre1"><strong class="calibre2">设置属性</strong></p>
<p class="calibre1">与<code class="calibre11">getattribute()</code>配套的方法是<code class="calibre11">setattribute()</code>，这个方法接收两个参数：要设置的属性名和属性的值。如果属性已经存在，则<code class="calibre11">setattribute()</code>会以指定的值替换原来的值；如果属性不存在，则<code class="calibre11">setattribute()</code>会以指定的值创建该属性。下面看一个例子：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">div.setattribute("id", "someotherid");
div.setattribute("class", "ft");
div.setattribute("title", "some other text");
div.setattribute("lang","fr");
div.setattribute("dir", "rtl");</code></pre>
<p class="calibre1"><code class="calibre11">setattribute()</code>适用于html属性，也适用于自定义属性。另外，使用<code class="calibre11">setattribute()</code>方法设置的属性名会规范为小写形式，因此<code class="calibre11">"id"</code>会变成<code class="calibre11">"id"</code>。</p>
<p class="calibre1">因为元素属性也是dom对象属性，所以直接给dom对象的属性赋值也可以设置元素属性的值，如下所示：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">div.id = "someotherid";
div.align = "left";</code></pre>
<p class="calibre1">注意，在dom对象上添加自定义属性，如下面的例子所示，不会自动让它变成元素的属性：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">div.mycolor = "red";
alert(div.getattribute("mycolor")); // null（ie除外）</code></pre>
<p class="calibre1">这个例子添加了一个自定义属性<code class="calibre11">mycolor</code>并将其值设置为<code class="calibre11">"red"</code>。在多数浏览器中，这个属性不会自动变成元素属性。因此调用<code class="calibre11">getattribute()</code>取得<code class="calibre11">mycolor</code>的值会返回<code class="calibre11">null</code>。</p>
<p class="calibre1">最后一个方法<code class="calibre11">removeattribute()</code>用于从元素中删除属性。这样不单单是清除属性的值，而是会把整个属性完全从元素中去掉，如下所示：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">div.removeattribute("class");</code></pre>
<p class="calibre1">这个方法用得并不多，但在序列化dom元素时可以通过它控制要包含的属性。<br class="calibre4"/> </p>
</li>
<li value="4" class="di_1ji_wu_xu_lie_biao"><p class="calibre1"><strong class="calibre2"><code class="calibre11">attributes</code> 属性</strong></p>
<p class="calibre1"><code class="calibre11">element</code>类型是唯一使用<code class="calibre11">attributes</code>属性的dom节点类型。<code class="calibre11">attributes</code>属性包含一个<code class="calibre11">namednodemap</code>实例，是一个类似<code class="calibre11">nodelist</code>的“实时”集合。元素的每个属性都表示为一个<code class="calibre11">attr</code>节点，并保存在这个<code class="calibre11">namednodemap</code>对象中。<code class="calibre11">namednodemap</code>对象包含下列方法：</p>
<ul class="calibre17">
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">getnameditem(<i class="calibre6">name</i>)</code>，返回<code class="calibre11">nodename</code>属性等于<code class="calibre11"><i class="calibre6">name</i></code>的节点；</li>
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">removenameditem(<i class="calibre6">name</i>)</code>，删除<code class="calibre11">nodename</code>属性等于<code class="calibre11"><i class="calibre6">name</i></code>的节点；</li>
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">setnameditem(<i class="calibre6">node</i>)</code>，向列表中添加<code class="calibre11"><i class="calibre6">node</i></code>节点，以其<code class="calibre11">nodename</code>为索引；</li>
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">item(<i class="calibre6">pos</i>)</code>，返回索引位置<code class="calibre11"><i class="calibre6">pos</i></code>处的节点。</li>
</ul>
<p class="calibre1"><code class="calibre11">attributes</code>属性中的每个节点的<code class="calibre11">nodename</code>是对应属性的名字，<code class="calibre11">nodevalue</code>是属性的值。比如，要取得元素<code class="calibre11">id</code>属性的值，可以使用以下代码：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">let id = element.attributes.getnameditem("id").nodevalue;</code></pre>
<p class="calibre1">下面是使用中括号访问属性的简写形式：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">let id = element.attributes["id"].nodevalue;</code></pre>
<p class="calibre1">同样，也可以用这种语法设置属性的值，即先取得属性节点，再将其<code class="calibre11">nodevalue</code>设置为新值，如下所示：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">element.attributes["id"].nodevalue = "someotherid";</code></pre>
<p class="calibre1"><code class="calibre11">removenameditem()</code>方法与元素上的<code class="calibre11">removeattribute()</code>方法类似，也是删除指定名字的属性。下面的例子展示了这两个方法唯一的不同之处，就是<code class="calibre11">removenameditem()</code>返回表示被删除属性的<code class="calibre11">attr</code>节点：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">let oldattr = element.attributes.removenameditem("id");</code></pre>
<p class="calibre1"><code class="calibre11">setnameditem()</code>方法很少使用，它接收一个属性节点，然后给元素添加一个新属性，如下所示：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">element.attributes.setnameditem(newattr);</code></pre>
<p class="calibre1">一般来说，因为使用起来更简便，通常开发者更喜欢使用<code class="calibre11">getattribute()</code>、<code class="calibre11">removeattribute()</code>和<code class="calibre11">setattribute()</code>方法，而不是刚刚介绍的<code class="calibre11">namednodemap</code>对象的方法。</p>
<p class="calibre1"><code class="calibre11">attributes</code>属性最有用的场景是需要迭代元素上所有属性的时候。这时候往往是要把dom结构序列化为xml或html字符串。比如，以下代码能够迭代一个元素上的所有属性并以<code class="calibre11">attribute1= "value1" attribute2="value2"</code>的形式生成格式化字符串：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">function outputattributes(element) {
  let pairs = [];

  for (let i = 0, len = element.attributes.length; i &lt; len; ++i) {
    const attribute = element.attributes[i];
    pairs.push(`${attribute.nodename}="${attribute.nodevalue}"`);
  }

  return pairs.join(" ");
}</code></pre>
<p class="calibre1">这个函数使用数组存储每个名/值对，迭代完所有属性后，再将这些名/值对用空格拼接在一起。（这个技术常用于序列化为长字符串。）这个函数中的<code class="calibre11">for</code>循环使用<code class="calibre11">attributes.length</code>属性迭代每个属性，将每个属性的名字和值输出为字符串。不同浏览器返回的<code class="calibre11">attributes</code>中的属性顺序也可能不一样。html或xml代码中属性出现的顺序不一定与<code class="calibre11">attributes</code>中的顺序一致。<br class="calibre4"/> </p>
</li>
<li value="5" class="di_1ji_wu_xu_lie_biao"><p class="calibre1"><strong class="calibre2">创建元素</strong></p>
<p class="calibre1">可以使用<code class="calibre11">document.createelement()</code>方法创建新元素。这个方法接收一个参数，即要创建元素的标签名。在html文档中，标签名是不区分大小写的，而xml文档（包括xhtml）是区分大小写的。要创建<code class="calibre11">&lt;div&gt;</code>元素，可以使用下面的代码：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">let div = document.createelement("div");</code></pre>
<p class="calibre1">使用<code class="calibre11">createelement()</code>方法创建新元素的同时也会将其<code class="calibre11">ownerdocument</code>属性设置为<code class="calibre11">document</code>。此时，可以再为其添加属性、添加更多子元素。比如：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">div.id = "mynewdiv";
div.classname = "box";</code></pre>
<p class="calibre1">在新元素上设置这些属性只会附加信息。因为这个元素还没有添加到文档树，所以不会影响浏览器显示。要把元素添加到文档树，可以使用<code class="calibre11">appendchild()</code>、<code class="calibre11">insertbefore()</code>或<code class="calibre11">replacechild()</code>。比如，以下代码会把刚才创建的元素添加到文档的<code class="calibre11">&lt;body&gt;</code>元素中：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">document.body.appendchild(div);</code></pre>
<p class="calibre1">元素被添加到文档树之后，浏览器会立即将其渲染出来。之后再对这个元素所做的任何修改，都会立即在浏览器中反映出来。<br class="calibre4"/> </p>
</li>
<li value="6" class="di_1ji_wu_xu_lie_biao"><p class="calibre1"><strong class="calibre2">元素后代</strong></p>
<p class="calibre1">元素可以拥有任意多个子元素和后代元素，因为元素本身也可以是其他元素的子元素。<code class="calibre11">childnodes</code>属性包含元素所有的子节点，这些子节点可能是其他元素、文本节点、注释或处理指令。不同浏览器在识别这些节点时的表现有明显不同。比如下面的代码：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">&lt;ul id="mylist"&gt;
  &lt;li&gt;item 1&lt;/li&gt;
  &lt;li&gt;item 2&lt;/li&gt;
  &lt;li&gt;item 3&lt;/li&gt;
&lt;/ul&gt;</code></pre>
<p class="calibre1">在解析以上代码时，<code class="calibre11">&lt;ul&gt;</code>元素会包含7个子元素，其中3个是<code class="calibre11">&lt;li&gt;</code>元素，还有4个<code class="calibre11">text</code>节点（表示<code class="calibre11">&lt;li&gt;</code>元素周围的空格）。如果把元素之间的空格删掉，变成下面这样，则所有浏览器都会返回同样数量的子节点：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">&lt;ul id="mylist"&gt;&lt;li&gt;item 1&lt;/li&gt;&lt;li&gt;item 2&lt;/li&gt;&lt;li&gt;item 3&lt;/li&gt;&lt;/ul&gt;</code></pre>
<p class="calibre1">所有浏览器解析上面的代码后，<code class="calibre11">&lt;ul&gt;</code>元素都会包含3个子节点。考虑到这种情况，通常在执行某个操作之后需要先检测一下节点的<code class="calibre11">nodetype</code>，如下所示：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">for (let i = 0, len = element.childnodes.length; i &lt; len; ++i) {
  if (element.childnodes[i].nodetype == 1) {
    // 执行某个操作
  }
}</code></pre>
<p class="calibre1">以上代码会遍历某个元素的子节点，并且只在<code class="calibre11">nodetype</code>等于1（即<code class="calibre11">element</code>节点）时执行某个操作。</p>
<p class="calibre1">要取得某个元素的子节点和其他后代节点，可以使用元素的<code class="calibre11">getelementsbytagname()</code>方法。在元素上调用这个方法与在文档上调用是一样的，只不过搜索范围限制在当前元素之内，即只会返回当前元素的后代。对于本节前面<code class="calibre11">&lt;ul&gt;</code>的例子，可以像下面这样取得其所有的<code class="calibre11">&lt;li&gt;</code>元素：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">let ul = document.getelementbyid("mylist");
let items = ul.getelementsbytagname("li");</code></pre>
<p class="calibre1">这里例子中的<code class="calibre11">&lt;ul&gt;</code>元素只有一级子节点，如果它包含更多层级，则所有层级中的<code class="calibre11">&lt;li&gt;</code>元素都会返回。</p>
</li>
</ol>
<h3 id="nav_point_311" class="calibre15">14.1.4　<code class="calibre26">text</code>类型</h3>
<p class="calibre1"><code class="calibre11">text</code>节点由<code class="calibre11">text</code>类型表示，包含按字面解释的纯文本，也可能包含转义后的html字符，但不含html代码。<code class="calibre11">text</code>类型的节点具有以下特征：</p>
<ul class="calibre10">
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">nodetype</code>等于3；</li>
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">nodename</code>值为<code class="calibre11">"#text"</code>；</li>
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">nodevalue</code>值为节点中包含的文本；</li>
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">parentnode</code>值为<code class="calibre11">element</code>对象；</li>
<li class="di_1ji_wu_xu_lie_biao">不支持子节点。</li>
</ul>
<p class="calibre1"><code class="calibre11">text</code>节点中包含的文本可以通过<code class="calibre11">nodevalue</code>属性访问，也可以通过<code class="calibre11">data</code>属性访问，这两个属性包含相同的值。修改<code class="calibre11">nodevalue</code>或<code class="calibre11">data</code>的值，也会在另一个属性反映出来。文本节点暴露了以下操作文本的方法：</p>
<ul class="calibre10">
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">appenddata(<i class="calibre6">text</i>)</code>，向节点末尾添加文本<code class="calibre11"><i class="calibre6">text</i></code>；</li>
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">deletedata(<i class="calibre6">offset, count</i>)</code>，从位置<code class="calibre11"><i class="calibre6">offset</i></code>开始删除<code class="calibre11"><i class="calibre6">count</i></code>个字符；</li>
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">insertdata(<i class="calibre6">offset, text</i>)</code>，在位置<code class="calibre11"><i class="calibre6">offset</i></code>插入<code class="calibre11"><i class="calibre6">text</i></code>；</li>
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">replacedata(<i class="calibre6">offset, count, text</i>)</code>，用<code class="calibre11"><i class="calibre6">text</i></code>替换从位置<code class="calibre11"><i class="calibre6">offset</i></code>到<code class="calibre11"><i class="calibre6">offset</i> + <i class="calibre6">count</i></code>的文本；</li>
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">splittext(<i class="calibre6">offset</i>)</code>，在位置<code class="calibre11"><i class="calibre6">offset</i></code>将当前文本节点拆分为两个文本节点；</li>
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">substringdata(<i class="calibre6">offset, count</i>)</code>，提取从位置<code class="calibre11"><i class="calibre6">offset</i></code>到<code class="calibre11"><i class="calibre6">offset</i> + <i class="calibre6">count</i></code>的文本。</li>
</ul>
<p class="calibre1">除了这些方法，还可以通过<code class="calibre11">length</code>属性获取文本节点中包含的字符数量。这个值等于<code class="calibre11">nodevalue.length</code>和<code class="calibre11">data.length</code>。</p>
<p class="calibre1">默认情况下，包含文本内容的每个元素最多只能有一个文本节点。例如：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">&lt;!-- 没有内容，因此没有文本节点 --&gt;
&lt;div&gt;&lt;/div&gt;

&lt;!-- 有空格，因此有一个文本节点 --&gt;
&lt;div&gt; &lt;/div&gt;

&lt;!-- 有内容，因此有一个文本节点 --&gt;
&lt;div&gt;hello world!&lt;/div&gt;</code></pre>
<p class="calibre1">示例中的第一个<code class="calibre11">&lt;div&gt;</code>元素中不包含内容，因此不会产生文本节点。只要开始标签和结束标签之间有内容，就会创建一个文本节点，因此第二个<code class="calibre11">&lt;div&gt;</code>元素会有一个文本节点的子节点，虽然它只包含空格。这个文本节点的<code class="calibre11">nodevalue</code>就是一个空格。第三个<code class="calibre11">&lt;div&gt;</code>元素也有一个文本节点的子节点，其<code class="calibre11">nodevalue</code>的值为<code class="calibre11">"hello world!"</code>。下列代码可以用来访问这个文本节点：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">let textnode = div.firstchild; // 或div.childnodes[0]</code></pre>
<p class="calibre1">取得文本节点的引用后，可以像这样来修改它：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">div.firstchild.nodevalue = "some other message";</code></pre>
<p class="calibre1">只要节点在当前的文档树中，这样的修改就会马上反映出来。修改文本节点还有一点要注意，就是html或xml代码（取决于文档类型）会被转换成实体编码，即小于号、大于号或引号会被转义，如下所示：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">// 输出为"some &amp;lt;strong&amp;gt;other&amp;lt;/strong&amp;gt; message"
div.firstchild.nodevalue = "some &lt;strong&gt;other&lt;/strong&gt; message";</code></pre>
<p class="calibre1">这实际上是在将html字符串插入dom文档前进行编码的有效方式。</p>
<ol class="calibre16">
<li value="1" class="di_1ji_wu_xu_lie_biao"><p class="calibre1"><strong class="calibre2">创建文本节点</strong></p>
<p class="calibre1"><code class="calibre11">document.createtextnode()</code>可以用来创建新文本节点，它接收一个参数，即要插入节点的文本。跟设置已有文本节点的值一样，这些要插入的文本也会应用html或xml编码，如下面的例子所示：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">let textnode = document.createtextnode("&lt;strong&gt;hello&lt;/strong&gt; world!");</code></pre>
<p class="calibre1">创建新文本节点后，其<code class="calibre11">ownerdocument</code>属性会被设置为<code class="calibre11">document</code>。但在把这个节点添加到文档树之前，我们不会在浏览器中看到它。以下代码创建了一个<code class="calibre11">&lt;div&gt;</code>元素并给它添加了一段文本消息：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">let element = document.createelement("div");
element.classname = "message";

let textnode = document.createtextnode("hello world!");
element.appendchild(textnode);

document.body.appendchild(element);</code></pre>
<p class="calibre1">这个例子首先创建了一个<code class="calibre11">&lt;div&gt;</code>元素并给它添加了值为<code class="calibre11">"message"</code>的<code class="calibre11">class</code>属性，然后又创建了一个文本节点并添加到该元素。最后一步是把这个元素添加到文档的主体上，这样元素及其包含的文本会出现在浏览器中。</p>
<p class="calibre1">一般来说一个元素只包含一个文本子节点。不过，也可以让元素包含多个文本子节点，如下面的例子所示：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">let element = document.createelement("div");
element.classname = "message";

let textnode = document.createtextnode("hello world!");
element.appendchild(textnode);

let anothertextnode = document.createtextnode("yippee!");
element.appendchild(anothertextnode);

document.body.appendchild(element);</code></pre>
<p class="calibre1">在将一个文本节点作为另一个文本节点的同胞插入后，两个文本节点的文本之间不会包含空格。<br class="calibre4"/> </p>
</li>
<li value="2" class="di_1ji_wu_xu_lie_biao"><p class="calibre1"><strong class="calibre2">规范化文本节点</strong></p>
<p class="calibre1">dom文档中的同胞文本节点可能导致困惑，因为一个文本节点足以表示一个文本字符串。同样，dom文档中也经常会出现两个相邻文本节点。为此，有一个方法可以合并相邻的文本节点。这个方法叫<code class="calibre11">normalize()</code>，是在<code class="calibre11">node</code>类型中定义的（因此所有类型的节点上都有这个方法）。在包含两个或多个相邻文本节点的父节点上调用<code class="calibre11">normalize()</code>时，所有同胞文本节点会被合并为一个文本节点，这个文本节点的<code class="calibre11">nodevalue</code>就等于之前所有同胞节点<code class="calibre11">nodevalue</code>拼接在一起得到的字符串。来看下面的例子：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">let element = document.createelement("div");
element.classname = "message";

let textnode = document.createtextnode("hello world!");
element.appendchild(textnode);

let anothertextnode = document.createtextnode("yippee!");
element.appendchild(anothertextnode);

document.body.appendchild(element);

alert(element.childnodes.length);    // 2

element.normalize();
alert(element.childnodes.length);    // 1
alert(element.firstchild.nodevalue); // "hello world!yippee!"</code></pre>
<p class="calibre1">浏览器在解析文档时，永远不会创建同胞文本节点。同胞文本节点只会出现在dom脚本生成的文档树中。<br class="calibre4"/> </p>
</li>
<li value="3" class="di_1ji_wu_xu_lie_biao"><p class="calibre1"><strong class="calibre2">拆分文本节点</strong></p>
<p class="calibre1"><code class="calibre11">text</code>类型定义了一个与<code class="calibre11">normalize()</code>相反的方法——<code class="calibre11">splittext()</code>。这个方法可以在指定的偏移位置拆分<code class="calibre11">nodevalue</code>，将一个文本节点拆分成两个文本节点。拆分之后，原来的文本节点包含开头到偏移位置前的文本，新文本节点包含剩下的文本。这个方法返回新的文本节点，具有与原来的文本节点相同的<code class="calibre11">parentnode</code>。来看下面的例子：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">let element = document.createelement("div");
element.classname = "message";

let textnode = document.createtextnode("hello world!");
element.appendchild(textnode);

document.body.appendchild(element);

let newnode = element.firstchild.splittext(5);
alert(element.firstchild.nodevalue);  // "hello"
alert(newnode.nodevalue);             // " world!"
alert(element.childnodes.length);     // 2</code></pre>
<p class="calibre1">在这个例子中，包含<code class="calibre11">"hello world!"</code>的文本节点被从位置<code class="calibre11">5</code>拆分成两个文本节点。位置<code class="calibre11">5</code>对应<code class="calibre11">"hello"</code>和<code class="calibre11">"world!"</code>之间的空格，因此原始文本节点包含字符串<code class="calibre11">"hello"</code>，而新文本节点包含文本<code class="calibre11">" world!"</code>（包含空格）。</p>
<p class="calibre1">拆分文本节点最常用于从文本节点中提取数据的dom解析技术。</p>
</li>
</ol>
<h3 id="nav_point_312" class="calibre15">14.1.5　<code class="calibre26">comment</code>类型</h3>
<p class="calibre1">dom中的注释通过<code class="calibre11">comment</code>类型表示。<code class="calibre11">comment</code>类型的节点具有以下特征：</p>
<ul class="calibre10">
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">nodetype</code>等于8；</li>
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">nodename</code>值为<code class="calibre11">"#comment"</code>；</li>
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">nodevalue</code>值为注释的内容；</li>
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">parentnode</code>值为<code class="calibre11">document</code>或<code class="calibre11">element</code>对象；</li>
<li class="di_1ji_wu_xu_lie_biao">不支持子节点。</li>
</ul>
<p class="calibre1"><code class="calibre11">comment</code>类型与<code class="calibre11">text</code>类型继承同一个基类（<code class="calibre11">characterdata</code>），因此拥有除<code class="calibre11">splittext()</code>之外<code class="calibre11">text</code>节点所有的字符串操作方法。与<code class="calibre11">text</code>类型相似，注释的实际内容可以通过<code class="calibre11">nodevalue</code>或<code class="calibre11">data</code>属性获得。</p>
<p class="calibre1">注释节点可以作为父节点的子节点来访问。比如下面的html代码：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">&lt;div id="mydiv"&gt;&lt;!-- a comment --&gt;&lt;/div&gt;</code></pre>
<p class="calibre1">这里的注释是<code class="calibre11">&lt;div&gt;</code>元素的子节点，这意味着可以像下面这样访问它：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">let div = document.getelementbyid("mydiv");
let comment = div.firstchild;
alert(comment.data); // "a comment"</code></pre>
<p class="calibre1">可以使用<code class="calibre11">document.createcomment()</code>方法创建注释节点，参数为注释文本，如下所示：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">let comment = document.createcomment("a comment");</code></pre>
<p class="calibre1">显然，注释节点很少通过javascrpit创建和访问，因为注释几乎不涉及算法逻辑。此外，浏览器不承认结束的<code class="calibre11">&lt;/html&gt;</code>标签之后的注释。如果要访问注释节点，则必须确定它们是<code class="calibre11">&lt;html&gt;</code>元素的后代。</p>
<h3 id="nav_point_313" class="calibre15">14.1.6　<code class="calibre26">cdatasection</code>类型</h3>
<p class="calibre1"><code class="calibre11">cdatasection</code>类型表示xml中特有的cdata区块。<code class="calibre11">cdatasection</code>类型继承<code class="calibre11">text</code>类型，因此拥有包括<code class="calibre11">splittext()</code>在内的所有字符串操作方法。<code class="calibre11">cdatasection</code>类型的节点具有以下特征：</p>
<ul class="calibre10">
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">nodetype</code>等于4；</li>
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">nodename</code>值为<code class="calibre11">"#cdata-section"</code>；</li>
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">nodevalue</code>值为cdata区块的内容；</li>
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">parentnode</code>值为<code class="calibre11">document</code>或<code class="calibre11">element</code>对象；</li>
<li class="di_1ji_wu_xu_lie_biao">不支持子节点。</li>
</ul>
<p class="calibre1">cdata区块只在xml文档中有效，因此某些浏览器比较陈旧的版本会错误地将cdata区块解析为<code class="calibre11">comment</code>或<code class="calibre11">element</code>。比如下面这行代码：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">&lt;div id="mydiv"&gt;&lt;![cdata[this is some content.]]&gt;&lt;/div&gt;</code></pre>
<p class="calibre1">这里<code class="calibre11">&lt;div&gt;</code>的第一个子节点应该是<code class="calibre11">cdatasection</code>节点。但主流的四大浏览器没有一个将其识别为<code class="calibre11">cdatasection</code>。即使在有效的xhtml文档中，这些浏览器也不能恰当地支持嵌入的cdata区块。</p>
<p class="calibre1">在真正的xml文档中，可以使用<code class="calibre11">document.createcdatasection()</code>并传入节点内容来创建cdata区块。</p>
<h3 id="nav_point_314" class="calibre15">14.1.7　<code class="calibre26">documenttype</code>类型</h3>
<p class="calibre1"><code class="calibre11">documenttype</code>类型的节点包含文档的文档类型（<code class="calibre11">doctype</code>）信息，具有以下特征：</p>
<ul class="calibre10">
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">nodetype</code>等于10；</li>
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">nodename</code>值为文档类型的名称；</li>
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">nodevalue</code>值为<code class="calibre11">null</code>；</li>
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">parentnode</code>值为<code class="calibre11">document</code>对象；</li>
<li class="di_1ji_wu_xu_lie_biao">不支持子节点。</li>
</ul>
<p class="calibre1"><code class="calibre11">documenttype</code>对象在dom level 1中不支持动态创建，只能在解析文档代码时创建。对于支持这个类型的浏览器，<code class="calibre11">documenttype</code>对象保存在<code class="calibre11">document.doctype</code>属性中。dom level 1规定了<code class="calibre11">documenttype</code>对象的3个属性：<code class="calibre11">name</code>、<code class="calibre11">entities</code>和<code class="calibre11">notations</code>。其中，<code class="calibre11">name</code>是文档类型的名称，<code class="calibre11">entities</code>是这个文档类型描述的实体的<code class="calibre11">namednodemap</code>，而<code class="calibre11">notations</code>是这个文档类型描述的表示法的<code class="calibre11">namednodemap</code>。因为浏览器中的文档通常是html或xhtml文档类型，所以<code class="calibre11">entities</code>和<code class="calibre11">notations</code>列表为空。（这个对象只包含行内声明的文档类型。）无论如何，只有<code class="calibre11">name</code>属性是有用的。这个属性包含文档类型的名称，即紧跟在<code class="calibre11">&lt;!doctype</code>后面的那串文本。比如下面的html 4.01严格文档类型：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">&lt;!doctype html public "-// w3c// dtd html 4.01// en"
  "http:// www.w3.org/tr/html4/strict.dtd"&gt;</code></pre>
<p class="calibre1">对于这个文档类型，<code class="calibre11">name</code>属性的值是<code class="calibre11">"html"</code>：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">alert(document.doctype.name); // "html"</code></pre>
<h3 id="nav_point_315" class="calibre15">14.1.8　<code class="calibre26">documentfragment</code>类型</h3>
<p class="calibre1">在所有节点类型中，<code class="calibre11">documentfragment</code>类型是唯一一个在标记中没有对应表示的类型。dom将文档片段定义为“轻量级”文档，能够包含和操作节点，却没有完整文档那样额外的消耗。<code class="calibre11">documentfragment</code>节点具有以下特征：</p>
<ul class="calibre10">
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">nodetype</code>等于11；</li>
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">nodename</code>值为<code class="calibre11">"#document-fragment"</code>；</li>
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">nodevalue</code>值为<code class="calibre11">null</code>；</li>
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">parentnode</code>值为<code class="calibre11">null</code>；</li>
<li class="di_1ji_wu_xu_lie_biao">子节点可以是<code class="calibre11">element</code>、<code class="calibre11">processinginstruction</code>、<code class="calibre11">comment</code>、<code class="calibre11">text</code>、<code class="calibre11">cdatasection</code>或<code class="calibre11">entityreference</code>。</li>
</ul>
<p class="calibre1">不能直接把文档片段添加到文档。相反，文档片段的作用是充当其他要被添加到文档的节点的仓库。可以使用<code class="calibre11">document.createdocumentfragment()</code>方法像下面这样创建文档片段：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">let fragment = document.createdocumentfragment();</code></pre>
<p class="calibre1">文档片段从<code class="calibre11">node</code>类型继承了所有文档类型具备的可以执行dom操作的方法。如果文档中的一个节点被添加到一个文档片段，则该节点会从文档树中移除，不会再被浏览器渲染。添加到文档片段的新节点同样不属于文档树，不会被浏览器渲染。可以通过<code class="calibre11">appendchild()</code>或<code class="calibre11">insertbefore()</code>方法将文档片段的内容添加到文档。在把文档片段作为参数传给这些方法时，这个文档片段的所有子节点会被添加到文档中相应的位置。文档片段本身永远不会被添加到文档树。以下面的html为例：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">&lt;ul id="mylist"&gt;&lt;/ul&gt;</code></pre>
<p class="calibre1">假设想给这个<code class="calibre11">&lt;ul&gt;</code>元素添加3个列表项。如果分3次给这个元素添加列表项，浏览器就要重新渲染3次页面，以反映新添加的内容。为避免多次渲染，下面的代码示例使用文档片段创建了所有列表项，然后一次性将它们添加到了<code class="calibre11">&lt;ul&gt;</code>元素：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">let fragment = document.createdocumentfragment();
let ul = document.getelementbyid("mylist");

for (let i = 0; i &lt; 3; ++i) {
  let li = document.createelement("li");
  li.appendchild(document.createtextnode(`item ${i + 1}`));
  fragment.appendchild(li);
}

ul.appendchild(fragment);</code></pre>
<p class="calibre1">这个例子先创建了一个文档片段，然后取得了<code class="calibre11">&lt;ul&gt;</code>元素的引用。接着通过<code class="calibre11">for</code>循环创建了3个列表项，每一项都包含表明自己身份的文本。为此先创建<code class="calibre11">&lt;li&gt;</code>元素，再创建文本节点并添加到该元素。然后通过<code class="calibre11">appendchild()</code>把<code class="calibre11">&lt;li&gt;</code>元素添加到文档片段。循环结束后，通过把文档片段传给<code class="calibre11">appendchild()</code>将所有列表项添加到了<code class="calibre11">&lt;ul&gt;</code>元素。此时，文档片段的子节点全部被转移到了<code class="calibre11">&lt;ul&gt;</code>元素。</p>
<h3 id="nav_point_316" class="calibre15">14.1.9　<code class="calibre26">attr</code>类型</h3>
<p class="calibre1">元素数据在dom中通过<code class="calibre11">attr</code>类型表示。<code class="calibre11">attr</code>类型构造函数和原型在所有浏览器中都可以直接访问。技术上讲，属性是存在于元素<code class="calibre11">attributes</code>属性中的节点。<code class="calibre11">attr</code>节点具有以下特征：</p>
<ul class="calibre10">
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">nodetype</code>等于2；</li>
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">nodename</code>值为属性名；</li>
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">nodevalue</code>值为属性值；</li>
<li class="di_1ji_wu_xu_lie_biao"><code class="calibre11">parentnode</code>值为<code class="calibre11">null</code>；</li>
<li class="di_1ji_wu_xu_lie_biao">在html中不支持子节点；</li>
<li class="di_1ji_wu_xu_lie_biao">在xml中子节点可以是<code class="calibre11">text</code>或<code class="calibre11">entityreference</code>。</li>
</ul>
<p class="calibre1">属性节点尽管是节点，却不被认为是dom文档树的一部分。<code class="calibre11">attr</code>节点很少直接被引用，通常开发者更喜欢使用<code class="calibre11">getattribute()</code>、<code class="calibre11">removeattribute()</code>和<code class="calibre11">setattribute()</code>方法操作属性。</p>
<p class="calibre1"><code class="calibre11">attr</code>对象上有3个属性：<code class="calibre11">name</code>、<code class="calibre11">value</code>和<code class="calibre11">specified</code>。其中，<code class="calibre11">name</code>包含属性名（与<code class="calibre11">nodename</code>一样），<code class="calibre11">value</code>包含属性值（与<code class="calibre11">nodevalue</code>一样），而<code class="calibre11">specified</code>是一个布尔值，表示属性使用的是默认值还是被指定的值。</p>
<p class="calibre1">可以使用<code class="calibre11">document.createattribute()</code>方法创建新的<code class="calibre11">attr</code>节点，参数为属性名。比如，要给元素添加<code class="calibre11">align</code>属性，可以使用下列代码：</p>
<pre class="dai_ma_wu_xing_hao"><code class="calibre11">let attr = document.createattribute("align");
attr.value = "left";
element.setattributenode(attr);

alert(element.attributes["align"].value);       // "left"
alert(element.getattributenode("align").value); // "left"
alert(element.getattribute("align"));           // "left"</code></pre>
<p class="calibre1">在这个例子中，首先创建了一个新属性。调用<code class="calibre11">createattribute()</code>并传入<code class="calibre11">"align"</code>为新属性设置了<code class="calibre11">name</code>属性，因此就不用再设置了。随后，<code class="calibre11">value</code>属性被赋值为<code class="calibre11">"left"</code>。为把这个新属性添加到元素上，可以使用元素的<code class="calibre11">setattributenode()</code>方法。添加这个属性后，可以通过不同方式访问它，包括<code class="calibre11">attributes</code>属性、<code class="calibre11">getattributenode()</code>和<code class="calibre11">getattribute()</code>方法。其中，<code class="calibre11">attributes</code>属性和<code class="calibre11">getattributenode()</code>方法都返回属性对应的<code class="calibre11">attr</code>节点，而<code class="calibre11">getattribute()</code>方法只返回属性的值。</p>
<blockquote class="calibre13">
<p class="calibre1"><strong class="calibre2">注意</strong>　将属性作为节点来访问多数情况下并无必要。推荐使用<code class="calibre11">getattribute()</code>、<code class="calibre11">removeattribute()</code>和<code class="calibre11">setattribute()</code>方法操作属性，而不是直接操作属性节点。</p>
</blockquote>



  </div>

  
  <div class="calibretoc">
    <h2><a href="../../54m0dfqx.html">table of contents
</a></h2>
    <div>
  <ul>
    <li>
      <a href="part0002.html#nav_point_0">版权声明</a>
    </li>
    <li>
      <a href="part0003.html#nav_point_1">献词</a>
    </li>
    <li>
      <a href="part0004.html#nav_point_2">译者序</a>
    </li>
    <li>
      <a href="part0005.html#nav_point_3">序</a>
    </li>
    <li>
      <a href="part0006.html#nav_point_4">前言</a>
    </li>
    <li>
      <a href="part0012.html#nav_point_10">致谢</a>
    </li>
    <li>
      <a href="part0013.html#nav_point_11">第 1 章 什么是javascript</a>
    </li>
    <li>
      <a href="part0018.html#nav_point_19">第 2 章 html中的javascript</a>
    </li>
    <li>
      <a href="part0024.html#nav_point_31">第 3 章 语言基础</a>
    </li>
    <li>
      <a href="part0033.html#nav_point_78">第 4 章 变量、作用域与内存</a>
    </li>
    <li>
      <a href="part0038.html#nav_point_93">第 5 章 基本引用类型</a>
    </li>
    <li>
      <a href="part0044.html#nav_point_111">第 6 章 集合引用类型</a>
    </li>
    <li>
      <a href="part0054.html#nav_point_153">第 7 章 迭代器与生成器</a>
    </li>
    <li>
      <a href="part0059.html#nav_point_166">第 8 章 对象、类与面向对象编程</a>
    </li>
    <li>
      <a href="part0065.html#nav_point_194">第 9 章 代理与反射</a>
    </li>
    <li>
      <a href="part0070.html#nav_point_225">第 10 章 函数</a>
    </li>
    <li>
      <a href="part0088.html#nav_point_258">第 11 章 期约与异步函数</a>
    </li>
    <li>
      <a href="part0093.html#nav_point_273">第 12 章 bom</a>
    </li>
    <li>
      <a href="part0100.html#nav_point_294">第 13 章 客户端检测</a>
    </li>
    <li>
      <a href="part0105.html#nav_point_306">第 14 章 dom</a>
    </li>
    <li>
      <a href="part0110.html#nav_point_328">第 15 章 dom扩展</a>
    </li>
    <li>
      <a href="part0116.html#nav_point_348">第 16 章 dom2和dom3</a>
    </li>
    <li>
      <a href="part0122.html#nav_point_370">第 17 章 事件</a>
    </li>
    <li>
      <a href="part0130.html#nav_point_403">第 18 章 动画与canvas图形</a>
    </li>
    <li>
      <a href="part0136.html#nav_point_428">第 19 章 表单脚本</a>
    </li>
    <li>
      <a href="part0143.html#nav_point_450">第 20 章 javascript api</a>
    </li>
    <li>
      <a href="part0157.html#nav_point_500">第 21 章 错误处理与调试</a>
    </li>
    <li>
      <a href="part0163.html#nav_point_526">第 22 章 处理xml</a>
    </li>
    <li>
      <a href="part0168.html#nav_point_542">第 23 章 json</a>
    </li>
    <li>
      <a href="part0172.html#nav_point_552">第 24 章 网络请求与远程资源</a>
    </li>
    <li>
      <a href="part0182.html#nav_point_582">第 25 章 客户端存储</a>
    </li>
    <li>
      <a href="part0187.html#nav_point_607">第 26 章 模块</a>
    </li>
    <li>
      <a href="part0193.html#nav_point_633">第 27 章 工作者线程</a>
    </li>
    <li>
      <a href="part0199.html#nav_point_667">第 28 章 最佳实践</a>
    </li>
    <li>
      <a href="part0204.html#nav_point_683">附录 a es2018和es2019</a>
    </li>
    <li>
      <a href="part0215.html#nav_point_708">附录 b 严格模式</a>
    </li>
    <li>
      <a href="part0223.html#nav_point_719">附录 c javascript库和框架</a>
    </li>
    <li>
      <a href="part0227.html#nav_point_741">附录 d javascript工具</a>
    </li>
    <li>
      <a href="part0239.html#nav_point_800">作者简介</a>
    </li>
  </ul>
</div>


  </div>
  

  <div class="calibreebnav">
    
      <a href="part0105.html" class="calibreaprev">上一页
</a>
    

    <a href="../../54m0dfqx.html" class="calibreahome">首页
</a>

    
      <a href="part0107.html" class="calibreanext">下一页
</a>
    
  </div>

</div>

</body>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-6487844781006261"
     data-ad-slot="3432081921"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</html>
