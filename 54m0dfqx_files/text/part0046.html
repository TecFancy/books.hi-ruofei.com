<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>

    <title>JavaScript高级程序设计（第4版）</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" type="text/css" href="../stylesheet.css"/>
    <link rel="stylesheet" type="text/css" href="../page_styles.css"/>

    <link href="../calibreHtmlOutBasicCss.css" type="text/css" rel="stylesheet"/>

  </head>
  <body>

    <div class="calibreMeta">
      <div class="calibreMetaTitle">

        <h1>
          <a href="../../54m0dfqx.html">JavaScript高级程序设计（第4版）
          </a>
        </h1>

      </div>
      <div class="calibreMetaAuthor">
        [美] 马特 • 弗里斯比

      </div>
    </div>

    <div class="calibreMain">

      <div class="calibreEbookContent">

        <div class="calibreEbNavTop">

          <a href="part0045.html" class="calibreAPrev">上一页
          </a>

          <a href="part0047.html" class="calibreANext">下一页
          </a>

        </div>

        <h2 id="nav_point_113" class="calibre9">6.2
          <code class="calibre26">Array</code>
        </h2>
        <p class="calibre1">除了<code class="calibre11">Object</code>，<code class="calibre11">Array</code>应该就是ECMAScript中最常用的类型了。ECMAScript数组跟其他编程语言的数组有很大区别。跟其他语言中的数组一样，ECMAScript数组也是一组有序的数据，但跟其他语言不同的是，数组中每个槽位可以存储任意类型的数据。这意味着可以创建一个数组，它的第一个元素是字符串，第二个元素是数值，第三个是对象。ECMAScript数组也是动态大小的，会随着数据添加而自动增长。</p>
        <h3 id="nav_point_114" class="calibre15">6.2.1 创建数组</h3>
        <p class="calibre1">有几种基本的方式可以创建数组。一种是使用<code class="calibre11">Array</code>构造函数，比如：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let colors = new array();</code></pre>
        <p class="calibre1">如果知道数组中元素的数量，那么可以给构造函数传入一个数值，然后<code class="calibre11">length</code>属性就会被自动创建并设置为这个值。比如，下面的代码会创建一个初始<code class="calibre11">length</code>为20的数组：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let colors = new array(20);</code></pre>
        <p class="calibre1">也可以给<code class="calibre11">Array</code>构造函数传入要保存的元素。比如，下面的代码会创建一个包含3个字符串值的数组：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let colors = new array("red", "blue", "green");</code></pre>
        <p class="calibre1">创建数组时可以给构造函数传一个值。这时候就有点问题了，因为如果这个值是数值，则会创建一个长度为指定数值的数组；而如果这个值是其他类型的，则会创建一个只包含该特定值的数组。下面看一个例子：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let colors = new array(3);     // 创建一个包含3个元素的数组
let names = new array("greg"); // 创建一个只包含一个元素，即字符串"greg"的数组</code></pre>
        <p class="calibre1">在使用<code class="calibre11">Array</code>构造函数时，也可以省略<code class="calibre11">new</code>操作符。结果是一样的，比如：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let colors = array(3);     // 创建一个包含3个元素的数组
let names = array("greg"); // 创建一个只包含一个元素，即字符串"greg"的数组</code></pre>
        <p class="calibre1">另一种创建数组的方式是使用<strong class="calibre2">数组字面量</strong>（array literal）表示法。数组字面量是在中括号中包含以逗号分隔的元素列表，如下面的例子所示：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let colors = ["red", "blue", "green"];  // 创建一个包含3个元素的数组
let names = [];                         // 创建一个空数组
let values = [1,2,];                    // 创建一个包含2个元素的数组</code></pre>
        <p class="calibre1">在这个例子中，第一行创建一个包含3个字符串的数组。第二行用一对空中括号创建了一个空数组。第三行展示了在数组最后一个值后面加逗号的效果：<code class="calibre11">values</code>是一个包含两个值（1和2）的数组。</p>
        <blockquote class="calibre13">
          <p class="calibre1">
            <strong class="calibre2">注意</strong>
            与对象一样，在使用数组字面量表示法创建数组不会调用<code class="calibre11">Array</code>构造函数。</p>
        </blockquote>
        <p class="calibre1">
          <code class="calibre11">Array</code>构造函数还有两个ES6新增的用于创建数组的静态方法：<code class="calibre11">from()</code>和<code class="calibre11">of()</code>。<code class="calibre11">from()</code>用于将类数组结构转换为数组实例，而<code class="calibre11">of()</code>用于将一组参数转换为数组实例。</p>
        <p class="calibre1">
          <code class="calibre11">Array.from()</code>的第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个<code class="calibre11">length</code>属性和可索引元素的结构。这种方式可用于很多场合：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">// 字符串会被拆分为单字符数组
console.log(array.from("matt")); // ["m", "a", "t", "t"]

// 可以使用from()将集合和映射转换为一个新数组
const m = new map().set(1, 2)
                   .set(3, 4);
const s = new set().add(1)
                   .add(2)
                   .add(3)
                   .add(4);

console.log(array.from(m)); // [[1, 2], [3, 4]]
console.log(array.from(s)); // [1, 2, 3, 4]

// array.from()对现有数组执行浅复制
const a1 = [1, 2, 3, 4];
const a2 = array.from(a1);

console.log(a1);        // [1, 2, 3, 4]
alert(a1 === a2); // false


// 可以使用任何可迭代对象
const iter = {
  *[symbol.iterator]() {
    yield 1;
    yield 2;
    yield 3;
    yield 4;

  }
};
console.log(array.from(iter)); // [1, 2, 3, 4]

// arguments对象可以被轻松地转换为数组
function getargsarray() {
  return array.from(arguments);
}
console.log(getargsarray(1, 2, 3, 4)); // [1, 2, 3, 4]

// from()也能转换带有必要属性的自定义对象
const arraylikeobject = {
  0: 1,
  1: 2,
  2: 3,
  3: 4,
  length: 4
};
console.log(array.from(arraylikeobject)); // [1, 2, 3, 4]</code></pre>
        <p class="calibre1">
          <code class="calibre11">Array.from()</code>还接收第二个可选的映射函数参数。这个函数可以直接增强新数组的值，而无须像调用<code class="calibre11">Array.from().map()</code>那样先创建一个中间数组。还可以接收第三个可选参数，用于指定映射函数中<code class="calibre11">this</code>的值。但这个重写的<code class="calibre11">this</code>值在箭头函数中不适用。</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">const a1 = [1, 2, 3, 4];
const a2 = array.from(a1, x =&gt; x**2);
const a3 = array.from(a1, function(x) {return x**this.exponent}, {exponent: 2});
console.log(a2);  // [1, 4, 9, 16]
console.log(a3);  // [1, 4, 9, 16]</code></pre>
        <p class="calibre1">
          <code class="calibre11">Array.of()</code>可以把一组参数转换为数组。这个方法用于替代在ES6之前常用的<code class="calibre11">Array.prototype.slice.call(arguments)</code>，一种异常笨拙的将<code class="calibre11">arguments</code>对象转换为数组的写法：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">console.log(array.of(1, 2, 3, 4)); // [1, 2, 3, 4]
console.log(array.of(undefined));  // [undefined]</code></pre>
        <h3 id="nav_point_115" class="calibre15">6.2.2 数组空位</h3>
        <p class="calibre1">使用数组字面量初始化数组时，可以使用一串逗号来创建空位（hole）。ECMAScript会将逗号之间相应索引位置的值当成空位，ES6规范重新定义了该如何处理这些空位。</p>
        <p class="calibre1">可以像下面这样创建一个空位数组：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">const options = [,,,,,]; // 创建包含5个元素的数组
console.log(options.length);   // 5
console.log(options);          // [,,,,,]</code></pre>
        <p class="calibre1">ES6新增的方法和迭代器与早期ECMAScript版本中存在的方法行为不同。ES6新增方法普遍将这些空位当成存在的元素，只不过值为<code class="calibre11">undefined</code>：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">const options = [1,,,,5];

for (const option of options) {
  console.log(option === undefined);
}
// false
// true
// true
// true
// false

const a = array.from([,,,]); // 使用es6的array.from()创建的包含3个空位的数组
for (const val of a) {
  alert(val === undefined);
}
// true
// true
// true

alert(array.of(...[,,,])); // [undefined, undefined, undefined]

for (const [index, value] of options.entries()) {
  alert(value);
}
// 1
// undefined
// undefined
// undefined
// 5</code></pre>
        <p class="calibre1">ES6之前的方法则会忽略这个空位，但具体的行为也会因方法而异：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">const options = [1,,,,5];

// map()会跳过空位置
console.log(options.map(() =&gt; 6));  // [6, undefined, undefined, undefined, 6]

// join()视空位置为空字符串
console.log(options.join('-'));     // "1----5"</code></pre>
        <blockquote class="calibre13">
          <p class="calibre1">
            <strong class="calibre2">注意</strong>
            由于行为不一致和存在性能隐患，因此实践中要避免使用数组空位。如果确实需要空位，则可以显式地用<code class="calibre11">undefined</code>值代替。</p>
        </blockquote>
        <h3 id="nav_point_116" class="calibre15">6.2.3 数组索引</h3>
        <p class="calibre1">要取得或设置数组的值，需要使用中括号并提供相应值的数字索引，如下所示：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let colors = ["red", "blue", "green"];  // 定义一个字符串数组
alert(colors[0]);                       // 显示第一项
colors[2] = "black";                    // 修改第三项
colors[3] = "brown";                    // 添加第四项</code></pre>
        <p class="calibre1">在中括号中提供的索引表示要访问的值。如果索引小于数组包含的元素数，则返回存储在相应位置的元素，就像示例中<code class="calibre11">colors[0]</code>显示<code class="calibre11">"red"</code>一样。设置数组的值方法也是一样的，就是替换指定位置的值。如果把一个值设置给超过数组最大索引的索引，就像示例中的<code class="calibre11">colors[3]</code>，则数组长度会自动扩展到该索引值加1（示例中设置的索引3，所以数组长度变成了4）。</p>
        <p class="calibre1">数组中元素的数量保存在<code class="calibre11">length</code>属性中，这个属性始终返回0或大于0的值，如下例所示：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let colors = ["red", "blue", "green"];  // 创建一个包含3个字符串的数组
let names = [];                         // 创建一个空数组

alert(colors.length); // 3
alert(names.length);  // 0</code></pre>
        <p class="calibre1">数组<code class="calibre11">length</code>属性的独特之处在于，它不是只读的。通过修改<code class="calibre11">length</code>属性，可以从数组末尾删除或添加元素。来看下面的例子：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let colors = ["red", "blue", "green"]; // 创建一个包含3个字符串的数组
colors.length = 2;
alert(colors[2]);  // undefined</code></pre>
        <p class="calibre1">这里，数组<code class="calibre11">colors</code>一开始有3个值。将<code class="calibre11">length</code>设置为2，就删除了最后一个（位置2的）值，因此<code class="calibre11">colors[2]</code>就没有值了。如果将<code class="calibre11">length</code>设置为大于数组元素数的值，则新添加的元素都将以<code class="calibre11">undefined</code>填充，如下例所示：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let colors = ["red", "blue", "green"];  // 创建一个包含3个字符串的数组
colors.length = 4;
alert(colors[3]);  // undefined</code></pre>
        <p class="calibre1">这里将数组<code class="calibre11">colors</code>的<code class="calibre11">length</code>设置为4，虽然数组只包含3个元素。位置3在数组中不存在，因此访问其值会返回特殊值<code class="calibre11">undefined</code>。</p>
        <p class="calibre1">使用<code class="calibre11">length</code>属性可以方便地向数组末尾添加元素，如下例所示：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let colors = ["red", "blue", "green"];  // 创建一个包含3个字符串的数组
colors[colors.length] = "black";        // 添加一种颜色（位置3）
colors[colors.length] = "brown";        // 再添加一种颜色（位置4）</code></pre>
        <p class="calibre1">数组中最后一个元素的索引始终是<code class="calibre11">length - 1</code>，因此下一个新增槽位的索引就是<code class="calibre11">length</code>。每次在数组最后一个元素后面新增一项，数组的<code class="calibre11">length</code>属性都会自动更新，以反映变化。这意味着第二行的<code class="calibre11">colors[colors.length]</code>会在位置3添加一个新元素，下一行则会在位置4添加一个新元素。新的长度会在新增元素被添加到当前数组外部的位置上时自动更新。换句话说，就是<code class="calibre11">length</code>属性会更新为位置加上1，如下例所示：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let colors = ["red", "blue", "green"];  // 创建一个包含3个字符串的数组
colors[99] = "black";                   // 添加一种颜色（位置99）
alert(colors.length);                   // 100</code></pre>
        <p class="calibre1">这里，<code class="calibre11">colors</code>数组有一个值被插入到位置99，结果新<code class="calibre11">length</code>就变成了100（99 + 1）。这中间的所有元素，即位置3~98，实际上并不存在，因此在访问时会返回<code class="calibre11">undefined</code>。</p>
        <blockquote class="calibre13">
          <p class="calibre1">
            <strong class="calibre2">注意</strong>
            数组最多可以包含4 294 967 295个元素，这对于大多数编程任务应该足够了。如果尝试添加更多项，则会导致抛出错误。以这个最大值作为初始值创建数组，可能导致脚本运行时间过长的错误。</p>
        </blockquote>
        <h3 id="nav_point_117" class="calibre15">6.2.4 检测数组</h3>
        <p class="calibre1">一个经典的ECMAScript问题是判断一个对象是不是数组。在只有一个网页（因而只有一个全局作用域）的情况下，使用<code class="calibre11">instanceof</code>操作符就足矣：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">if (value instanceof array){
  // 操作数组
}</code></pre>
        <p class="calibre1">使用<code class="calibre11">instanceof</code>的问题是假定只有一个全局执行上下文。如果网页里有多个框架，则可能涉及两个不同的全局执行上下文，因此就会有两个不同版本的<code class="calibre11">Array</code>构造函数。如果要把数组从一个框架传给另一个框架，则这个数组的构造函数将有别于在第二个框架内本地创建的数组。</p>
        <p class="calibre1">为解决这个问题，ECMAScript提供了<code class="calibre11">Array.isArray()</code>方法。这个方法的目的就是确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的。来看下面的例子：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">if (array.isarray(value)){
  // 操作数组
}</code></pre>
        <h3 id="nav_point_118" class="calibre15">6.2.5 迭代器方法</h3>
        <p class="calibre1">在ES6中，<code class="calibre11">Array</code>的原型上暴露了3个用于检索数组内容的方法：<code class="calibre11">keys()</code>、<code class="calibre11">values()</code>和<code class="calibre11">entries()</code>。<code class="calibre11">keys()</code>返回数组索引的迭代器，<code class="calibre11">values()</code>返回数组元素的迭代器，而<code class="calibre11">entries()</code>返回索引/值对的迭代器：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">const a = ["foo", "bar", "baz", "qux"];

// 因为这些方法都返回迭代器，所以可以将它们的内容
// 通过array.from()直接转换为数组实例
const akeys = array.from(a.keys());
const avalues = array.from(a.values());
const aentries = array.from(a.entries());

console.log(akeys);     // [0, 1, 2, 3]
console.log(avalues);   // ["foo", "bar", "baz", "qux"]
console.log(aentries);  // [[0, "foo"], [1, "bar"], [2, "baz"], [3, "qux"]]</code></pre>
        <p class="calibre1">使用ES6的解构可以非常容易地在循环中拆分键/值对：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">const a = ["foo", "bar", "baz", "qux"];

for (const [idx, element] of a.entries()) {
  alert(idx);
  alert(element);
}
// 0
// foo
// 1
// bar
// 2
// baz
// 3
// qux</code></pre>
        <blockquote class="calibre13">
          <p class="calibre1">
            <strong class="calibre2">注意</strong>
            虽然这些方法是ES6规范定义的，但在2017年底的时候仍有浏览器没有实现它们。</p>
        </blockquote>
        <h3 id="nav_point_119" class="calibre15">6.2.6 复制和填充方法</h3>
        <p class="calibre1">ES6新增了两个方法：批量复制方法<code class="calibre11">copyWithin()</code>，以及填充数组方法<code class="calibre11">fill()</code>。这两个方法的函数签名类似，都需要指定既有数组实例上的一个范围，包含开始索引，不包含结束索引。使用这个方法不会改变数组的大小。</p>
        <p class="calibre1">使用<code class="calibre11">fill()</code>方法可以向一个已有的数组中插入全部或部分相同的值。开始索引用于指定开始填充的位置，它是可选的。如果不提供结束索引，则一直填充到数组末尾。负值索引从数组末尾开始计算。也可以将负索引想象成数组长度加上它得到的一个正索引：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">const zeroes = [0, 0, 0, 0, 0];

// 用5填充整个数组
zeroes.fill(5);
console.log(zeroes);  // [5, 5, 5, 5, 5]
zeroes.fill(0);       // 重置

// 用6填充索引大于等于3的元素
zeroes.fill(6, 3);
console.log(zeroes);  // [0, 0, 0, 6, 6]
zeroes.fill(0);       // 重置

// 用7填充索引大于等于1且小于3的元素
zeroes.fill(7, 1, 3);
console.log(zeroes);  // [0, 7, 7, 0, 0];
zeroes.fill(0);       // 重置

// 用8填充索引大于等于1且小于4的元素
// (-4 + zeroes.length = 1)
// (-1 + zeroes.length = 4)
zeroes.fill(8, -4, -1);
console.log(zeroes);  // [0, 8, 8, 8, 0];</code></pre>
        <p class="calibre1">
          <code class="calibre11">fill()</code>静默忽略超出数组边界、零长度及方向相反的索引范围：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">const zeroes = [0, 0, 0, 0, 0];

// 索引过低，忽略
zeroes.fill(1, -10, -6);
console.log(zeroes);  // [0, 0, 0, 0, 0]

// 索引过高，忽略
zeroes.fill(1, 10, 15);
console.log(zeroes);  // [0, 0, 0, 0, 0]

// 索引反向，忽略
zeroes.fill(2, 4, 2);
console.log(zeroes);  // [0, 0, 0, 0, 0]

// 索引部分可用，填充可用部分
zeroes.fill(4, 3, 10)
console.log(zeroes);  // [0, 0, 0, 4, 4]</code></pre>
        <p class="calibre1">与<code class="calibre11">fill()</code>不同，<code class="calibre11">copyWithin()</code>会按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置。开始索引和结束索引则与<code class="calibre11">fill()</code>使用同样的计算方法：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let ints,
    reset = () =&gt; ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
reset();

// 从ints中复制索引0开始的内容，插入到索引5开始的位置
// 在源索引或目标索引到达数组边界时停止
ints.copywithin(5);
console.log(ints);  // [0, 1, 2, 3, 4, 0, 1, 2, 3, 4]
reset();

// 从ints中复制索引5开始的内容，插入到索引0开始的位置
ints.copywithin(0, 5);
console.log(ints);  // [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]
reset();

// 从ints中复制索引0开始到索引3结束的内容
// 插入到索引4开始的位置
ints.copywithin(4, 0, 3);
alert(ints);  // [0, 1, 2, 3, 0, 1, 2, 7, 8, 9]
reset();

// javascript引擎在插值前会完整复制范围内的值
// 因此复制期间不存在重写的风险
ints.copywithin(2, 0, 6);
alert(ints);  // [0, 1, 0, 1, 2, 3, 4, 5, 8, 9]
reset();

// 支持负索引值，与fill()相对于数组末尾计算正向索引的过程是一样的
ints.copywithin(-4, -7, -3);
alert(ints);  // [0, 1, 2, 3, 4, 5, 3, 4, 5, 6]</code></pre>
        <p class="calibre1">
          <code class="calibre11">copyWithin()</code>静默忽略超出数组边界、零长度及方向相反的索引范围：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let ints,
    reset = () =&gt; ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
reset();

// 索引过低，忽略
ints.copywithin(1, -15, -12);
alert(ints);  // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
reset()

// 索引过高，忽略
ints.copywithin(1, 12, 15);
alert(ints);  // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
reset();

// 索引反向，忽略
ints.copywithin(2, 4, 2);
alert(ints);  // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
reset();

// 索引部分可用，复制、填充可用部分
ints.copywithin(4, 7, 10)
alert(ints);  // [0, 1, 2, 3, 7, 8, 9, 7, 8, 9];</code></pre>
        <h3 id="nav_point_120" class="calibre15">6.2.7 转换方法</h3>
        <p class="calibre1">前面提到过，所有对象都有<code class="calibre11">toLocaleString()</code>、<code class="calibre11">toString()</code>和<code class="calibre11">valueOf()</code>方法。其中，<code class="calibre11">valueOf()</code>返回的还是数组本身。而<code class="calibre11">toString()</code>返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串。也就是说，对数组的每个值都会调用其<code class="calibre11">toString()</code>方法，以得到最终的字符串。来看下面的例子：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let colors = ["red", "blue", "green"]; // 创建一个包含3个字符串的数组
alert(colors.tostring());   // red,blue,green
alert(colors.valueof());    // red,blue,green
alert(colors);              // red,blue,green</code></pre>
        <p class="calibre1">首先是被显式调用的<code class="calibre11">toString()</code>和<code class="calibre11">valueOf()</code>方法，它们分别返回了数组的字符串表示，即将所有字符串组合起来，以逗号分隔。最后一行代码直接用<code class="calibre11">alert()</code>显示数组，因为<code class="calibre11">alert()</code>期待字符串，所以会在后台调用数组的<code class="calibre11">toString()</code>方法，从而得到跟前面一样的结果。</p>
        <p class="calibre1">
          <code class="calibre11">toLocaleString()</code>方法也可能返回跟<code class="calibre11">toString()</code>和<code class="calibre11">valueOf()</code>相同的结果，但也不一定。在调用数组的<code class="calibre11">toLocaleString()</code>方法时，会得到一个逗号分隔的数组值的字符串。它与另外两个方法唯一的区别是，为了得到最终的字符串，会调用数组每个值的<code class="calibre11">toLocaleString()</code>方法，而不是<code class="calibre11">toString()</code>方法。看下面的例子：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let person1 = {
  tolocalestring() {
    return "nikolaos";
  },

  tostring() {
    return "nicholas";
  }
};

let person2 = {
  tolocalestring() {
    return "grigorios";
  },

  tostring() {
    return "greg";
  }
};

let people = [person1, person2];
alert(people);                   // nicholas,greg
alert(people.tostring());        // nicholas,greg
alert(people.tolocalestring());  // nikolaos,grigorios</code></pre>
        <p class="calibre1">这里定义了两个对象<code class="calibre11">person1</code>和<code class="calibre11">person2</code>，它们都定义了<code class="calibre11">toString()</code>和<code class="calibre11">toLocaleString()</code>方法，而且返回不同的值。然后又创建了一个包含这两个对象的数组<code class="calibre11">people</code>。在将数组传给<code class="calibre11">alert()</code>时，输出的是<code class="calibre11">"Nicholas,Greg"</code>，这是因为会在数组每一项上调用<code class="calibre11">toString()</code>方法（与下一行显式调用<code class="calibre11">toString()</code>方法结果一样）。而在调用数组的<code class="calibre11">toLocaleString()</code>方法时，结果变成了<code class="calibre11">"Nikolaos, Grigorios"</code>，这是因为调用了数组每一项的<code class="calibre11">toLocaleString()</code>方法。</p>
        <p class="calibre1">继承的方法<code class="calibre11">toLocaleString()</code>以及<code class="calibre11">toString()</code>都返回数组值的逗号分隔的字符串。如果想使用不同的分隔符，则可以使用<code class="calibre11">join()</code>方法。<code class="calibre11">join()</code>方法接收一个参数，即字符串分隔符，返回包含所有项的字符串。来看下面的例子：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let colors = ["red", "green", "blue"];
alert(colors.join(","));     // red,green,blue
alert(colors.join("||"));    // red||green||blue</code></pre>
        <p class="calibre1">这里在<code class="calibre11">colors</code>数组上调用了<code class="calibre11">join()</code>方法，得到了与调用<code class="calibre11">toString()</code>方法相同的结果。传入逗号，结果就是逗号分隔的字符串。最后一行给<code class="calibre11">join()</code>传入了双竖线，得到了字符串<code class="calibre11">"red||green||blue"</code>。如果不给<code class="calibre11">join()</code>传入任何参数，或者传入<code class="calibre11">undefined</code>，则仍然使用逗号作为分隔符。</p>
        <blockquote class="calibre13">
          <p class="calibre1">
            <strong class="calibre2">注意</strong>
            如果数组中某一项是<code class="calibre11">null</code>或<code class="calibre11">undefined</code>，则在<code class="calibre11">join()</code>、<code class="calibre11">toLocaleString()</code>、<code class="calibre11">toString()</code>和<code class="calibre11">valueOf()</code>返回的结果中会以空字符串表示。</p>
        </blockquote>
        <h3 id="nav_point_121" class="calibre15">6.2.8 栈方法</h3>
        <p class="calibre1">ECMAScript给数组提供几个方法，让它看起来像是另外一种数据结构。数组对象可以像栈一样，也就是一种限制插入和删除项的数据结构。栈是一种后进先出（LIFO，Last-In-First-Out）的结构，也就是最近添加的项先被删除。数据项的插入（称为<strong class="calibre2">推入</strong>，push）和删除（称为<strong class="calibre2">弹出</strong>，pop）只在栈的一个地方发生，即栈顶。ECMAScript数组提供了<code class="calibre11">push()</code>和<code class="calibre11">pop()</code>方法，以实现类似栈的行为。</p>
        <p class="calibre1">
          <code class="calibre11">push()</code>方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度。<code class="calibre11">pop()</code>方法则用于删除数组的最后一项，同时减少数组的<code class="calibre11">length</code>值，返回被删除的项。来看下面的例子：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let colors = new array();                 // 创建一个数组
let count = colors.push("red", "green");  // 推入两项
alert(count);                             // 2

count = colors.push("black");  // 再推入一项
alert(count);                  // 3

let item = colors.pop();       // 取得最后一项
alert(item);                   // black
alert(colors.length);          // 2</code></pre>
        <p class="calibre1">这里创建了一个当作栈来使用的数组（注意不需要任何额外的代码，<code class="calibre11">push()</code>和<code class="calibre11">pop()</code>都是数组的默认方法）。首先，使用<code class="calibre11">push()</code>方法把两个字符串推入数组末尾，将结果保存在变量<code class="calibre11">count</code>中（结果为<code class="calibre11">2</code>）。</p>
        <p class="calibre1">然后，再推入另一个值，再把结果保存在<code class="calibre11">count</code>中。因为现在数组中有3个元素，所以<code class="calibre11">push()</code>返回<code class="calibre11">3</code>。在调用<code class="calibre11">pop()</code>时，会返回数组的最后一项，即字符串<code class="calibre11">"black"</code>。此时数组还有两个元素。</p>
        <p class="calibre1">栈方法可以与数组的其他任何方法一起使用，如下例所示：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let colors = ["red", "blue"];
colors.push("brown");        // 再添加一项
colors[3] = "black";         // 添加一项
alert(colors.length);        // 4

let item = colors.pop();     // 取得最后一项
alert(item);                 // black</code></pre>
        <p class="calibre1">这里先初始化了包含两个字符串的数组，然后通过<code class="calibre11">push()</code>添加了第三个值，第四个值是通过直接在位置3上赋值添加的。调用<code class="calibre11">pop()</code>时，返回了字符串<code class="calibre11">"black"</code>，也就是最后添加到数组的字符串。</p>
        <h3 id="nav_point_122" class="calibre15">6.2.9 队列方法</h3>
        <p class="calibre1">就像栈是以LIFO形式限制访问的数据结构一样，队列以先进先出（FIFO，First-In-First-Out）形式限制访问。队列在列表末尾添加数据，但从列表开头获取数据。因为有了在数据末尾添加数据的<code class="calibre11">push()</code>方法，所以要模拟队列就差一个从数组开头取得数据的方法了。这个数组方法叫<code class="calibre11">shift()</code>，它会删除数组的第一项并返回它，然后数组长度减1。使用<code class="calibre11">shift()</code>和<code class="calibre11">push()</code>，可以把数组当成队列来使用：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let colors = new array();                 // 创建一个数组
let count = colors.push("red", "green");  // 推入两项
alert(count);                             // 2

count = colors.push("black"); // 再推入一项
alert(count);                 // 3

let item = colors.shift();  // 取得第一项
alert(item);                // red
alert(colors.length);       // 2</code></pre>
        <p class="calibre1">这个例子创建了一个数组并用<code class="calibre11">push()</code>方法推入三个值。加粗的那行代码使用<code class="calibre11">shift()</code>方法取得了数组的第一项，即<code class="calibre11">"red"</code>。删除这一项之后，<code class="calibre11">"green"</code>成为第一个元素，<code class="calibre11">"black"</code>成为第二个元素，数组此时就包含两项。</p>
        <p class="calibre1">ECMAScript也为数组提供了<code class="calibre11">unshift()</code>方法。顾名思义，<code class="calibre11">unshift()</code>就是执行跟<code class="calibre11">shift()</code>相反的操作：在数组开头添加任意多个值，然后返回新的数组长度。通过使用<code class="calibre11">unshift()</code>和<code class="calibre11">pop()</code>，可以在相反方向上模拟队列，即在数组开头添加新数据，在数组末尾取得数据，如下例所示：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let colors = new array();                    // 创建一个数组
let count = colors.unshift("red", "green");  // 从数组开头推入两项
alert(count);                                // 2

count = colors.unshift("black");  // 再推入一项
alert(count);                     // 3

let item = colors.pop();  // 取得最后一项
alert(item);              // green
alert(colors.length);     // 2</code></pre>
        <p class="calibre1">这里，先创建一个数组，再通过<code class="calibre11">unshift()</code>填充数组。首先，给数组添加<code class="calibre11">"red"</code>和<code class="calibre11">"green"</code>，再添加<code class="calibre11">"black"</code>，得到<code class="calibre11">["black","red","green"]</code>。调用<code class="calibre11">pop()</code>时，删除最后一项<code class="calibre11">"green"</code>并返回它。</p>
        <h3 id="nav_point_123" class="calibre15">6.2.10 排序方法</h3>
        <p class="calibre1">数组有两个方法可以用来对元素重新排序：<code class="calibre11">reverse()</code>和<code class="calibre11">sort()</code>。顾名思义，<code class="calibre11">reverse()</code>方法就是将数组元素反向排列。比如：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let values = [1, 2, 3, 4, 5];
values.reverse();
alert(values);  // 5,4,3,2,1</code></pre>
        <p class="calibre1">这里，数组<code class="calibre11">values</code>的初始状态为<code class="calibre11">[1,2,3,4,5]</code>。通过调用<code class="calibre11">reverse()</code>反向排序，得到了<code class="calibre11">[5,4,3,2,1]</code>。这个方法很直观，但不够灵活，所以才有了<code class="calibre11">sort()</code>方法。</p>
        <p class="calibre1">默认情况下，<code class="calibre11">sort()</code>会按照升序重新排列数组元素，即最小的值在前面，最大的值在后面。为此，<code class="calibre11">sort()</code>会在每一项上调用<code class="calibre11">String()</code>转型函数，然后比较字符串来决定顺序。即使数组的元素都是数值，也会先把数组转换为字符串再比较、排序。比如：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let values = [0, 1, 5, 10, 15];
values.sort();
alert(values);  // 0,1,10,15,5</code></pre>
        <p class="calibre1">一开始数组中数值的顺序是正确的，但调用<code class="calibre11">sort()</code>会按照这些数值的字符串形式重新排序。因此，即使5小于10，但字符串<code class="calibre11">"10"</code>在字符串<code class="calibre11">"5"</code>的前头，所以10还是会排到5前面。很明显，这在多数情况下都不是最合适的。为此，<code class="calibre11">sort()</code>方法可以接收一个<strong class="calibre2">比较函数</strong>，用于判断哪个值应该排在前面。</p>
        <p class="calibre1">比较函数接收两个参数，如果第一个参数应该排在第二个参数前面，就返回负值；如果两个参数相等，就返回0；如果第一个参数应该排在第二个参数后面，就返回正值。下面是使用简单比较函数的一个例子：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">function compare(value1, value2) {
  if (value1 &lt; value2) {
    return -1;
  } else if (value1 &gt; value2) {
    return 1;
  } else {
    return 0;
  }
}</code></pre>
        <p class="calibre1">这个比较函数可以适用于大多数数据类型，可以把它当作参数传给<code class="calibre11">sort()</code>方法，如下所示：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let values = [0, 1, 5, 10, 15];
values.sort(compare);
alert(values);  // 0,1,5,10,15</code></pre>
        <p class="calibre1">在给<code class="calibre11">sort()</code>方法传入比较函数后，数组中的数值在排序后保持了正确的顺序。当然，比较函数也可以产生降序效果，只要把返回值交换一下即可：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">function compare(value1, value2) {
  if (value1 &lt; value2) {
    return 1;
  } else if (value1 &gt; value2) {
    return -1;
  } else {
    return 0;
  }
}

let values = [0, 1, 5, 10, 15];
values.sort(compare);
alert(values);  // 15,10,5,1,0</code></pre>
        <p class="calibre1">此外，这个比较函数还可简写为一个箭头函数：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let values = [0, 1, 5, 10, 15];
values.sort((a, b) =&gt; a &lt; b ? 1 : a &gt; b ? -1 : 0);
alert(values); // 15,10,5,1,0</code></pre>
        <p class="calibre1">在这个修改版函数中，如果第一个值应该排在第二个值后面则返回1，如果第一个值应该排在第二个值前面则返回-1。交换这两个返回值之后，较大的值就会排在前头，数组就会按照降序排序。当然，如果只是想反转数组的顺序，<code class="calibre11">reverse()</code>更简单也更快。</p>
        <blockquote class="calibre13">
          <p class="calibre1">
            <strong class="calibre2">注意</strong>
            <code class="calibre11">reverse()</code>和<code class="calibre11">sort()</code>都返回调用它们的数组的引用。</p>
        </blockquote>
        <p class="calibre1">如果数组的元素是数值，或者是其<code class="calibre11">valueOf()</code>方法返回数值的对象（如<code class="calibre11">Date</code>对象），这个比较函数还可以写得更简单，因为这时可以直接用第二个值减去第一个值：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">function compare(value1, value2){
  return value2 - value1;
}</code></pre>
        <p class="calibre1">比较函数就是要返回小于0、0和大于0的数值，因此减法操作完全可以满足要求。</p>
        <h3 id="nav_point_124" class="calibre15">6.2.11 操作方法</h3>
        <p class="calibre1">对于数组中的元素，我们有很多操作方法。比如，<code class="calibre11">concat()</code>方法可以在现有数组全部元素基础上创建一个新数组。它首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组。如果传入一个或多个数组，则<code class="calibre11">concat()</code>会把这些数组的每一项都添加到结果数组。如果参数不是数组，则直接把它们添加到结果数组末尾。来看下面的例子：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let colors = ["red", "green", "blue"];
let colors2 = colors.concat("yellow", ["black", "brown"]);

console.log(colors);   // ["red", "green","blue"]
console.log(colors2);  // ["red", "green", "blue", "yellow", "black", "brown"]</code></pre>
        <p class="calibre1">这里先创建一个包含3个值的数组<code class="calibre11">colors</code>。然后<code class="calibre11">colors</code>调用<code class="calibre11">concat()</code>方法，传入字符串<code class="calibre11">"yellow"</code>和一个包含<code class="calibre11">"black"</code>和<code class="calibre11">"brown"</code>的数组。保存在<code class="calibre11">colors2</code>中的结果就是<code class="calibre11">["red", "green", "blue", "yellow", "black", "brown"]</code>。原始数组<code class="calibre11">colors</code>保持不变。</p>
        <p class="calibre1">打平数组参数的行为可以重写，方法是在参数数组上指定一个特殊的符号：<code class="calibre11">Symbol.isConcatSpreadable</code>。这个符号能够阻止<code class="calibre11">concat()</code>打平参数数组。相反，把这个值设置为<code class="calibre11">true</code>可以强制打平类数组对象：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let colors = ["red", "green", "blue"];
let newcolors = ["black", "brown"];
let morenewcolors = {
  [symbol.isconcatspreadable]: true,
  length: 2,
  0: "pink",
  1: "cyan"
};

newcolors[symbol.isconcatspreadable] = false;

// 强制不打平数组
let colors2 = colors.concat("yellow", newcolors);

// 强制打平类数组对象
let colors3 = colors.concat(morenewcolors);

console.log(colors);   // ["red", "green", "blue"]
console.log(colors2);  // ["red", "green", "blue", "yellow", ["black", "brown"]]
console.log(colors3);  // ["red", "green", "blue", "pink", "cyan"]</code></pre>
        <p class="calibre1">接下来，方法<code class="calibre11">slice()</code>用于创建一个包含原有数组中一个或多个元素的新数组。<code class="calibre11">slice()</code>方法可以接收一个或两个参数：返回元素的开始索引和结束索引。如果只有一个参数，则<code class="calibre11">slice()</code>会返回该索引到数组末尾的所有元素。如果有两个参数，则<code class="calibre11">slice()</code>返回从开始索引到结束索引对应的所有元素，其中不包含结束索引对应的元素。记住，这个操作不影响原始数组。来看下面的例子：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let colors = ["red", "green", "blue", "yellow", "purple"];
let colors2 = colors.slice(1);
let colors3 = colors.slice(1, 4);

alert(colors2);  // green,blue,yellow,purple
alert(colors3);  // green,blue,yellow</code></pre>
        <p class="calibre1">这里，<code class="calibre11">colors</code>数组一开始有5个元素。调用<code class="calibre11">slice()</code>传入1会得到包含4个元素的新数组。其中不包括<code class="calibre11">"red"</code>，这是因为拆分操作要从位置1开始，即从<code class="calibre11">"green"</code>开始。得到的<code class="calibre11">colors2</code>数组包含<code class="calibre11">"green"</code>、<code class="calibre11">"blue"</code>、<code class="calibre11">"yellow"</code>和<code class="calibre11">"purple"</code>。<code class="calibre11">colors3</code>数组是通过调用<code class="calibre11">slice()</code>并传入1和4得到的，即从位置1开始复制到位置3。因此<code class="calibre11">colors3</code>包含<code class="calibre11">"green"</code>、<code class="calibre11">"blue"</code>和<code class="calibre11">"yellow"</code>。</p>
        <blockquote class="calibre13">
          <p class="calibre1">
            <strong class="calibre2">注意</strong>
            如果<code class="calibre11">slice()</code>的参数有负值，那么就以数值长度加上这个负值的结果确定位置。比如，在包含5个元素的数组上调用<code class="calibre11">slice(-2,-1)</code>，就相当于调用<code class="calibre11">slice(3,4)</code>。如果结束位置小于开始位置，则返回空数组。</p>
        </blockquote>
        <p class="calibre1">或许最强大的数组方法就属<code class="calibre11">splice()</code>了，使用它的方式可以有很多种。<code class="calibre11">splice()</code>的主要目的是在数组中间插入元素，但有<code class="calibre11">3</code>种不同的方式使用这个方法。</p>
        <ul class="calibre10">
          <li class="di_1ji_wu_xu_lie_biao">
            <strong class="calibre2">删除</strong>。需要给<code class="calibre11">splice()</code>传2个参数：要删除的第一个元素的位置和要删除的元素数量。可以从数组中删除任意多个元素，比如<code class="calibre11">splice(0, 2)</code>会删除前两个元素。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <strong class="calibre2">插入</strong>。需要给<code class="calibre11">splice()</code>传3个参数：开始位置、0（要删除的元素数量）和要插入的元素，可以在数组中指定的位置插入元素。第三个参数之后还可以传第四个、第五个参数，乃至任意多个要插入的元素。比如，<code class="calibre11">splice(2, 0, "red", "green")</code>会从数组位置2开始插入字符串<code class="calibre11">"red"</code>和<code class="calibre11">"green"</code>。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <strong class="calibre2">替换</strong>。<code class="calibre11">splice()</code>在删除元素的同时可以在指定位置插入新元素，同样要传入3个参数：开始位置、要删除元素的数量和要插入的任意多个元素。要插入的元素数量不一定跟删除的元素数量一致。比如，<code class="calibre11">splice(2, 1, "red", "green")</code>会在位置2删除一个元素，然后从该位置开始向数组中插入<code class="calibre11">"red"</code>和<code class="calibre11">"green"</code>。</li>
        </ul>
        <p class="calibre1">
          <code class="calibre11">splice()</code>方法始终返回这样一个数组，它包含从数组中被删除的元素（如果没有删除元素，则返回空数组）。以下示例展示了上述3种使用方式。</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let colors = ["red", "green", "blue"];
let removed = colors.splice(0,1);  // 删除第一项
alert(colors);                     // green,blue
alert(removed);                    // red，只有一个元素的数组

removed = colors.splice(1, 0, "yellow", "orange");   // 在位置1插入两个元素
alert(colors);                                       // green,yellow,orange,blue
alert(removed);                                      // 空数组

removed = colors.splice(1, 1, "red", "purple");  // 插入两个值，删除一个元素
alert(colors);                                   // green,red,purple,orange,blue
alert(removed);                                  // yellow，只有一个元素的数组</code></pre>
        <p class="calibre1">这个例子中，<code class="calibre11">colors</code>数组一开始包含3个元素。第一次调用<code class="calibre11">splice()</code>时，只删除了第一项，<code class="calibre11">colors</code>中还有<code class="calibre11">"green"</code>和<code class="calibre11">"blue"</code>。第二次调用<code class="calibre11">slice()</code>时，在位置1插入两项，然后<code class="calibre11">colors</code>包含<code class="calibre11">"green"</code>、<code class="calibre11">"yellow"</code>、<code class="calibre11">"orange"</code>和<code class="calibre11">"blue"</code>。这次没删除任何项，因此返回空数组。最后一次调用<code class="calibre11">splice()</code>时删除了位置1上的一项，同时又插入了<code class="calibre11">"red"</code>和<code class="calibre11">"purple"</code>。最后，<code class="calibre11">colors</code>数组包含<code class="calibre11">"green"</code>、<code class="calibre11">"red"</code>、<code class="calibre11">"purple"</code>、<code class="calibre11">"orange"</code>和<code class="calibre11">"blue"</code>。</p>
        <h3 id="nav_point_125" class="calibre15">6.2.12 搜索和位置方法</h3>
        <p class="calibre1">ECMAScript提供两类搜索数组的方法：按严格相等搜索和按断言函数搜索。</p>
        <ol class="calibre16">
          <li value="1" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">严格相等</strong>
            </p>
            <p class="calibre1">ECMAScript提供了3个严格相等的搜索方法：<code class="calibre11">indexOf()</code>、<code class="calibre11">lastIndexOf()</code>和<code class="calibre11">includes()</code>。其中，前两个方法在所有版本中都可用，而第三个方法是ECMAScript 7新增的。这些方法都接收两个参数：要查找的元素和一个可选的起始搜索位置。<code class="calibre11">indexOf()</code>和<code class="calibre11">includes()</code>方法从数组前头（第一项）开始向后搜索，而<code class="calibre11">lastIndexOf()</code>从数组末尾（最后一项）开始向前搜索。</p>
            <p class="calibre1">
              <code class="calibre11">indexOf()</code>和<code class="calibre11">lastIndexOf()</code>都返回要查找的元素在数组中的位置，如果没找到则返回-1。<code class="calibre11">includes()</code>返回布尔值，表示是否至少找到一个与指定元素匹配的项。在比较第一个参数跟数组每一项时，会使用全等（<code class="calibre11">===</code>）比较，也就是说两项必须严格相等。下面来看一些例子：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];

alert(numbers.indexof(4));          // 3
alert(numbers.lastindexof(4));      // 5
alert(numbers.includes(4));         // true

alert(numbers.indexof(4, 4));       // 5
alert(numbers.lastindexof(4, 4));   // 3
alert(numbers.includes(4, 7));      // false

let person = { name: "nicholas" };
let people = [{ name: "nicholas" }];
let morepeople = [person];

alert(people.indexof(person));      // -1
alert(morepeople.indexof(person));  // 0
alert(people.includes(person));     // false
alert(morepeople.includes(person)); // true</code></pre>
            <p class="calibre1"></p>
          </li>
          <li value="2" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">断言函数</strong>
            </p>
            <p class="calibre1">ECMAScript也允许按照定义的断言函数搜索数组，每个索引都会调用这个函数。断言函数的返回值决定了相应索引的元素是否被认为匹配。</p>
            <p class="calibre1">断言函数接收3个参数：元素、索引和数组本身。其中元素是数组中当前搜索的元素，索引是当前元素的索引，而数组就是正在搜索的数组。断言函数返回真值，表示是否匹配。</p>
            <p class="calibre1">
              <code class="calibre11">find()</code>和<code class="calibre11">findIndex()</code>方法使用了断言函数。这两个方法都从数组的最小索引开始。<code class="calibre11">find()</code>返回第一个匹配的元素，<code class="calibre11">findIndex()</code>返回第一个匹配元素的索引。这两个方法也都接收第二个可选的参数，用于指定断言函数内部<code class="calibre11">this</code>的值。</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">const people = [
  {
    name: "matt",
    age: 27
  },
  {
    name: "nicholas",
    age: 29
  }
];

alert(people.find((element, index, array) =&gt; element.age &lt; 28));
// {name: "matt", age: 27}

alert(people.findindex((element, index, array) =&gt; element.age &lt; 28));
// 0</code></pre>
            <p class="calibre1">找到匹配项后，这两个方法都不再继续搜索。</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">const evens = [2, 4, 6];

// 找到匹配后，永远不会检查数组的最后一个元素
evens.find((element, index, array) =&gt; {
  console.log(element);
  console.log(index);
  console.log(array);
  return element === 4;
});
// 2
// 0
// [2, 4, 6]
// 4
// 1
// [2, 4, 6]</code></pre>
          </li>
        </ol>
        <h3 id="nav_point_126" class="calibre15">6.2.13 迭代方法</h3>
        <p class="calibre1">ECMAScript为数组定义了5个迭代方法。每个方法接收两个参数：以每一项为参数运行的函数，以及可选的作为函数运行上下文的作用域对象（影响函数中<code class="calibre11">this</code>的值）。传给每个方法的函数接收3个参数：数组元素、元素索引和数组本身。因具体方法而异，这个函数的执行结果可能会也可能不会影响方法的返回值。数组的5个迭代方法如下。</p>
        <ul class="calibre10">
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">every()</code>：对数组每一项都运行传入的函数，如果对每一项函数都返回<code class="calibre11">true</code>，则这个方法返回<code class="calibre11">true</code>。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">filter()</code>：对数组每一项都运行传入的函数，函数返回<code class="calibre11">true</code>的项会组成数组之后返回。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">forEach()</code>：对数组每一项都运行传入的函数，没有返回值。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">map()</code>：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">some()</code>：对数组每一项都运行传入的函数，如果有一项函数返回<code class="calibre11">true</code>，则这个方法返回<code class="calibre11">true</code>。</li>
        </ul>
        <p class="calibre1">这些方法都不改变调用它们的数组。</p>
        <p class="calibre1">在这些方法中，<code class="calibre11">every()</code>和<code class="calibre11">some()</code>是最相似的，都是从数组中搜索符合某个条件的元素。对<code class="calibre11">every()</code>来说，传入的函数必须对每一项都返回<code class="calibre11">true</code>，它才会返回<code class="calibre11">true</code>；否则，它就返回<code class="calibre11">false</code>。而对<code class="calibre11">some()</code>来说，只要有一项让传入的函数返回<code class="calibre11">true</code>，它就会返回<code class="calibre11">true</code>。下面是一个例子：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];

let everyresult = numbers.every((item, index, array) =&gt; item &gt; 2);
alert(everyresult);  // false

let someresult = numbers.some((item, index, array) =&gt; item &gt; 2);
alert(someresult);   // true</code></pre>
        <p class="calibre1">以上代码调用了<code class="calibre11">every()</code>和<code class="calibre11">some()</code>，传入的函数都是在给定项大于2时返回<code class="calibre11">true</code>。<code class="calibre11">every()</code>返回<code class="calibre11">false</code>是因为并不是每一项都能达到要求。而<code class="calibre11">some()</code>返回<code class="calibre11">true</code>是因为至少有一项满足条件。</p>
        <p class="calibre1">下面再看一看<code class="calibre11">filter()</code>方法。这个方法基于给定的函数来决定某一项是否应该包含在它返回的数组中。比如，要返回一个所有数值都大于2的数组，可以使用如下代码：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];

let filterresult = numbers.filter((item, index, array) =&gt; item &gt; 2);
alert(filterresult);  // 3,4,5,4,3</code></pre>
        <p class="calibre1">这里，调用<code class="calibre11">filter()</code>返回的数组包含<code class="calibre11">3</code>、<code class="calibre11">4</code>、<code class="calibre11">5</code>、<code class="calibre11">4</code>、<code class="calibre11">3</code>，因为只有对这些项传入的函数才返回<code class="calibre11">true</code>。这个方法非常适合从数组中筛选满足给定条件的元素。</p>
        <p class="calibre1">接下来<code class="calibre11">map()</code>方法也会返回一个数组。这个数组的每一项都是对原始数组中同样位置的元素运行传入函数而返回的结果。例如，可以将一个数组中的每一项都乘以2，并返回包含所有结果的数组，如下所示：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];

let mapresult = numbers.map((item, index, array) =&gt; item * 2);

alert(mapresult);  // 2,4,6,8,10,8,6,4,2</code></pre>
        <p class="calibre1">以上代码返回了一个数组，包含原始数组中每个值乘以2的结果。这个方法非常适合创建一个与原始数组元素一一对应的新数组。</p>
        <p class="calibre1">最后，再来看一看<code class="calibre11">forEach()</code>方法。这个方法只会对每一项运行传入的函数，没有返回值。本质上，<code class="calibre11">forEach()</code>方法相当于使用<code class="calibre11">for</code>循环遍历数组。比如：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];

numbers.foreach((item, index, array) =&gt; {
  // 执行某些操作
});</code></pre>
        <p class="calibre1">数组的这些迭代方法通过执行不同操作方便了对数组的处理。</p>
        <h3 id="nav_point_127" class="calibre15">6.2.14 归并方法</h3>
        <p class="calibre1">ECMAScript为数组提供了两个归并方法：<code class="calibre11">reduce()</code>和<code class="calibre11">reduceRight()</code>。这两个方法都会迭代数组的所有项，并在此基础上构建一个最终返回值。<code class="calibre11">reduce()</code>方法从数组第一项开始遍历到最后一项。而<code class="calibre11">reduceRight()</code>从最后一项开始遍历至第一项。</p>
        <p class="calibre1">这两个方法都接收两个参数：对每一项都会运行的归并函数，以及可选的以之为归并起点的初始值。传给<code class="calibre11">reduce()</code>和<code class="calibre11">reduceRight()</code>的函数接收4个参数：上一个归并值、当前项、当前项的索引和数组本身。这个函数返回的任何值都会作为下一次调用同一个函数的第一个参数。如果没有给这两个方法传入可选的第二个参数（作为归并起点值），则第一次迭代将从数组的第二项开始，因此传给归并函数的第一个参数是数组的第一项，第二个参数是数组的第二项。</p>
        <p class="calibre1">可以使用<code class="calibre11">reduce()</code>函数执行累加数组中所有数值的操作，比如：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let values = [1, 2, 3, 4, 5];
let sum = values.reduce((prev, cur, index, array) =&gt; prev + cur);

alert(sum);  // 15</code></pre>
        <p class="calibre1">第一次执行归并函数时，<code class="calibre11">prev</code>是1，<code class="calibre11">cur</code>是2。第二次执行时，<code class="calibre11">prev</code>是3（1 + 2），<code class="calibre11">cur</code>是3（数组第三项）。如此递进，直到把所有项都遍历一次，最后返回归并结果。</p>
        <p class="calibre1">
          <code class="calibre11">reduceRight()</code>方法与之类似，只是方向相反。来看下面的例子：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let values = [1, 2, 3, 4, 5];
let sum = values.reduceright(function(prev, cur, index, array){
  return prev + cur;
});
alert(sum); // 15</code></pre>
        <p class="calibre1">在这里，第一次调用归并函数时<code class="calibre11">prev</code>是5，而<code class="calibre11">cur</code>是4。当然，最终结果相同，因为归并操作都是简单的加法。</p>
        <p class="calibre1">究竟是使用<code class="calibre11">reduce()</code>还是<code class="calibre11">reduceRight()</code>，只取决于遍历数组元素的方向。除此之外，这两个方法没什么区别。</p>

      </div>

      <div class="calibreToc">
        <h2>
          <a href="../../54m0dfqx.html">Table of contents
          </a>
        </h2>
        <div>
          <ul>
            <li>
              <a href="part0002.html#nav_point_0">版权声明</a>
            </li>
            <li>
              <a href="part0003.html#nav_point_1">献词</a>
            </li>
            <li>
              <a href="part0004.html#nav_point_2">译者序</a>
            </li>
            <li>
              <a href="part0005.html#nav_point_3">序</a>
            </li>
            <li>
              <a href="part0006.html#nav_point_4">前言</a>
            </li>
            <li>
              <a href="part0012.html#nav_point_10">致谢</a>
            </li>
            <li>
              <a href="part0013.html#nav_point_11">第 1 章 什么是JavaScript</a>
            </li>
            <li>
              <a href="part0018.html#nav_point_19">第 2 章 HTML中的JavaScript</a>
            </li>
            <li>
              <a href="part0024.html#nav_point_31">第 3 章 语言基础</a>
            </li>
            <li>
              <a href="part0033.html#nav_point_78">第 4 章 变量、作用域与内存</a>
            </li>
            <li>
              <a href="part0038.html#nav_point_93">第 5 章 基本引用类型</a>
            </li>
            <li>
              <a href="part0044.html#nav_point_111">第 6 章 集合引用类型</a>
            </li>
            <li>
              <a href="part0054.html#nav_point_153">第 7 章 迭代器与生成器</a>
            </li>
            <li>
              <a href="part0059.html#nav_point_166">第 8 章 对象、类与面向对象编程</a>
            </li>
            <li>
              <a href="part0065.html#nav_point_194">第 9 章 代理与反射</a>
            </li>
            <li>
              <a href="part0070.html#nav_point_225">第 10 章 函数</a>
            </li>
            <li>
              <a href="part0088.html#nav_point_258">第 11 章 期约与异步函数</a>
            </li>
            <li>
              <a href="part0093.html#nav_point_273">第 12 章 BOM</a>
            </li>
            <li>
              <a href="part0100.html#nav_point_294">第 13 章 客户端检测</a>
            </li>
            <li>
              <a href="part0105.html#nav_point_306">第 14 章 DOM</a>
            </li>
            <li>
              <a href="part0110.html#nav_point_328">第 15 章 DOM扩展</a>
            </li>
            <li>
              <a href="part0116.html#nav_point_348">第 16 章 DOM2和DOM3</a>
            </li>
            <li>
              <a href="part0122.html#nav_point_370">第 17 章 事件</a>
            </li>
            <li>
              <a href="part0130.html#nav_point_403">第 18 章 动画与Canvas图形</a>
            </li>
            <li>
              <a href="part0136.html#nav_point_428">第 19 章 表单脚本</a>
            </li>
            <li>
              <a href="part0143.html#nav_point_450">第 20 章 JavaScript API</a>
            </li>
            <li>
              <a href="part0157.html#nav_point_500">第 21 章 错误处理与调试</a>
            </li>
            <li>
              <a href="part0163.html#nav_point_526">第 22 章 处理XML</a>
            </li>
            <li>
              <a href="part0168.html#nav_point_542">第 23 章 JSON</a>
            </li>
            <li>
              <a href="part0172.html#nav_point_552">第 24 章 网络请求与远程资源</a>
            </li>
            <li>
              <a href="part0182.html#nav_point_582">第 25 章 客户端存储</a>
            </li>
            <li>
              <a href="part0187.html#nav_point_607">第 26 章 模块</a>
            </li>
            <li>
              <a href="part0193.html#nav_point_633">第 27 章 工作者线程</a>
            </li>
            <li>
              <a href="part0199.html#nav_point_667">第 28 章 最佳实践</a>
            </li>
            <li>
              <a href="part0204.html#nav_point_683">附录 A ES2018和ES2019</a>
            </li>
            <li>
              <a href="part0215.html#nav_point_708">附录 B 严格模式</a>
            </li>
            <li>
              <a href="part0223.html#nav_point_719">附录 C JavaScript库和框架</a>
            </li>
            <li>
              <a href="part0227.html#nav_point_741">附录 D JavaScript工具</a>
            </li>
            <li>
              <a href="part0239.html#nav_point_800">作者简介</a>
            </li>
          </ul>
        </div>

      </div>

      <div class="calibreEbNav">

        <a href="part0045.html" class="calibreAPrev">上一页
        </a>

        <a href="../../54m0dfqx.html" class="calibreAHome">首页
        </a>

        <a href="part0047.html" class="calibreANext">下一页
        </a>

      </div>

    </div>

    <script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6487844781006261" crossorigin="anonymous"></script>
  </body>
</html>