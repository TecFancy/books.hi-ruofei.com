<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>

    <title>JavaScript高级程序设计（第4版）</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" type="text/css" href="../stylesheet.css"/>
    <link rel="stylesheet" type="text/css" href="../page_styles.css"/>

    <link href="../calibreHtmlOutBasicCss.css" type="text/css" rel="stylesheet"/>

  </head>
  <body>

    <div class="calibreMeta">
      <div class="calibreMetaTitle">

        <h1>
          <a href="../../54m0dfqx.html">JavaScript高级程序设计（第4版）
          </a>
        </h1>

      </div>
      <div class="calibreMetaAuthor">
        [美] 马特 • 弗里斯比

      </div>
    </div>

    <div class="calibreMain">

      <div class="calibreEbookContent">

        <div class="calibreEbNavTop">

          <a href="part0125.html" class="calibreAPrev">上一页
          </a>

          <a href="part0127.html" class="calibreANext">下一页
          </a>

        </div>

        <h2 id="nav_point_385" class="calibre9">17.4 事件类型</h2>
        <p class="calibre1">Web浏览器中可以发生很多种事件。如前所述，所发生事件的类型决定了事件对象中会保存什么信息。DOM3 Events定义了如下事件类型。</p>
        <ul class="calibre10">
          <li class="di_1ji_wu_xu_lie_biao">
            <strong class="calibre2">用户界面事件</strong>（<code class="calibre11">UIEvent</code>）：涉及与BOM交互的通用浏览器事件。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <strong class="calibre2">焦点事件</strong>（<code class="calibre11">FocusEvent</code>）：在元素获得和失去焦点时触发。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <strong class="calibre2">鼠标事件</strong>（<code class="calibre11">MouseEvent</code>）：使用鼠标在页面上执行某些操作时触发。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <strong class="calibre2">滚轮事件</strong>（<code class="calibre11">WheelEvent</code>）：使用鼠标滚轮（或类似设备）时触发。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <strong class="calibre2">输入事件</strong>（<code class="calibre11">InputEvent</code>）：向文档中输入文本时触发。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <strong class="calibre2">键盘事件</strong>（<code class="calibre11">KeyboardEvent</code>）：使用键盘在页面上执行某些操作时触发。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <strong class="calibre2">合成事件</strong>（<code class="calibre11">CompositionEvent</code>）：在使用某种IME（Input Method Editor，输入法编辑器）输入字符时触发。</li>
        </ul>
        <p class="calibre1">除了这些事件类型之外，HTML5还定义了另一组事件，而浏览器通常在DOM和BOM上实现专有事件。这些专有事件基本上都是根据开发者需求而不是按照规范增加的，因此不同浏览器的实现可能不同。</p>
        <p class="calibre1">DOM3 Events在DOM2 Events基础上重新定义了事件，并增加了新的事件类型。所有主流浏览器都支持DOM2 Events和DOM3 Events。</p>
        <h3 id="nav_point_386" class="calibre15">17.4.1 用户界面事件</h3>
        <p class="calibre1">用户界面事件或UI事件不一定跟用户操作有关。这类事件在DOM规范出现之前就已经以某种形式存在了，保留它们是为了向后兼容。UI事件主要有以下几种。</p>
        <ul class="calibre10">
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">DOMActivate</code>：元素被用户通过鼠标或键盘操作激活时触发（比<code class="calibre11">click</code>或<code class="calibre11">keydown</code>更通用）。这个事件在DOM3 Events中已经废弃。因为浏览器实现之间存在差异，所以不要使用它。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">load</code>：在<code class="calibre11">window</code>上当页面加载完成后触发，在窗套（<code class="calibre11">&lt;frameset&gt;</code>）上当所有窗格（<code class="calibre11">&lt;frame&gt;</code>）都加载完成后触发，在<code class="calibre11">&lt;img&gt;</code>元素上当图片加载完成后触发，在<code class="calibre11">&lt;object&gt;</code>元素上当相应对象加载完成后触发。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">unload</code>：在<code class="calibre11">window</code>上当页面完全卸载后触发，在窗套上当所有窗格都卸载完成后触发，在<code class="calibre11">&lt;object&gt;</code>元素上当相应对象卸载完成后触发。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">abort</code>：在<code class="calibre11">&lt;object&gt;</code>元素上当相应对象加载完成前被用户提前终止下载时触发。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">error</code>：在<code class="calibre11">window</code>上当JavaScript报错时触发，在<code class="calibre11">&lt;img&gt;</code>元素上当无法加载指定图片时触发，在<code class="calibre11">&lt;object&gt;</code>元素上当无法加载相应对象时触发，在窗套上当一个或多个窗格无法完成加载时触发。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">select</code>：在文本框（<code class="calibre11">&lt;input&gt;</code>或<code class="calibre11">textarea</code>）上当用户选择了一个或多个字符时触发。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">resize</code>：在<code class="calibre11">window</code>或窗格上当窗口或窗格被缩放时触发。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">scroll</code>：当用户滚动包含滚动条的元素时在元素上触发。<code class="calibre11">&lt;body&gt;</code>元素包含已加载页面的滚动条。</li>
        </ul>
        <p class="calibre1">大多数HTML事件与<code class="calibre11">window</code>对象和表单控件有关。</p>
        <p class="calibre1">除了<code class="calibre11">DOMActivate</code>，这些事件在DOM2 Events中都被归为HTML Events（<code class="calibre11">DOMActivate</code>在DOM2中仍旧是UI事件）。</p>
        <ol class="calibre16">
          <li value="1" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">
                <code class="calibre11">load</code>事件</strong>
            </p>
            <p class="calibre1">
              <code class="calibre11">load</code>事件可能是JavaScript中最常用的事件。在<code class="calibre11">window</code>对象上，<code class="calibre11">load</code>事件会在整个页面（包括所有外部资源如图片、JavaScript文件和CSS文件）加载完成后触发。可以通过两种方式指定<code class="calibre11">load</code>事件处理程序。第一种是JavaScript方式，如下所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">window.addeventlistener("load", (event) =&gt; {
  console.log("loaded!");
});</code></pre>
            <p class="calibre1">这是使用<code class="calibre11">addEventListener()</code>方法来指定事件处理程序。与其他事件一样，事件处理程序会接收到一个<code class="calibre11">event</code>对象。这个<code class="calibre11">event</code>对象并没有提供关于这种类型事件的额外信息，虽然在DOM合规的浏览器中，<code class="calibre11">event.target</code>会被设置为<code class="calibre11">document</code>，但在IE8之前的版本中，不会设置这个对象的<code class="calibre11">srcElement</code>属性。</p>
            <p class="calibre1">第二种指定<code class="calibre11">load</code>事件处理程序的方式是向<code class="calibre11">&lt;body&gt;</code>元素添加<code class="calibre11">onload</code>属性，如下所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;load event example&lt;/title&gt;
&lt;/head&gt;
&lt;body onload="console.log('loaded!')"&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre>
            <p class="calibre1">一般来说，任何在<code class="calibre11">window</code>上发生的事件，都可以通过给<code class="calibre11">&lt;body&gt;</code>元素上对应的属性赋值来指定，这是因为HTML中没有<code class="calibre11">window</code>元素。这实际上是为了保证向后兼容的一个策略，但在所有浏览器中都能得到很好的支持。实际开发中要尽量使用JavaScript方式。</p>
            <blockquote class="calibre13">
              <p class="calibre1">
                <strong class="calibre2">注意</strong>
                根据DOM2 Events，<code class="calibre11">load</code>事件应该在<code class="calibre11">document</code>而非<code class="calibre11">window</code>上触发。可是为了向后兼容，所有浏览器都在<code class="calibre11">window</code>上实现了<code class="calibre11">load</code>事件。</p>
            </blockquote>
            <p class="calibre1">图片上也会触发<code class="calibre11">load</code>事件，包括DOM中的图片和非DOM中的图片。可以在HTML中直接给<code class="calibre11">&lt;img&gt;</code>元素的<code class="calibre11">onload</code>属性指定事件处理程序，比如：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">&lt;img src="smile.gif" onload="console.log('image loaded.')"&gt;</code></pre>
            <p class="calibre1">这个例子会在图片加载完成后输出一条消息。同样，使用JavaScript也可以为图片指定事件处理程序：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let image = document.getelementbyid("myimage");
image.addeventlistener("load", (event) =&gt; {
  console.log(event.target.src);
});</code></pre>
            <p class="calibre1">这里使用JavaScript为图片指定了<code class="calibre11">load</code>事件处理程序。处理程序会接收到<code class="calibre11">event</code>对象，虽然这个对象上没有多少有用的信息。这个事件的目标是<code class="calibre11">&lt;img&gt;</code>元素，因此可以直接从<code class="calibre11">event.target.src</code>属性中取得图片地址并打印出来。</p>
            <p class="calibre1">在通过JavaScript创建新<code class="calibre11">&lt;img&gt;</code>元素时，也可以给这个元素指定一个在加载完成后执行的事件处理程序。在这里，关键是要在赋值<code class="calibre11">src</code>属性前指定事件处理程序，如下所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">window.addeventlistener("load", () =&gt; {
  let image = document.createelement("img");
  image.addeventlistener("load", (event) =&gt; {
    console.log(event.target.src);
  });
  document.body.appendchild(image);
  image.src = "smile.gif";
});</code></pre>
            <p class="calibre1">这个例子首先为<code class="calibre11">window</code>指定了一个<code class="calibre11">load</code>事件处理程序。因为示例涉及向DOM中添加新元素，所以必须确保页面已经加载完成。如果在页面加载完成之前操作<code class="calibre11">document.body</code>，则会导致错误。然后，代码创建了一个新的<code class="calibre11">&lt;img&gt;</code>元素，并为这个元素设置了<code class="calibre11">load</code>事件处理程序。最后，才把这个元素添加到文档中并指定了其<code class="calibre11">src</code>属性。注意，下载图片并不一定要把<code class="calibre11">&lt;img&gt;</code>元素添加到文档，只要给它设置了<code class="calibre11">src</code>属性就会立即开始下载。</p>
            <p class="calibre1">同样的技术也适用于DOM0的<code class="calibre11">Image</code>对象。在DOM出现之前，客户端都使用<code class="calibre11">Image</code>对象预先加载图片。可以像使用前面（通过<code class="calibre11">createElement()</code>方法创建）的<code class="calibre11">&lt;img&gt;</code>元素一样使用<code class="calibre11">Image</code>对象，只是不能把后者添加到DOM树。下面的例子使用新<code class="calibre11">Image</code>对象实现了图片预加载：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">window.addeventlistener("load", () =&gt; {
  let image = new image();
  image.addeventlistener("load", (event) =&gt; {
    console.log("image loaded!");
  });
  image.src = "smile.gif";
});</code></pre>
            <p class="calibre1">这里调用<code class="calibre11">Image</code>构造函数创建了一个新图片，并给它设置了事件处理程序。有些浏览器会把<code class="calibre11">Image</code>对象实现为<code class="calibre11">&lt;img&gt;</code>元素，但并非所有浏览器都如此。所以最好把它们看成是两个东西。</p>
            <blockquote class="calibre13">
              <p class="calibre1">
                <strong class="calibre2">注意</strong>
                在IE8及早期版本中，如果图片没有添加到DOM文档中，则<code class="calibre11">load</code>事件发生时不会生成<code class="calibre11">event</code>对象。对未被添加到文档中的<code class="calibre11">&lt;img&gt;</code>元素以及<code class="calibre11">Image</code>对象来说都是这样。IE9修复了这个问题。</p>
            </blockquote>
            <p class="calibre1">还有一些元素也以非标准的方式支持<code class="calibre11">load</code>事件。<code class="calibre11">&lt;script&gt;</code>元素会在JavaScript文件加载完成后触发<code class="calibre11">load</code>事件，从而可以动态检测。与图片不同，要下载JavaScript文件必须同时指定<code class="calibre11">src</code>属性并把<code class="calibre11">&lt;script&gt;</code>元素添加到文档中。因此指定事件处理程序和指定<code class="calibre11">src</code>属性的顺序在这里并不重要。下面的代码展示了如何给动态创建的<code class="calibre11">&lt;script&gt;</code>元素指定事件处理程序：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">window.addeventlistener("load", () =&gt; {
  let script = document.createelement("script");
  script.addeventlistener("load", (event) =&gt; {
    console.log("loaded");
  });
  script.src = "example.js";
  document.body.appendchild(script);
});</code></pre>
            <p class="calibre1">这里<code class="calibre11">event</code>对象的<code class="calibre11">target</code>属性在大多数浏览器中是<code class="calibre11">&lt;script&gt;</code>节点。IE8及更早版本不支持<code class="calibre11">&lt;script&gt;</code>元素触发<code class="calibre11">load</code>事件。</p>
            <p class="calibre1">IE和Opera支持<code class="calibre11">&lt;link&gt;</code>元素触发<code class="calibre11">load</code>事件，因而支持动态检测样式表是否加载完成。下面的代码展示了如何设置这样的事件处理程序：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">window.addeventlistener("load", () =&gt; {
  let link = document.createelement("link");
  link.type = "text/css";
  link.rel= "stylesheet";
  link.addeventlistener("load", (event) =&gt; {
    console.log("css loaded");
  });
  link.href = "example.css";
  document.getelementsbytagname("head")[0].appendchild(link);
});</code></pre>
            <p class="calibre1">与<code class="calibre11">&lt;script&gt;</code>节点一样，在指定<code class="calibre11">href</code>属性并把<code class="calibre11">&lt;link&gt;</code>节点添加到文档之前不会下载样式表。<br class="calibre4"/>
            </p>
          </li>
          <li value="2" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">
                <code class="calibre11">unload</code>事件</strong>
            </p>
            <p class="calibre1">与<code class="calibre11">load</code>事件相对的是<code class="calibre11">unload</code>事件，<code class="calibre11">unload</code>事件会在文档卸载完成后触发。<code class="calibre11">unload</code>事件一般是在从一个页面导航到另一个页面时触发，最常用于清理引用，以避免内存泄漏。与<code class="calibre11">load</code>事件类似，<code class="calibre11">unload</code>事件处理程序也有两种指定方式。第一种是JavaScript方式，如下所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">window.addeventlistener("unload", (event) =&gt; {
  console.log("unloaded!");
});</code></pre>
            <p class="calibre1">这个事件生成的<code class="calibre11">event</code>对象在DOM合规的浏览器中只有<code class="calibre11">target</code>属性（值为<code class="calibre11">document</code>）。IE8及更早版本在这个事件上不提供<code class="calibre11">srcElement</code>属性。</p>
            <p class="calibre1">第二种方式与<code class="calibre11">load</code>事件类似，就是给<code class="calibre11">&lt;body&gt;</code>元素添加<code class="calibre11">onunload</code>属性：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;unload event example&lt;/title&gt;
&lt;/head&gt;
&lt;body onunload="console.log('unloaded!')"&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre>
            <p class="calibre1">无论使用何种方式，都要注意事件处理程序中的代码。因为<code class="calibre11">unload</code>事件是在页面卸载完成后触发的，所以不能使用页面加载后才有的对象。此时要访问DOM或修改页面外观都会导致错误。</p>
            <blockquote class="calibre13">
              <p class="calibre1">
                <strong class="calibre2">注意</strong>
                根据DOM2 Events，<code class="calibre11">unload</code>事件应该在<code class="calibre11">&lt;body&gt;</code>而非<code class="calibre11">window</code>上触发。可是为了向后兼容，所有浏览器都在<code class="calibre11">window</code>上实现了<code class="calibre11">unload</code>事件。</p>
            </blockquote>
            <p class="calibre1"></p>
          </li>
          <li value="3" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">
                <code class="calibre11">resize</code>事件</strong>
            </p>
            <p class="calibre1">当浏览器窗口被缩放到新高度或宽度时，会触发<code class="calibre11">resize</code>事件。这个事件在<code class="calibre11">window</code>上触发，因此可以通过JavaScript在<code class="calibre11">window</code>上或者为<code class="calibre11">&lt;body&gt;</code>元素添加<code class="calibre11">onresize</code>属性来指定事件处理程序。优先使用JavaScript方式：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">window.addeventlistener("resize", (event) =&gt; {
  console.log("resized");
});</code></pre>
            <p class="calibre1">类似于其他在<code class="calibre11">window</code>上发生的事件，此时会生成<code class="calibre11">event</code>对象，且这个对象的<code class="calibre11">target</code>属性在DOM合规的浏览器中是<code class="calibre11">document</code>。而IE8及更早版本中并没有提供可用的属性。</p>
            <p class="calibre1">不同浏览器在决定何时触发<code class="calibre11">resize</code>事件上存在重要差异。IE、Safari、Chrome和Opera会在窗口缩放超过1像素时触发<code class="calibre11">resize</code>事件，然后随着用户缩放浏览器窗口不断触发。Firefox早期版本则只在用户停止缩放浏览器窗口时触发<code class="calibre11">resize</code>事件。无论如何，都应该避免在这个事件处理程序中执行过多计算。否则可能由于执行过于频繁而导致浏览器响应明确变慢。</p>
            <blockquote class="calibre13">
              <p class="calibre1">
                <strong class="calibre2">注意</strong>
                浏览器窗口在最大化和最小化时也会触发<code class="calibre11">resize</code>事件。</p>
            </blockquote>
            <p class="calibre1"></p>
          </li>
          <li value="4" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">
                <code class="calibre11">scroll</code>事件</strong>
            </p>
            <p class="calibre1">虽然<code class="calibre11">scroll</code>事件发生在<code class="calibre11">window</code>上，但实际上反映的是页面中相应元素的变化。在混杂模式下，可以通过<code class="calibre11">&lt;body&gt;</code>元素检测<code class="calibre11">scrollLeft</code>和<code class="calibre11">scrollTop</code>属性的变化。而在标准模式下，这些变化在除早期版的Safari之外的所有浏览器中都发生在<code class="calibre11">&lt;html&gt;</code>元素上（早期版的Safari在<code class="calibre11">&lt;body&gt;</code>上跟踪滚动位置）。下面的代码演示了如何处理这些差异：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">window.addeventlistener("scroll", (event) =&gt; {
  if (document.compatmode == "css1compat") {
    console.log(document.documentelement.scrolltop);
  } else {
    console.log(document.body.scrolltop);
  }
});</code></pre>
            <p class="calibre1">以上事件处理程序会在页面滚动时输出垂直方向上滚动的距离，而且适用于不同渲染模式。因为Safari 3.1之前不支持<code class="calibre11">document.compatMode</code>，所以早期版本会走第二个分支。</p>
            <p class="calibre1">类似于<code class="calibre11">resize</code>，<code class="calibre11">scroll</code>事件也会随着文档滚动而重复触发，因此最好保持事件处理程序的代码尽可能简单。</p>
          </li>
        </ol>
        <h3 id="nav_point_387" class="calibre15">17.4.2 焦点事件</h3>
        <p class="calibre1">焦点事件在页面元素获得或失去焦点时触发。这些事件可以与<code class="calibre11">document.hasFocus()</code>和<code class="calibre11">document.activeElement</code>一起为开发者提供用户在页面中导航的信息。焦点事件有以下6种。</p>
        <ul class="calibre10">
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">blur</code>：当元素失去焦点时触发。这个事件不冒泡，所有浏览器都支持。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">DOMFocusIn</code>：当元素获得焦点时触发。这个事件是<code class="calibre11">focus</code>的冒泡版。Opera是唯一支持这个事件的主流浏览器。DOM3 Events废弃了<code class="calibre11">DOMFocusIn</code>，推荐<code class="calibre11">focusin</code>。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">DOMFocusOut</code>：当元素失去焦点时触发。这个事件是<code class="calibre11">blur</code>的通用版。Opera是唯一支持这个事件的主流浏览器。DOM3 Events废弃了<code class="calibre11">DOMFocusOut</code>，推荐<code class="calibre11">focusout</code>。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">focus</code>：当元素获得焦点时触发。这个事件不冒泡，所有浏览器都支持。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">focusin</code>：当元素获得焦点时触发。这个事件是<code class="calibre11">focus</code>的冒泡版。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">focusout</code>：当元素失去焦点时触发。这个事件是<code class="calibre11">blur</code>的通用版。</li>
        </ul>
        <p class="calibre1">焦点事件中的两个主要事件是<code class="calibre11">focus</code>和<code class="calibre11">blur</code>，这两个事件在JavaScript早期就得到了浏览器支持。它们最大的问题是不冒泡。这导致IE后来又增加了<code class="calibre11">focusin</code>和<code class="calibre11">focusout</code>，Opera又增加了<code class="calibre11">DOMFocusIn</code>和<code class="calibre11">DOMFocusOut</code>。IE新增的这两个事件已经被DOM3 Events标准化。</p>
        <p class="calibre1">当焦点从页面中的一个元素移到另一个元素上时，会依次发生如下事件。</p>
        <p class="calibre1">(1)
          <code class="calibre11">focuscout</code>在失去焦点的元素上触发。</p>
        <p class="calibre1">(2)
          <code class="calibre11">focusin</code>在获得焦点的元素上触发。</p>
        <p class="calibre1">(3)
          <code class="calibre11">blur</code>在失去焦点的元素上触发。</p>
        <p class="calibre1">(4)
          <code class="calibre11">DOMFocusOut</code>在失去焦点的元素上触发。</p>
        <p class="calibre1">(5)
          <code class="calibre11">focus</code>在获得焦点的元素上触发。</p>
        <p class="calibre1">(6)
          <code class="calibre11">DOMFocusIn</code>在获得焦点的元素上触发。</p>
        <p class="calibre1">其中，<code class="calibre11">blur</code>、<code class="calibre11">DOMFocusOut</code>和<code class="calibre11">focusout</code>的事件目标是失去焦点的元素，而<code class="calibre11">focus</code>、<code class="calibre11">DOMFocusIn</code>和<code class="calibre11">focusin</code>的事件目标是获得焦点的元素。</p>
        <h3 id="nav_point_388" class="calibre15">17.4.3 鼠标和滚轮事件</h3>
        <p class="calibre1">
          <strong class="calibre2">鼠标事件</strong>是Web开发中最常用的一组事件，这是因为鼠标是用户的主要定位设备。DOM3 Events定义了9种鼠标事件。</p>
        <ul class="calibre10">
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">click</code>：在用户单击鼠标主键（通常是左键）或按键盘回车键时触发。这主要是基于无障碍的考虑，让键盘和鼠标都可以触发<code class="calibre11">onclick</code>事件处理程序。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">dblclick</code>：在用户双击鼠标主键（通常是左键）时触发。这个事件不是在DOM2 Events中定义的，但得到了很好的支持，DOM3 Events将其进行了标准化。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">mousedown</code>：在用户按下任意鼠标键时触发。这个事件不能通过键盘触发。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">mouseenter</code>：在用户把鼠标光标从元素外部移到元素内部时触发。这个事件不冒泡，也不会在光标经过后代元素时触发。<code class="calibre11">mouseenter</code>事件不是在DOM2 Events中定义的，而是DOM3 Events中新增的事件。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">mouseleave</code>：在用户把鼠标光标从元素内部移到元素外部时触发。这个事件不冒泡，也不会在光标经过后代元素时触发。<code class="calibre11">mouseleave</code>事件不是在DOM2 Events中定义的，而是DOM3 Events中新增的事件。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">mousemove</code>：在鼠标光标在元素上移动时反复触发。这个事件不能通过键盘触发。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">mouseout</code>：在用户把鼠标光标从一个元素移到另一个元素上时触发。移到的元素可以是原始元素的外部元素，也可以是原始元素的子元素。这个事件不能通过键盘触发。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">mouseover</code>：在用户把鼠标光标从元素外部移到元素内部时触发。这个事件不能通过键盘触发。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">mouseup</code>：在用户释放鼠标键时触发。这个事件不能通过键盘触发。</li>
        </ul>
        <p class="calibre1">页面中的所有元素都支持鼠标事件。除了<code class="calibre11">mouseenter</code>和<code class="calibre11">mouseleave</code>，所有鼠标事件都会冒泡，都可以被取消，而这会影响浏览器的默认行为。</p>
        <p class="calibre1">由于事件之间存在关系，因此取消鼠标事件的默认行为也会影响其他事件。</p>
        <p class="calibre1">比如，<code class="calibre11">click</code>事件触发的前提是<code class="calibre11">mousedown</code>事件触发后，紧接着又在同一个元素上触发了<code class="calibre11">mouseup</code>事件。如果<code class="calibre11">mousedown</code>和<code class="calibre11">mouseup</code>中的任意一个事件被取消，那么<code class="calibre11">click</code>事件就不会触发。类似地，两次连续的<code class="calibre11">click</code>事件会导致<code class="calibre11">dblclick</code>事件触发。只要有任何逻辑阻止了这两个<code class="calibre11">click</code>事件发生（比如取消其中一个<code class="calibre11">click</code>事件或者取消<code class="calibre11">mousedown</code>或<code class="calibre11">mouseup</code>事件中的任一个），<code class="calibre11">dblclick</code>事件就不会发生。这4个事件永远会按照如下顺序触发：</p>
        <p class="calibre1">(1)
          <code class="calibre11">mousedown</code>
        </p>
        <p class="calibre1">(2)
          <code class="calibre11">mouseup</code>
        </p>
        <p class="calibre1">(3)
          <code class="calibre11">click</code>
        </p>
        <p class="calibre1">(4)
          <code class="calibre11">mousedown</code>
        </p>
        <p class="calibre1">(5)
          <code class="calibre11">mouseup</code>
        </p>
        <p class="calibre1">(6)
          <code class="calibre11">click</code>
        </p>
        <p class="calibre1">(7)
          <code class="calibre11">dblclick</code>
        </p>
        <p class="calibre1">
          <code class="calibre11">click</code>和<code class="calibre11">dblclick</code>在触发前都依赖其他事件触发，<code class="calibre11">mousedown</code>和<code class="calibre11">mouseup</code>则不会受其他事件影响。</p>
        <p class="calibre1">IE8及更早版本的实现中有个问题，这会导致双击事件跳过第二次<code class="calibre11">mousedown</code>和<code class="calibre11">click</code>事件。相应的顺序变成了：</p>
        <p class="calibre1">(1)
          <code class="calibre11">mousedown</code>
        </p>
        <p class="calibre1">(2)
          <code class="calibre11">mouseup</code>
        </p>
        <p class="calibre1">(3)
          <code class="calibre11">click</code>
        </p>
        <p class="calibre1">(4)
          <code class="calibre11">mouseup</code>
        </p>
        <p class="calibre1">(5)
          <code class="calibre11">dblclick</code>
        </p>
        <p class="calibre1">鼠标事件在DOM3 Events中对应的类型是<code class="calibre11">"MouseEvent"</code>，而不是<code class="calibre11">"MouseEvents"</code>。</p>
        <p class="calibre1">鼠标事件还有一个名为<strong class="calibre2">滚轮事件</strong>的子类别。滚轮事件只有一个事件<code class="calibre11">mousewheel</code>，反映的是鼠标滚轮或带滚轮的类似设备上滚轮的交互。</p>
        <ol class="calibre16">
          <li value="1" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">客户端坐标</strong>
            </p>
            <p class="calibre1">鼠标事件都是在浏览器视口中的某个位置上发生的。这些信息被保存在<code class="calibre11">event</code>对象的<code class="calibre11">clientX</code>和<code class="calibre11">clientY</code>属性中。这两个属性表示事件发生时鼠标光标在视口中的坐标，所有浏览器都支持。图17-4展示了视口中的<strong class="calibre2">客户端坐标</strong>。</p>
            <p class="calibre1"><img src="../images/00023.gif" alt="{%}" class="calibre12"/></p>
            <p class="calibre1">
              <strong class="calibre2">图 17-4</strong>
            </p>
            <p class="calibre1">可以通过下面的方式获取鼠标事件的客户端坐标：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let div = document.getelementbyid("mydiv");
div.addeventlistener("click", (event) =&gt; {
  console.log(`client coordinates: ${event.clientx}, ${event.clienty}`);
});</code></pre>
            <p class="calibre1">这个例子为<code class="calibre11">&lt;div&gt;</code>元素指定了一个<code class="calibre11">onclick</code>事件处理程序。当元素被点击时，会显示事件发生时鼠标光标在客户端视口中的坐标。注意客户端坐标不考虑页面滚动，因此这两个值并不代表鼠标在页面上的位置。<br class="calibre4"/>
            </p>
          </li>
          <li value="2" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">页面坐标</strong>
            </p>
            <p class="calibre1">客户端坐标是事件发生时鼠标光标在客户端视口中的坐标，而<strong class="calibre2">页面坐标</strong>是事件发生时鼠标光标在页面上的坐标，通过<code class="calibre11">event</code>对象的<code class="calibre11">pageX</code>和<code class="calibre11">pageY</code>可以获取。这两个属性表示鼠标光标在页面上的位置，因此反映的是光标到页面而非视口左边与上边的距离。</p>
            <p class="calibre1">可以像下面这样取得鼠标事件的页面坐标：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let div = document.getelementbyid("mydiv");
div.addeventlistener("click", (event) =&gt; {
  console.log(`page coordinates: ${event.pagex}, ${event.pagey}`);
});</code></pre>
            <p class="calibre1">在页面没有滚动时，<code class="calibre11">pageX</code>和<code class="calibre11">pageY</code>与<code class="calibre11">clientX</code>和<code class="calibre11">clientY</code>的值相同。</p>
            <p class="calibre1">IE8及更早版本没有在<code class="calibre11">event</code>对象上暴露页面坐标。不过，可以通过客户端坐标和滚动信息计算出来。滚动信息可以从<code class="calibre11">document.body</code>（混杂模式）或<code class="calibre11">document.documentElement</code>（标准模式）的<code class="calibre11">scrollLeft</code>和<code class="calibre11">scrollTop</code>属性获取。计算过程如下所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let div = document.getelementbyid("mydiv");
div.addeventlistener("click", (event) =&gt; {
  let pagex = event.pagex,
    pagey = event.pagey;
  if (pagex === undefined) {
    pagex = event.clientx + (document.body.scrollleft ||
        document.documentelement.scrollleft);
  }
  if (pagey === undefined) {
    pagey = event.clienty + (document.body.scrolltop ||
        document.documentelement.scrolltop);
  }
  console.log(`page coordinates: ${pagex}, ${pagey}`);
});</code></pre>
            <p class="calibre1"></p>
          </li>
          <li value="3" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">屏幕坐标</strong>
            </p>
            <p class="calibre1">鼠标事件不仅是在浏览器窗口中发生的，也是在整个屏幕上发生的。可以通过<code class="calibre11">event</code>对象的<code class="calibre11">screenX</code>和<code class="calibre11">screenY</code>属性获取鼠标光标在屏幕上的坐标。图17-5展示了浏览器中触发鼠标事件的光标的<strong class="calibre2">屏幕坐标</strong>。</p>
            <p class="calibre1"><img src="../images/00017.gif" alt="{%}" class="calibre12"/></p>
            <p class="calibre1">
              <strong class="calibre2">图 17-5</strong>
            </p>
            <p class="calibre1">可以像下面这样获取鼠标事件的屏幕坐标：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let div = document.getelementbyid("mydiv");
div.addeventlistener("click", (event) =&gt; {
  console.log(`screen coordinates: ${event.screenx}, ${event.screeny}`);
});</code></pre>
            <p class="calibre1">与前面的例子类似，这段代码也为<code class="calibre11">&lt;div&gt;</code>元素指定了<code class="calibre11">onclick</code>事件处理程序。当元素被点击时，会通过控制台打印出事件的屏幕坐标。<br class="calibre4"/>
            </p>
          </li>
          <li value="4" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">修饰键</strong>
            </p>
            <p class="calibre1">虽然鼠标事件主要是通过鼠标触发的，但有时候要确定用户想实现的操作，还要考虑键盘按键的状态。键盘上的<strong class="calibre2">修饰键</strong>Shift、Ctrl、Alt和Meta经常用于修改鼠标事件的行为。DOM规定了4个属性来表示这几个修饰键的状态：<code class="calibre11">shiftKey</code>、<code class="calibre11">ctrlKey</code>、<code class="calibre11">altKey</code>和<code class="calibre11">metaKey</code>。这几属性会在各自对应的修饰键被按下时包含布尔值<code class="calibre11">true</code>，没有被按下时包含<code class="calibre11">false</code>。在鼠标事件发生的，可以通过这几个属性来检测修饰键是否被按下。来看下面的例子，其中在<code class="calibre11">click</code>事件发生时检测了每个修饰键的状态：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let div = document.getelementbyid("mydiv");
div.addeventlistener("click", (event) =&gt; {
  let keys = new array();

  if (event.shiftkey) {
    keys.push("shift");
  }

  if (event.ctrlkey) {
    keys.push("ctrl");
  }

  if (event.altkey) {
    keys.push("alt");
  }

  if (event.metakey) {
    keys.push("meta");
  }

  console.log("keys: " + keys.join(","));

});</code></pre>
            <p class="calibre1">在这个例子中，<code class="calibre11">onclick</code>事件处理程序检查了不同修饰键的状态。<code class="calibre11">keys</code>数组中包含了在事件发生时被按下的修饰键的名称。每个对应属性为<code class="calibre11">true</code>的修饰键的名称都会添加到<code class="calibre11">keys</code>中。最后，事件处理程序会输出所有键的名称。</p>
            <blockquote class="calibre13">
              <p class="calibre1">
                <strong class="calibre2">注意</strong>
                现代浏览器支持所有这4个修饰键。IE8及更早版本不支持<code class="calibre11">metaKey</code>属性。</p>
            </blockquote>
            <p class="calibre1"></p>
          </li>
          <li value="5" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">相关元素</strong>
            </p>
            <p class="calibre1">对<code class="calibre11">mouseover</code>和<code class="calibre11">mouseout</code>事件而言，还存在与事件相关的其他元素。这两个事件都涉及从一个元素的边界之内把光标移到另一个元素的边界之内。对<code class="calibre11">mouseover</code>事件来说，事件的主要目标是获得光标的元素，相关元素是失去光标的元素。类似地，对<code class="calibre11">mouseout</code>事件来说，事件的主要目标是失去光标的元素，而相关元素是获得光标的元素。来看下面的例子：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;related elements example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id="mydiv"
       style="background-color:red;height:100px;width:100px;"&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
            <p class="calibre1">这个页面中只包含一个<code class="calibre11">&lt;div&gt;</code>元素。如果光标开始在<code class="calibre11">&lt;div&gt;</code>元素上，然后从它上面移出，则<code class="calibre11">&lt;div&gt;</code>元素上会触发<code class="calibre11">mouseout</code>事件，相关元素为<code class="calibre11">&lt;body&gt;</code>元素。与此同时，<code class="calibre11">&lt;body&gt;</code>元素上会触发<code class="calibre11">mouseover</code>事件，相关元素是<code class="calibre11">&lt;div&gt;</code>元素。</p>
            <p class="calibre1">DOM通过<code class="calibre11">event</code>对象的<code class="calibre11">relatedTarget</code>属性提供了相关元素的信息。这个属性只有在<code class="calibre11">mouseover</code>和<code class="calibre11">mouseout</code>事件发生时才包含值，其他所有事件的这个属性的值都是<code class="calibre11">null</code>。IE8及更早版本不支持<code class="calibre11">relatedTarget</code>属性，但提供了其他的可以访问到相关元素的属性。在<code class="calibre11">mouseover</code>事件触发时，IE会提供<code class="calibre11">fromElement</code>属性，其中包含相关元素。而在<code class="calibre11">mouseout</code>事件触发时，IE会提供<code class="calibre11">toElement</code>属性，其中包含相关元素。（IE9支持所有这些属性。）因此，可以在<code class="calibre11">EventUtil</code>中增加一个通用的获取相关属性的方法：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">var eventutil = {

  // 其他代码

  getrelatedtarget: function(event) {
    if (event.relatedtarget) {
      return event.relatedtarget;
    } else if (event.toelement) {
      return event.toelement;
    } else if (event.fromelement) {
      return event.fromelement;
    } else {
      return null;
    }
  },

  // 其他代码

};</code></pre>
            <p class="calibre1">与前面介绍的其他跨浏览器方法一样，这个方法同样使用特性检测来确定要返回哪个值。可以像下面这样使用<code class="calibre11">EventUtil.getRelatedTarget()</code>方法：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let div = document.getelementbyid("mydiv");
div.addeventlistener("mouseout", (event) =&gt; {
  let target = event.target;
  let relatedtarget = eventutil.getrelatedtarget(event);
  console.log(
    `moused out of ${target.tagname} to ${relatedtarget.tagname}`);
});</code></pre>
            <p class="calibre1">这个例子在<code class="calibre11">&lt;div&gt;</code>元素上注册了<code class="calibre11">mouseout</code>事件处理程序。当事件触发时，就会打印出一条消息说明鼠标从哪个元素移出，移到了哪个元素上。<br class="calibre4"/>
            </p>
          </li>
          <li value="6" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">鼠标按键</strong>
            </p>
            <p class="calibre1">只有在元素上单击鼠标主键（或按下键盘上的回车键）时<code class="calibre11">click</code>事件才会触发，因此按键信息并不是必需的。对<code class="calibre11">mousedown</code>和<code class="calibre11">mouseup</code>事件来说，<code class="calibre11">event</code>对象上会有一个<code class="calibre11">button</code>属性，表示按下或释放的是哪个按键。DOM为这个<code class="calibre11">button</code>属性定义了3个值：0表示鼠标主键、1表示鼠标中键（通常也是滚轮键）、2表示鼠标副键。按照惯例，鼠标主键通常是左边的按键，副键通常是右边的按键。</p>
            <p class="calibre1">IE8及更早版本也提供了<code class="calibre11">button</code>属性，但这个属性的值与前面说的完全不同：</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">0，表示没有按下任何键；</li>
              <li class="di_1ji_wu_xu_lie_biao">1，表示按下鼠标主键；</li>
              <li class="di_1ji_wu_xu_lie_biao">2，表示按下鼠标副键；</li>
              <li class="di_1ji_wu_xu_lie_biao">3，表示同时按下鼠标主键、副键；</li>
              <li class="di_1ji_wu_xu_lie_biao">4，表示按下鼠标中键；</li>
              <li class="di_1ji_wu_xu_lie_biao">5，表示同时按下鼠标主键和中键；</li>
              <li class="di_1ji_wu_xu_lie_biao">6，表示同时按下鼠标副键和中键；</li>
              <li class="di_1ji_wu_xu_lie_biao">7，表示同时按下3个键。</li>
            </ul>
            <p class="calibre1">很显然，DOM定义的<code class="calibre11">button</code>属性比IE这一套更简单也更有用，毕竟同时按多个鼠标键的情况很少见。为此，实践中基本上都以DOM的<code class="calibre11">button</code>属性为准，这是因为除IE8及更早版本外的所有主流浏览器都原生支持。主、中、副键的定义非常明确，而IE定义的其他情形都可以翻译为按下其中某个键，而且优先翻译为主键。比如，IE返回5或7时，就会对应到DOM的0。<br class="calibre4"/>
            </p>
          </li>
          <li value="7" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">额外事件信息</strong>
            </p>
            <p class="calibre1">DOM2 Events规范在<code class="calibre11">event</code>对象上提供了<code class="calibre11">detail</code>属性，以给出关于事件的更多信息。对鼠标事件来说，<code class="calibre11">detail</code>包含一个数值，表示在给定位置上发生了多少次单击。单击相当于在同一个像素上发生一次<code class="calibre11">mousedown</code>紧跟一次<code class="calibre11">mouseup</code>。<code class="calibre11">detail</code>的值从1开始，每次单击会加1。如果鼠标在<code class="calibre11">mousedown</code>和<code class="calibre11">mouseup</code>之间移动了，则<code class="calibre11">detail</code>会重置为0。</p>
            <p class="calibre1">IE还为每个鼠标事件提供了以下额外信息：</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">altLeft</code>，布尔值，表示是否按下了左Alt键（如果<code class="calibre11">altLeft</code>是<code class="calibre11">true</code>，那么<code class="calibre11">altKey</code>也是<code class="calibre11">true</code>）；</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">ctrlLeft</code>，布尔值，表示是否按下了左Ctrl键（如果<code class="calibre11">ctrlLeft</code>是<code class="calibre11">true</code>，那么<code class="calibre11">ctrlKey</code>也是<code class="calibre11">true</code>）；</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">offsetX</code>，光标相对于目标元素边界的<img src="../images/00080.gif" alt="x" class="calibre12"/>坐标；</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">offsetY</code>，光标相对于目标元素边界的<img src="../images/00073.gif" alt="y" class="calibre12"/>坐标；</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">shiftLeft</code>，布尔值，表示是否按下了左Shift键（如果<code class="calibre11">shiftLeft</code>是<code class="calibre11">true</code>，那么<code class="calibre11">shiftKey</code>也是<code class="calibre11">true</code>）。</li>
            </ul>
            <p class="calibre1">这些属性的作用有限，这是因为只有IE支持。而且，它们提供的信息要么没必要，要么可以通过其他方式计算。<br class="calibre4"/>
            </p>
          </li>
          <li value="8" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">
                <code class="calibre11">mousewheel</code>事件</strong>
            </p>
            <p class="calibre1">IE6首先实现了<code class="calibre11">mousewheel</code>事件。之后，Opera、Chrome和Safari也跟着实现了。<code class="calibre11">mousewheel</code>事件会在用户使用鼠标滚轮时触发，包括在垂直方向上任意滚动。这个事件会在任何元素上触发，并（在IE8中）冒泡到<code class="calibre11">document</code>和（在所有现代浏览器中）<code class="calibre11">window</code>。<code class="calibre11">mousewheel</code>事件的<code class="calibre11">event</code>对象包含鼠标事件的所有标准信息，此外还有一个名为<code class="calibre11">wheelDelta</code>的新属性。当鼠标滚轮向前滚动时，<code class="calibre11">wheelDelta</code>每次都是+120；而当鼠标滚轮向后滚动时，<code class="calibre11">wheelDelta</code>每次都是–120（见图17-6）。</p>
            <p class="calibre1"><img src="../images/00082.gif" alt="" width="45%" class="calibre42"/></p>
            <p class="calibre1">
              <strong class="calibre2">图 17-6</strong>
            </p>
            <p class="calibre1">可以为页面上的任何元素或文档添加<code class="calibre11">onmousewheel</code>事件处理程序，以处理所有鼠标滚轮交互，比如：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">document.addeventlistener("mousewheel", (event) =&gt; {
  console.log(event.wheeldelta);
});</code></pre>
            <p class="calibre1">这个例子简单地显示了鼠标滚轮事件触发时<code class="calibre11">wheelDelta</code>的值。多数情况下只需知道滚轮滚动的方向，而这通过<code class="calibre11">wheelDelta</code>值的符号就可以知道。</p>
            <blockquote class="calibre13">
              <p class="calibre1">
                <strong class="calibre2">注意</strong>
                HTML5也增加了<code class="calibre11">mousewheel</code>事件，以反映大多数浏览器对它的支持。</p>
            </blockquote>
            <p class="calibre1"></p>
          </li>
          <li value="9" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">触摸屏设备</strong>
            </p>
            <p class="calibre1">iOS和Android等触摸屏设备的实现大相径庭，因为触摸屏通常不支持鼠标操作。在为触摸屏设备开发时，要记住以下事项。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">不支持<code class="calibre11">dblclick</code>事件。双击浏览器窗口可以放大，但没有办法覆盖这个行为。</li>
              <li class="di_1ji_wu_xu_lie_biao">单指点触屏幕上的可点击元素会触发<code class="calibre11">mousemove</code>事件。如果操作会导致内容变化，则不会再触发其他事件。如果屏幕上没有变化，则会相继触发<code class="calibre11">mousedown</code>、<code class="calibre11">mouseup</code>和<code class="calibre11">click</code>事件。点触不可点击的元素不会触发事件。可点击元素是指点击时有默认动作的元素（如链接）或指定了<code class="calibre11">onclick</code>事件处理程序的元素。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">mousemove</code>事件也会触发<code class="calibre11">mouseover</code>和<code class="calibre11">mouseout</code>事件。</li>
              <li class="di_1ji_wu_xu_lie_biao">双指点触屏幕并滑动导致页面滚动时会触发<code class="calibre11">mousewheel</code>和<code class="calibre11">scroll</code>事件。<br class="calibre4"/>
              </li>
            </ul>
          </li>
          <li value="10" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">无障碍问题</strong>
            </p>
            <p class="calibre1">如果Web应用或网站必须考虑残障人士，特别是使用屏幕阅读器的用户，那么必须小心使用鼠标事件。如前所述，按回车键可以触发<code class="calibre11">click</code>事件，但其他鼠标事件不能通过键盘触发。因此，建议不要使用<code class="calibre11">click</code>事件之外的其他鼠标事件向用户提示功能或触发代码执行，这是因为其他鼠标事件会严格妨碍盲人或视障用户使用。以下是几条使用鼠标事件时应该遵循的无障碍建议。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">使用<code class="calibre11">click</code>事件执行代码。有人认为，当使用<code class="calibre11">onmousedown</code>执行代码时，应用程序会运行得更快。对视力正常用户来说确实如此。但在屏幕阅读器上，这样会导致代码无法执行，这是因为屏幕阅读器无法触发<code class="calibre11">mousedown</code>事件。</li>
              <li class="di_1ji_wu_xu_lie_biao">不要使用<code class="calibre11">mouseover</code>向用户显示新选项。同样，原因是屏幕阅读器无法触发<code class="calibre11">mousedown</code>事件。如果必须要通过这种方式显示新选项，那么可以考虑显示相同信息的键盘快捷键。</li>
              <li class="di_1ji_wu_xu_lie_biao">不要使用<code class="calibre11">dblclick</code>执行重要的操作，这是因为键盘不能触发这个事件。</li>
            </ul>
            <p class="calibre1">遵循这些简单的建议可以极大提升Web应用或网站对残障人士的无障碍性。</p>
            <blockquote class="calibre13">
              <p class="calibre1">
                <strong class="calibre2">注意</strong>
                要了解更多关于网站无障碍的信息，可以参考WebAIM网站。</p>
            </blockquote>
          </li>
        </ol>
        <h3 id="nav_point_389" class="calibre15">17.4.4 键盘与输入事件</h3>
        <p class="calibre1">
          <strong class="calibre2">键盘事件</strong>是用户操作键盘时触发的。DOM2 Events最初定义了键盘事件，但该规范在最终发布前删除了相应内容。因此，键盘事件很大程度上是基于原始的DOM0实现的。</p>
        <p class="calibre1">DOM3 Events为键盘事件提供了一个首先在IE9中完全实现的规范。其他浏览器也开始实现该规范，但仍然存在很多遗留的实现。</p>
        <p class="calibre1">键盘事件包含3个事件：</p>
        <ul class="calibre10">
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">keydown</code>，用户按下键盘上某个键时触发，而且持续按住会重复触发。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">keypress</code>，用户按下键盘上某个键并产生字符时触发，而且持续按住会重复触发。Esc键也会触发这个事件。DOM3 Events废弃了<code class="calibre11">keypress</code>事件，而推荐<code class="calibre11">textInput</code>事件。</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">keyup</code>，用户释放键盘上某个键时触发。</li>
        </ul>
        <p class="calibre1">虽然所有元素都支持这些事件，但当用户在文本框中输入内容时最容易看到。</p>
        <p class="calibre1">输入事件只有一个，即<code class="calibre11">textInput</code>。这个事件是对<code class="calibre11">keypress</code>事件的扩展，用于在文本显示给用户之前更方便地截获文本输入。<code class="calibre11">textInput</code>会在文本被插入到文本框之前触发。</p>
        <p class="calibre1">当用户按下键盘上的某个字符键时，首先会触发<code class="calibre11">keydown</code>事件，然后触发<code class="calibre11">keypress</code>事件，最后触发<code class="calibre11">keyup</code>事件。注意，这里<code class="calibre11">keydown</code>和<code class="calibre11">keypress</code>事件会在文本框出现变化之前触发，而<code class="calibre11">keyup</code>事件会在文本框出现变化之后触发。如果一个字符键被按住不放，<code class="calibre11">keydown</code>和<code class="calibre11">keypress</code>就会重复触发，直到这个键被释放。</p>
        <p class="calibre1">对于非字符键，在键盘上按一下这个键，会先触发<code class="calibre11">keydown</code>事件，然后触发<code class="calibre11">keyup</code>事件。如果按住某个非字符键不放，则会重复触发<code class="calibre11">keydown</code>事件，直到这个键被释放，此时会触发<code class="calibre11">keyup</code>事件。</p>
        <blockquote class="calibre13">
          <p class="calibre1">
            <strong class="calibre2">注意</strong>
            键盘事件支持与鼠标事件相同的修饰键。<code class="calibre11">shiftKey</code>、<code class="calibre11">ctrlKey</code>、<code class="calibre11">altKey</code>和<code class="calibre11">metaKey</code>属性在键盘事件中都是可用的。IE8及更早版本不支持<code class="calibre11">metaKey</code>属性。</p>
        </blockquote>
        <ol class="calibre16">
          <li value="1" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">键码</strong>
            </p>
            <p class="calibre1">对于<code class="calibre11">keydown</code>和<code class="calibre11">keyup</code>事件，<code class="calibre11">event</code>对象的<code class="calibre11">keyCode</code>属性中会保存一个键码，对应键盘上特定的一个键。对于字母和数字键，<code class="calibre11">keyCode</code>的值与小写字母和数字的ASCII编码一致。比如数字7键的<code class="calibre11">keyCode</code>为55，而字母A键的<code class="calibre11">keyCode</code>为65，而且跟是否按了Shift键无关。DOM和IE的<code class="calibre11">event</code>对象都支持<code class="calibre11">keyCode</code>属性。下面这个例子展示了如何使用<code class="calibre11">keyCode</code>属性：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let textbox = document.getelementbyid("mytext");
textbox.addeventlistener("keyup", (event) =&gt; {
  console.log(event.keycode);
});</code></pre>
            <p class="calibre1">这个例子在<code class="calibre11">keyup</code>事件触发时直接显示出<code class="calibre11">event</code>对象的<code class="calibre11">keyCode</code>属性值。下表给出了键盘上所有非字符键的键码。</p>
            <table class="table" width="90%" border="1">
              <tr class="calibre18">
                <th class="calibre19">键</th>
                <th class="calibre19">键码</th>
                <th class="calibre19">键</th>
                <th class="calibre19">键码</th>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">Backspace</td>
                <td class="calibre21">8</td>
                <td class="calibre21">数字键盘8</td>
                <td class="calibre21">104</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">Tab</td>
                <td class="calibre21">9</td>
                <td class="calibre21">数字键盘9</td>
                <td class="calibre21">105</td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">Enter</td>
                <td class="calibre21">13</td>
                <td class="calibre21">数字键盘+</td>
                <td class="calibre21">107</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">Shift</td>
                <td class="calibre21">16</td>
                <td class="calibre21">减号（包含数字和非数字键盘）</td>
                <td class="calibre21">109</td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">Ctrl</td>
                <td class="calibre21">17</td>
                <td class="calibre21">数字键盘.</td>
                <td class="calibre21">110</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">Alt</td>
                <td class="calibre21">18</td>
                <td class="calibre21">数字键盘/</td>
                <td class="calibre21">111</td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">Pause/Break</td>
                <td class="calibre21">19</td>
                <td class="calibre21">F1</td>
                <td class="calibre21">112</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">Caps Lock</td>
                <td class="calibre21">20</td>
                <td class="calibre21">F2</td>
                <td class="calibre21">113</td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">Esc</td>
                <td class="calibre21">27</td>
                <td class="calibre21">F3</td>
                <td class="calibre21">114</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">Page Up</td>
                <td class="calibre21">33</td>
                <td class="calibre21">F4</td>
                <td class="calibre21">115</td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">Page Down</td>
                <td class="calibre21">34</td>
                <td class="calibre21">F5</td>
                <td class="calibre21">116</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">End</td>
                <td class="calibre21">35</td>
                <td class="calibre21">F6</td>
                <td class="calibre21">117</td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">Home</td>
                <td class="calibre21">36</td>
                <td class="calibre21">F7</td>
                <td class="calibre21">118</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">左箭头</td>
                <td class="calibre21">37</td>
                <td class="calibre21">F8</td>
                <td class="calibre21">119</td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">上箭头</td>
                <td class="calibre21">38</td>
                <td class="calibre21">F9</td>
                <td class="calibre21">120</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">右箭头</td>
                <td class="calibre21">39</td>
                <td class="calibre21">F10</td>
                <td class="calibre21">121</td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">下箭头</td>
                <td class="calibre21">40</td>
                <td class="calibre21">F11</td>
                <td class="calibre21">122</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">Ins</td>
                <td class="calibre21">45</td>
                <td class="calibre21">F12</td>
                <td class="calibre21">123</td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">Del</td>
                <td class="calibre21">46</td>
                <td class="calibre21">Num Lock</td>
                <td class="calibre21">144</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">左Windows</td>
                <td class="calibre21">91</td>
                <td class="calibre21">Scroll Lock</td>
                <td class="calibre21">145</td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">右Windows</td>
                <td class="calibre21">92</td>
                <td class="calibre21">分号（IE/Safari/Chrome）</td>
                <td class="calibre21">186</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">Context Menu</td>
                <td class="calibre21">93</td>
                <td class="calibre21">分号（Opera/FF）</td>
                <td class="calibre21">59</td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">数字键盘0</td>
                <td class="calibre21">96</td>
                <td class="calibre21">小于号</td>
                <td class="calibre21">188</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">数字键盘1</td>
                <td class="calibre21">97</td>
                <td class="calibre21">大于号</td>
                <td class="calibre21">190</td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">数字键盘2</td>
                <td class="calibre21">98</td>
                <td class="calibre21">反斜杠</td>
                <td class="calibre21">191</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">数字键盘3</td>
                <td class="calibre21">99</td>
                <td class="calibre21">重音符（<code class="calibre27">\`</code>）</td>
                <td class="calibre21">192</td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">数字键盘4</td>
                <td class="calibre21">100</td>
                <td class="calibre21">等于号</td>
                <td class="calibre21">61</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">数字键盘5</td>
                <td class="calibre21">101</td>
                <td class="calibre21">左中括号</td>
                <td class="calibre21">219</td>
              </tr>
              <tr class="calibre20">
                <td class="calibre21">数字键盘6</td>
                <td class="calibre21">102</td>
                <td class="calibre21">反斜杠（<code class="calibre27">\\</code>）</td>
                <td class="calibre21">220</td>
              </tr>
              <tr class="calibre18">
                <td class="calibre21">数字键盘7</td>
                <td class="calibre21">103</td>
                <td class="calibre21">右中括号</td>
                <td class="calibre21">221</td>
              </tr>
              <tr class="calibre20"><td class="calibre21"/><td class="calibre21"/>
                <td class="calibre21">单引号</td>
                <td class="calibre21">222</td>
              </tr>
            </table>

            <p class="calibre1"></p>
          </li>
          <li value="2" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">字符编码</strong>
            </p>
            <p class="calibre1">在<code class="calibre11">keypress</code>事件发生时，意味着按键会影响屏幕上显示的文本。对插入或移除字符的键，所有浏览器都会触发<code class="calibre11">keypress</code>事件，其他键则取决于浏览器。因为DOM3 Events规范才刚刚开始实现，所以不同浏览器之间的实现存在显著差异。</p>
            <p class="calibre1">浏览器在<code class="calibre11">event</code>对象上支持<code class="calibre11">charCode</code>属性，只有发生<code class="calibre11">keypress</code>事件时这个属性才会被设置值，包含的是按键字符对应的ASCII编码。通常，<code class="calibre11">charCode</code>属性的值是0，在<code class="calibre11">keypress</code>事件发生时则是对应按键的键码。IE8及更早版本和Opera使用<code class="calibre11">keyCode</code>传达字符的ASCII编码。要以跨浏览器方式获取字符编码，首先要检查<code class="calibre11">charCode</code>属性是否有值，如果没有再使用<code class="calibre11">keyCode</code>，如下所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">var eventutil = {

  // 其他代码

  getcharcode: function(event) {
    if (typeof event.charcode == "number") {
      return event.charcode;
    } else {
      return event.keycode;
    }
  },

  // 其他代码
};</code></pre>
            <p class="calibre1">这个方法检测<code class="calibre11">charCode</code>属性是否为数值（在不支持的浏览器中是<code class="calibre11">undefined</code>）。如果是数值，则返回。否则，返回<code class="calibre11">keyCode</code>值。可以像下面这样使用：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let textbox = document.getelementbyid("mytext");
textbox.addeventlistener("keypress", (event) =&gt; {
  console.log(eventutil.getcharcode(event));
});</code></pre>
            <p class="calibre1">一旦有了字母编码，就可以使用<code class="calibre11">String.fromCharCode()</code>方法将其转换为实际的字符了。<br class="calibre4"/>
            </p>
          </li>
          <li value="3" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">DOM3的变化</strong>
            </p>
            <p class="calibre1">尽管所有浏览器都实现了某种形式的键盘事件，DOM3 Events还是做了一些修改。比如，DOM3 Events规范并未规定<code class="calibre11">charCode</code>属性，而是定义了<code class="calibre11">key</code>和<code class="calibre11">char</code>两个新属性。</p>
            <p class="calibre1">其中，<code class="calibre11">key</code>属性用于替代<code class="calibre11">keyCode</code>，且包含字符串。在按下字符键时，<code class="calibre11">key</code>的值等于文本字符（如“k”或“M”）；在按下非字符键时，<code class="calibre11">key</code>的值是键名（如“Shift”或“ArrowDown”）。<code class="calibre11">char</code>属性在按下字符键时与<code class="calibre11">key</code>类似，在按下非字符键时为<code class="calibre11">null</code>。</p>
            <p class="calibre1">IE支持<code class="calibre11">key</code>属性但不支持<code class="calibre11">char</code>属性。Safari和Chrome支持<code class="calibre11">keyIdentifier</code>属性，在按下非字符键时返回与<code class="calibre11">key</code>一样的值（如“Shift”）。对于字符键，<code class="calibre11">keyIdentifier</code>返回以“U+0000”形式表示Unicode值的字符串形式的字符编码。</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let textbox = document.getelementbyid("mytext");
textbox.addeventlistener("keypress", (event) =&gt; {
  let identifier = event.key || event.keyidentifier;
  if (identifier) {
    console.log(identifier);
  }
});</code></pre>
            <p class="calibre1">由于缺乏跨浏览器支持，因此不建议使用<code class="calibre11">key</code>、<code class="calibre11">keyIdentifier</code>、和<code class="calibre11">char</code>。</p>
            <p class="calibre1">DOM3 Events也支持一个名为<code class="calibre11">location</code>的属性，该属性是一个数值，表示是在哪里按的键。可能的值为：0是默认键，1是左边（如左边的Alt键），2是右边（如右边的Shift键），3是数字键盘，4是移动设备（即虚拟键盘），5是游戏手柄（如任天堂Wii控制器）。IE9支持这些属性。Safari和Chrome支持一个等价的<code class="calibre11">keyLocation</code>属性，但由于实现有问题，这个属性值始终为0，除非是数字键盘（此时值为3），值永远不会是1、2、4、5。</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let textbox = document.getelementbyid("mytext");
textbox.addeventlistener("keypress", (event) =&gt; {
  let loc = event.location || event.keylocation;
  if (loc) {
    console.log(loc);
  }
});</code></pre>
            <p class="calibre1">与<code class="calibre11">key</code>属性类似，<code class="calibre11">location</code>属性也没有得到广泛支持，因此不建议在跨浏览器开发时使用。</p>
            <p class="calibre1">最后一个变化是给<code class="calibre11">event</code>对象增加了<code class="calibre11">getModifierState()</code>方法。这个方法接收一个参数，一个等于<code class="calibre11">Shift</code>、<code class="calibre11">Control</code>、<code class="calibre11">Alt</code>、<code class="calibre11">AltGraph</code>或<code class="calibre11">Meta</code>的字符串，表示要检测的修饰键。如果给定的修饰键处于激活状态（键被按住），则方法返回<code class="calibre11">true</code>，否则返回<code class="calibre11">false</code>：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let textbox = document.getelementbyid("mytext");
textbox.addeventlistener("keypress", (event) =&gt; {
  if (event.getmodifierstate) {
    console.log(event.getmodifierstate("shift"));
  }
});</code></pre>
            <p class="calibre1">当然，<code class="calibre11">event</code>对象已经通过<code class="calibre11">shiftKey</code>、<code class="calibre11">altKey</code>、<code class="calibre11">ctrlKey</code>和<code class="calibre11">metaKey</code>属性暴露了这些信息。<br class="calibre4"/>
            </p>
          </li>
          <li value="4" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">
                <code class="calibre11">textInput</code>事件</strong>
            </p>
            <p class="calibre1">DOM3 Events规范增加了一个名为<code class="calibre11">textInput</code>的事件，其在字符被输入到可编辑区域时触发。作为对<code class="calibre11">keypress</code>的替代，<code class="calibre11">textInput</code>事件的行为有些不一样。一个区别是<code class="calibre11">keypress</code>会在任何可以获得焦点的元素上触发，而<code class="calibre11">textInput</code>只在可编辑区域上触发。另一个区别是<code class="calibre11">textInput</code>只在有新字符被插入时才会触发，而<code class="calibre11">keypress</code>对任何可能影响文本的键都会触发（包括退格键）。</p>
            <p class="calibre1">因为<code class="calibre11">textInput</code>事件主要关注字符，所以在<code class="calibre11">event</code>对象上提供了一个<code class="calibre11">data</code>属性，包含要插入的字符（不是字符编码）。<code class="calibre11">data</code>的值始终是要被插入的字符，因此如果在按S键时没有按Shift键，<code class="calibre11">data</code>的值就是<code class="calibre11">"s"</code>，但在按S键时同时按Shift键，<code class="calibre11">data</code>的值则是<code class="calibre11">"S"</code>。</p>
            <p class="calibre1">
              <code class="calibre11">textInput</code>事件可以这样来用：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let textbox = document.getelementbyid("mytext");
textbox.addeventlistener("textinput", (event) =&gt; {
  console.log(event.data);
});</code></pre>
            <p class="calibre1">这个例子会实时把输入文本框的文本通过日志打印出来。</p>
            <p class="calibre1">
              <code class="calibre11">event</code>对象上还有一个名为<code class="calibre11">inputMethod</code>的属性，该属性表示向控件中输入文本的手段。可能的值如下：</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">0，表示浏览器不能确定是什么输入手段；</li>
              <li class="di_1ji_wu_xu_lie_biao">1，表示键盘；</li>
              <li class="di_1ji_wu_xu_lie_biao">2，表示粘贴；</li>
              <li class="di_1ji_wu_xu_lie_biao">3，表示拖放操作；</li>
              <li class="di_1ji_wu_xu_lie_biao">4，表示IME；</li>
              <li class="di_1ji_wu_xu_lie_biao">5，表示表单选项；</li>
              <li class="di_1ji_wu_xu_lie_biao">6，表示手写（如使用手写笔）；</li>
              <li class="di_1ji_wu_xu_lie_biao">7，表示语音；</li>
              <li class="di_1ji_wu_xu_lie_biao">8，表示组合方式；</li>
              <li class="di_1ji_wu_xu_lie_biao">9，表示脚本。</li>
            </ul>
            <p class="calibre1">使用这些属性，可以确定用户是如何将文本输入到控件中的，从而可以辅助验证。<br class="calibre4"/>
            </p>
          </li>
          <li value="5" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">设备上的键盘事件</strong>
            </p>
            <p class="calibre1">任天堂Wii会在用户按下Wii遥控器上的键时触发键盘事件。虽然不能访问Wii遥控器上所有的键，但其中一些键可以触发键盘事件。图17-7中标识出了某些键的键码。</p>
            <p class="calibre1"><img src="../images/00026.gif" alt="" width="60%" class="calibre36"/></p>
            <p class="calibre1">
              <strong class="calibre2">图 17-7</strong>
            </p>
            <p class="calibre1">如图所示，按下十字键（175~178）、减号键（170）、加号键（174）、1（172）或2（173）按钮会触发键盘事件。无法判断电源键、A、B或Home键是否已按下。</p>
          </li>
        </ol>
        <h3 id="nav_point_390" class="calibre15">17.4.5 合成事件</h3>
        <p class="calibre1">
          <strong class="calibre2">合成事件</strong>是DOM3 Events中新增的，用于处理通常使用IME输入时的复杂输入序列。IME可以让用户输入物理键盘上没有的字符。例如，使用拉丁字母键盘的用户还可以使用IME输入日文。IME通常需要同时按下多个键才能输入一个字符。合成事件用于检测和控制这种输入。合成事件有以下3种：</p>
        <ul class="calibre10">
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">compositionstart</code>，在IME的文本合成系统打开时触发，表示输入即将开始；</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">compositionupdate</code>，在新字符插入输入字段时触发；</li>
          <li class="di_1ji_wu_xu_lie_biao">
            <code class="calibre11">compositionend</code>，在IME的文本合成系统关闭时触发，表示恢复正常键盘输入。</li>
        </ul>
        <p class="calibre1">合成事件在很多方面与输入事件很类似。在合成事件触发时，事件目标是接收文本的输入字段。唯一增加的事件属性是<code class="calibre11">data</code>，其中包含的值视情况而异：</p>
        <ul class="calibre10">
          <li class="di_1ji_wu_xu_lie_biao">在<code class="calibre11">compositionstart</code>事件中，包含正在编辑的文本（例如，已经选择了文本但还没替换）；</li>
          <li class="di_1ji_wu_xu_lie_biao">在<code class="calibre11">compositionupdate</code>事件中，包含要插入的新字符；</li>
          <li class="di_1ji_wu_xu_lie_biao">在<code class="calibre11">compositionend</code>事件中，包含本次合成过程中输入的全部内容。</li>
        </ul>
        <p class="calibre1">与文本事件类似，合成事件可以用来在必要时过滤输入内容。可以像下面这样使用合成事件：</p>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">let textbox = document.getelementbyid("mytext");
textbox.addeventlistener("compositionstart", (event) =&gt; {
  console.log(event.data);
});
textbox.addeventlistener("compositionupdate", (event) =&gt; {
  console.log(event.data);
});
textbox.addeventlistener("compositionend", (event) =&gt; {
  console.log(event.data);
});</code></pre>
        <h3 id="nav_point_391" class="calibre15">17.4.6 变化事件</h3>
        <p class="calibre1">DOM2的<strong class="calibre2">变化事件</strong>（Mutation Events）是为了在DOM发生变化时提供通知。</p>
        <blockquote class="calibre13">
          <p class="calibre1">
            <strong class="calibre2">注意</strong>
            这些事件已经被废弃，浏览器已经在有计划地停止对它们的支持。变化事件已经被Mutation Observers所取代，可以参考第14章中的介绍。</p>
        </blockquote>
        <h3 id="nav_point_392" class="calibre15">17.4.7 HTML5事件</h3>
        <p class="calibre1">DOM规范并未涵盖浏览器都支持的所有事件。很多浏览器根据特定的用户需求或使用场景实现了自定义事件。HTML5详尽地列出了浏览器支持的所有事件。本节讨论HTML5中得到浏览器较好支持的一些事件。注意这些并不是浏览器支持的所有事件。（本书后面也会涉及一些其他事件。）</p>
        <ol class="calibre16">
          <li value="1" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">
                <code class="calibre11">contextmenu</code>事件</strong>
            </p>
            <p class="calibre1">Windows 95通过单击鼠标右键为PC用户增加了上下文菜单的概念。不久，这个概念也在Web上得以实现。开发者面临的问题是如何确定何时该显示上下文菜单（在Windows上是右击鼠标，在Mac上是Ctrl+单击），以及如何避免默认的上下文菜单起作用。结果就出现了<code class="calibre11">contextmenu</code>事件，以专门用于表示何时该显示上下文菜单，从而允许开发者取消默认的上下文菜单并提供自定义菜单。</p>
            <p class="calibre1">
              <code class="calibre11">contextmenu</code>事件冒泡，因此只要给<code class="calibre11">document</code>指定一个事件处理程序就可以处理页面上的所有同类事件。事件目标是触发操作的元素。这个事件在所有浏览器中都可以取消，在DOM合规的浏览器中使用<code class="calibre11">event.preventDefault()</code>，在IE8及更早版本中将<code class="calibre11">event.returnValue</code>设置为<code class="calibre11">false</code>。<code class="calibre11">contextmenu</code>事件应该算一种鼠标事件，因此<code class="calibre11">event</code>对象上的很多属性都与光标位置有关。通常，自定义的上下文菜单都是通过<code class="calibre11">oncontextmenu</code>事件处理程序触发显示，并通过<code class="calibre11">onclick</code>事件处理程序触发隐藏的。来看下面的例子：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;contextmenu event example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id="mydiv"&gt;right click or ctrl+click me to get a custom context menu.
    click anywhere else to get the default context menu.&lt;/div&gt;
  &lt;ul id="mymenu" style="position:absolute;visibility:hidden;background-color:
    silver"&gt;
    &lt;li&gt;&lt;a href="http://www.somewhere.com"&gt; somewhere&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="http://www.wrox.com"&gt;wrox site&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="http://www.somewhere-else.com"&gt;somewhere-else&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
            <p class="calibre1">这个例子中的<code class="calibre11">&lt;div&gt;</code>元素有一个上下文菜单<code class="calibre11">&lt;ul&gt;</code>。作为上下文菜单，<code class="calibre11">&lt;ul&gt;</code>元素初始时是隐藏的。以下是实现上下文菜单功能的JavaScript代码：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">window.addeventlistener("load", (event) =&gt; {
  let div = document.getelementbyid("mydiv");

  div.addeventlistener("contextmenu", (event) =&gt; {
    event.preventdefault();

    let menu = document.getelementbyid("mymenu");
    menu.style.left = event.clientx + "px";
    menu.style.top = event.clienty + "px";
    menu.style.visibility = "visible";
  });

  document.addeventlistener("click", (event) =&gt; {
    document.getelementbyid("mymenu").style.visibility = "hidden";
  });
});</code></pre>
            <p class="calibre1">这里在<code class="calibre11">&lt;div&gt;</code>元素上指定了一个<code class="calibre11">oncontextmenu</code>事件处理程序。这个事件处理程序首先取消默认行，确保不会显示浏览器默认的上下文菜单。接着基于<code class="calibre11">event</code>对象的<code class="calibre11">clientX</code>和<code class="calibre11">clientY</code>属性把<code class="calibre11">&lt;ul&gt;</code>元素放到适当位置。最后一步通过将<code class="calibre11">visibility</code>属性设置为<code class="calibre11">"visible"</code>让自定义上下文菜单显示出来。另外，又给<code class="calibre11">document</code>添加了一个<code class="calibre11">onclick</code>事件处理程序，以便在单击事件发生时隐藏上下文菜单（系统上下文菜单就是这样隐藏的）。</p>
            <p class="calibre1">虽然这个例子很简单，但它是网页中所有自定义上下文菜单的基础。在这个简单例子的基础上，再添加一些CSS，上下文菜单就会更漂亮。<br class="calibre4"/>
            </p>
          </li>
          <li value="2" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">
                <code class="calibre11">beforeunload</code>事件</strong>
            </p>
            <p class="calibre1">
              <code class="calibre11">beforeunload</code>事件会在<code class="calibre11">window</code>上触发，用意是给开发者提供阻止页面被卸载的机会。这个事件会在页面即将从浏览器中卸载时触发，如果页面需要继续使用，则可以不被卸载。这个事件不能取消，否则就意味着可以把用户永久阻拦在一个页面上。相反，这个事件会向用户显示一个确认框，其中的消息表明浏览器即将卸载页面，并请用户确认是希望关闭页面，还是继续留在页面上（见图17-8）。</p>
            <p class="calibre1"><img src="../images/00032.gif" alt="" width="55%" class="calibre44"/></p>
            <p class="calibre1">
              <strong class="calibre2">图 17-8</strong>
            </p>
            <p class="calibre1">为了显示类似图17-8的确认框，需要将<code class="calibre11">event.returnValue</code>设置为要在确认框中显示的字符串（对于IE和Firefox来说），并将其作为函数值返回（对于Safari和Chrome来说），如下所示：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">window.addeventlistener("beforeunload", (event) =&gt; {
  let message = "i'm really going to miss you if you go.";
  event.returnvalue = message;
  return message;
});</code></pre>
            <p class="calibre1"></p>
          </li>
          <li value="3" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">
                <code class="calibre11">DOMContentLoaded</code>事件</strong>
            </p>
            <p class="calibre1">
              <code class="calibre11">window</code>的<code class="calibre11">load</code>事件会在页面完全加载后触发，因为要等待很多外部资源加载完成，所以会花费较长时间。而<code class="calibre11">DOMContentLoaded</code>事件会在DOM树构建完成后立即触发，而不用等待图片、JavaScript文件、CSS文件或其他资源加载完成。相对于<code class="calibre11">load</code>事件，<code class="calibre11">DOMContentLoaded</code>可以让开发者在外部资源下载的同时就能指定事件处理程序，从而让用户能够更快地与页面交互。</p>
            <p class="calibre1">要处理<code class="calibre11">DOMContentLoaded</code>事件，需要给<code class="calibre11">document</code>或<code class="calibre11">window</code>添加事件处理程序（实际的事件目标是<code class="calibre11">document</code>，但会冒泡到<code class="calibre11">window</code>）。下面是一个在<code class="calibre11">document</code>上监听<code class="calibre11">DOMContentLoaded</code>事件的例子：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">document.addeventlistener("domcontentloaded", (event) =&gt; {
  console.log("content loaded");
});</code></pre>
            <p class="calibre1">
              <code class="calibre11">DOMContentLoaded</code>事件的<code class="calibre11">event</code>对象中不包含任何额外信息（除了<code class="calibre11">target</code>等于<code class="calibre11">document</code>）。</p>
            <p class="calibre1">
              <code class="calibre11">DOMContentLoaded</code>事件通常用于添加事件处理程序或执行其他DOM操作。这个事件始终在<code class="calibre11">load</code>事件之前触发。</p>
            <p class="calibre1">对于不支持<code class="calibre11">DOMContentLoaded</code>事件的浏览器，可以使用超时为0的<code class="calibre11">setTimeout()</code>函数，通过其回调来设置事件处理程序，比如：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">settimeout(() =&gt; {
  // 在这里添加事件处理程序
}, 0);</code></pre>
            <p class="calibre1">以上代码本质上意味着在当前JavaScript进程执行完毕后立即执行这个回调。页面加载和构建期间，只有一个JavaScript进程运行。所以可以在这个进程空闲后立即执行回调，至于是否与同一个浏览器或同一页面上不同脚本的<code class="calibre11">DOMContentLoaded</code>触发时机一致并无绝对把握。为了尽可能早一些执行，以上代码最好是页面上的第一个超时代码。即使如此，考虑到各种影响因素，也不一定保证能在<code class="calibre11">load</code>事件之前执行超时回调。<br class="calibre4"/>
            </p>
          </li>
          <li value="4" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">
                <code class="calibre11">readystatechange</code>事件</strong>
            </p>
            <p class="calibre1">IE首先在DOM文档的一些地方定义了一个名为<code class="calibre11">readystatechange</code>事件。这个有点神秘的事件旨在提供文档或元素加载状态的信息，但行为有时候并不稳定。支持<code class="calibre11">readystatechange</code>事件的每个对象都有一个<code class="calibre11">readyState</code>属性，该属性具有一个以下列出的可能的字符串值。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">uninitialized</code>：对象存在并尚未初始化。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">loading</code>：对象正在加载数据。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">loaded</code>：对象已经加载完数据。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">interactive</code>：对象可以交互，但尚未加载完成。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">complete</code>：对象加载完成。</li>
            </ul>
            <p class="calibre1">看起来很简单，其实并非所有对象都会经历所有<code class="calibre11">readystate</code>阶段。文档中说有些对象会完全跳过某个阶段，但并未说明哪些阶段适用于哪些对象。这意味着<code class="calibre11">readystatechange</code>事件经常会触发不到4次，而<code class="calibre11">readyState</code>未必会依次呈现上述值。</p>
            <p class="calibre1">在<code class="calibre11">document</code>上使用时，值为<code class="calibre11">"interactive"</code>的<code class="calibre11">readyState</code>首先会触发<code class="calibre11">readystatechange</code>事件，时机类似于<code class="calibre11">DOMContentLoaded</code>。进入交互阶段，意味着DOM树已加载完成，因而可以安全地交互了。此时图片和其他外部资源不一定都加载完了。可以像下面这样使用<code class="calibre11">readystatechange</code>事件：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">document.addeventlistener("readystatechange", (event) =&gt; {
  if (document.readystate == "interactive") {
    console.log("content loaded");
  }
});</code></pre>
            <p class="calibre1">这个事件的<code class="calibre11">event</code>对象中没有任何额外的信息，连事件目标都不会设置。</p>
            <p class="calibre1">在与<code class="calibre11">load</code>事件共同使用时，这个事件的触发顺序不能保证。在包含特别多或较大外部资源的页面中，交互阶段会在<code class="calibre11">load</code>事件触发前先触发。而在包含较少且较小外部资源的页面中，这个<code class="calibre11">readystatechange</code>事件有可能在<code class="calibre11">load</code>事件触发后才触发。</p>
            <p class="calibre1">让问题变得更加复杂的是，交互阶段与完成阶段的顺序也不是固定的。在外部资源较多的页面中，很可能交互阶段会早于完成阶段，而在外部资源较少的页面中，很可能完成阶段会早于交互阶段。因此，实践中为了抢到较早的时机，需要同时检测交互阶段和完成阶段。比如：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">document.addeventlistener("readystatechange", (event) =&gt; {
  if (document.readystate == "interactive" ||
      document.readystate == "complete") {
    document.removeeventlistener("readystatechange", arguments.callee);
    console.log("content loaded");
  }
});</code></pre>
            <p class="calibre1">当<code class="calibre11">readystatechange</code>事件触发时，这段代码会检测<code class="calibre11">document.readyState</code>属性，以确定当前是不是交互或完成状态。如果是，则移除事件处理程序，以保证其他阶段不再执行。注意，因为这里的事件处理程序是匿名函数，所以使用了<code class="calibre11">arguments.callee</code>作为函数指针。然后，又打印出一条表示内容已加载的消息。这样的逻辑可以保证尽可能接近使用<code class="calibre11">DOMContentLoaded</code>事件的效果。</p>
            <blockquote class="calibre13">
              <p class="calibre1">
                <strong class="calibre2">注意</strong>
                使用<code class="calibre11">readystatechange</code>只能尽量模拟<code class="calibre11">DOMContentLoaded</code>，但做不到分毫不差。<code class="calibre11">load</code>事件和<code class="calibre11">readystatechange</code>事件发生的顺序在不同页面中是不一样的。</p>
            </blockquote>
            <p class="calibre1"></p>
          </li>
          <li value="5" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">
                <code class="calibre11">pageshow</code>与<code class="calibre11">pagehide</code>事件</strong>
            </p>
            <p class="calibre1">Firefox和Opera开发了一个名为<strong class="calibre2">往返缓存</strong>（bfcache，back-forward cache）的功能，此功能旨在使用浏览器“前进”和“后退”按钮时加快页面之间的切换。这个缓存不仅存储页面数据，也存储DOM和JavaScript状态，实际上是把整个页面都保存在内存里。如果页面在缓存中，那么导航到这个页面时就不会触发<code class="calibre11">load</code>事件。通常，这不会导致什么问题，因为整个页面状态都被保存起来了。不过，Firefx决定提供一些事件，把往返缓存的行为暴露出来。</p>
            <p class="calibre1">第一个事件是<code class="calibre11">pageshow</code>，其会在页面显示时触发，无论是否来自往返缓存。在新加载的页面上，<code class="calibre11">pageshow</code>会在<code class="calibre11">load</code>事件之后触发；在来自往返缓存的页面上，<code class="calibre11">pageshow</code>会在页面状态完全恢复后触发。注意，虽然这个事件的目标是<code class="calibre11">document</code>，但事件处理程序必须添加到<code class="calibre11">window</code>上。下面的例子展示了追踪这些事件的代码：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">(function() {
  let showcount = 0;

  window.addeventlistener("load", () =&gt; {
    console.log("load fired");
  });

  window.addeventlistener("pageshow", () =&gt; {
    showcount++;
    console.log(`show has been fired ${showcount} times.`);
  });
})();</code></pre>
            <p class="calibre1">这个例子使用了私有作用域来保证<code class="calibre11">showCount</code>变量不进入全局作用域。在页面首次加载时，<code class="calibre11">showCount</code>的值为0。之后每次触发<code class="calibre11">pageshow</code>事件，<code class="calibre11">showCount</code>都会加1并输出消息。如果从包含以上代码的页面跳走，然后又点击“后退”按钮返回以恢复它，就能够每次都看到<code class="calibre11">showCount</code>递增的值。这是因为变量的状态连同整个页面状态都保存在了内存中，导航回来后可以恢复。如果是点击了浏览器的“刷新”按钮，则<code class="calibre11">showCount</code>的值会重置为0，因为页面会重新加载。</p>
            <p class="calibre1">除了常用的属性，<code class="calibre11">pageshow</code>的<code class="calibre11">event</code>对象中还包含一个名为<code class="calibre11">persisted</code>的属性。这个属性是一个布尔值，如果页面存储在了往返缓存中就是<code class="calibre11">true</code>，否则就是<code class="calibre11">false</code>。可以像下面这样在事件处理程序中检测这个属性：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">(function() {
  let showcount = 0;

  window.addeventlistener("load", () =&gt; {
    console.log("load fired");
  });

  window.addeventlistener("pageshow", () =&gt; {
    showcount++;
    console.log(`show has been fired ${showcount} times.`,
                `persisted? ${event.persisted}`);
  });
})();</code></pre>
            <p class="calibre1">通过检测<code class="calibre11">persisted</code>属性可以根据页面是否取自往返缓存而决定是否采取不同的操作。</p>
            <p class="calibre1">与<code class="calibre11">pageshow</code>对应的事件是<code class="calibre11">pagehide</code>，这个事件会在页面从浏览器中卸载后，在<code class="calibre11">unload</code>事件之前触发。与<code class="calibre11">pageshow</code>事件一样，<code class="calibre11">pagehide</code>事件同样是在<code class="calibre11">document</code>上触发，但事件处理程序必须被添加到<code class="calibre11">window</code>。<code class="calibre11">event</code>对象中同样包含<code class="calibre11">persisted</code>属性，但用法稍有不同。比如，以下代码检测了<code class="calibre11">event.persisted</code>属性：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">window.addeventlistener("pagehide", (event) =&gt; {
  console.log("hiding. persisted? " + event.persisted);
});</code></pre>
            <p class="calibre1">这样，当<code class="calibre11">pagehide</code>事件触发时，也许可以根据<code class="calibre11">persisted</code>属性的值来采取一些不同的操作。对<code class="calibre11">pageshow</code>事件来说，<code class="calibre11">persisted</code>为<code class="calibre11">true</code>表示页面是从往返缓存中加载的；而对<code class="calibre11">pagehide</code>事件来说，<code class="calibre11">persisted</code>为<code class="calibre11">true</code>表示页面在卸载之后会被保存在往返缓存中。因此，第一次触发<code class="calibre11">pageshow</code>事件时<code class="calibre11">persisted</code>始终是<code class="calibre11">false</code>，而第一次触发<code class="calibre11">pagehide</code>事件时<code class="calibre11">persisted</code>始终是<code class="calibre11">true</code>（除非页面不符合使用往返缓存的条件）。</p>
            <blockquote class="calibre13">
              <p class="calibre1">
                <strong class="calibre2">注意</strong>
                注册了<code class="calibre11">onunload</code>事件处理程序（即使是空函数）的页面会自动排除在往返缓存之外。这是因为<code class="calibre11">onunload</code>事件典型的使用场景是撤销<code class="calibre11">onload</code>事件发生时所做的事情，如果使用往返缓存，则下一次页面显示时就不会触发<code class="calibre11">onload</code>事件，而这可能导致页面无法使用。</p>
            </blockquote>
            <p class="calibre1"></p>
          </li>
          <li value="6" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">
                <code class="calibre11">hashchange</code>事件</strong>
            </p>
            <p class="calibre1">HTML5增加了<code class="calibre11">hashchange</code>事件，用于在URL散列值（URL最后<code class="calibre11">#</code>后面的部分）发生变化时通知开发者。这是因为开发者经常在Ajax应用程序中使用URL散列值存储状态信息或路由导航信息。</p>
            <p class="calibre1">
              <code class="calibre11">onhashchange</code>事件处理程序必须添加给<code class="calibre11">window</code>，每次URL散列值发生变化时会调用它。<code class="calibre11">event</code>对象有两个新属性：<code class="calibre11">oldURL</code>和<code class="calibre11">newURL</code>。这两个属性分别保存变化前后的URL，而且是包含散列值的完整URL。下面的例子展示了如何获取变化前后的URL：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">window.addeventlistener("hashchange", (event) =&gt; {
  console.log(`old url: ${event.oldurl}, new url: ${event.newurl}`);
});</code></pre>
            <p class="calibre1">如果想确定当前的散列值，最好使用<code class="calibre11">location</code>对象：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">window.addeventlistener("hashchange", (event) =&gt; {
  console.log(`current hash: ${location.hash}`);
});</code></pre>
          </li>
        </ol>
        <h3 id="nav_point_393" class="calibre15">17.4.8 设备事件</h3>
        <p class="calibre1">随着智能手机和平板计算机的出现，用户与浏览器交互的新方式应运而生。为此，一批新事件被发明了出来。<strong class="calibre2">设备事件</strong>可以用于确定用户使用设备的方式。W3C在2011年就开始起草一份新规范，用于定义新设备及设备相关的事件。</p>
        <ol class="calibre16">
          <li value="1" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">
                <code class="calibre11">orientationchange</code>事件</strong>
            </p>
            <p class="calibre1">苹果公司在移动Safari浏览器上创造了<code class="calibre11">orientationchange</code>事件，以方便开发者判断用户的设备是处于垂直模式还是水平模式。移动Safari在<code class="calibre11">window</code>上暴露了<code class="calibre11">window.orientation</code>属性，它有以下3种值之一：0表示垂直模式，90表示左转水平模式（主屏幕键在右侧），–90表示右转水平模式（主屏幕键在左）。虽然相关文档也提及设备倒置后的值为180，但设备本身至今还不支持。图17-9展示了<code class="calibre11">window.orientation</code>属性的各种值。</p>
            <p class="calibre1"><img src="../images/00004.gif" alt="" width="62%" class="calibre40"/></p>
            <p class="calibre1">
              <strong class="calibre2">图 17-9</strong>
            </p>
            <p class="calibre1">每当用户旋转设备改变了模式，就会触发<code class="calibre11">orientationchange</code>事件。但<code class="calibre11">event</code>对象上没有暴露任何有用的信息，这是因为相关信息都可以从<code class="calibre11">window.orientation</code>属性中获取。以下是这个事件典型的用法：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">window.addeventlistener("load", (event) =&gt; {
  let div = document.getelementbyid("mydiv");
  div.innerhtml = "current orientation is " + window.orientation;

  window.addeventlistener("orientationchange", (event) =&gt; {
    div.innerhtml = "current orientation is " + window.orientation;
  });
});</code></pre>
            <p class="calibre1">这个例子会在<code class="calibre11">load</code>事件触发时显示设备初始的朝向。然后，又指定了<code class="calibre11">orientationchange</code>事件处理程序。此后，只要这个事件触发，页面就会更新以显示新的朝向信息。</p>
            <p class="calibre1">所有iOS设备都支持<code class="calibre11">orientationchange</code>事件和<code class="calibre11">window.orientation</code>属性。</p>
            <blockquote class="calibre13">
              <p class="calibre1">
                <strong class="calibre2">注意</strong>
                因为<code class="calibre11">orientationchange</code>事件被认为是<code class="calibre11">window</code>事件，所以也可以通过给<code class="calibre11">&lt;body&gt;</code>元素添加<code class="calibre11">onorientationchange</code>属性来指定事件处理程序。</p>
            </blockquote>
            <p class="calibre1"></p>
          </li>
          <li value="2" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">
                <code class="calibre11">deviceorientation</code>事件</strong>
            </p>
            <p class="calibre1">
              <code class="calibre11">deviceorientation</code>是DeviceOrientationEvent规范定义的事件。如果可以获取设备的加速计信息，而且数据发生了变化，这个事件就会在<code class="calibre11">window</code>上触发。要注意的是，<code class="calibre11">deviceorientation</code>事件只反映设备在空间中的朝向，而不涉及移动相关的信息。</p>
            <p class="calibre1">设备本身处于3D空间即拥有<img src="../images/00080.gif" alt="x" class="calibre12"/>轴、<img src="../images/00073.gif" alt="y" class="calibre12"/>轴和<img src="../images/00009.gif" alt="z" class="calibre12"/>轴的坐标系中。如果把设备静止放在水平的表面上，那么三轴的值均为0，其中，<img src="../images/00080.gif" alt="x" class="calibre12"/>轴方向为从设备左侧到右侧，<img src="../images/00073.gif" alt="y" class="calibre12"/>轴方向为从设备底部到上部，<img src="../images/00009.gif" alt="z" class="calibre12"/>轴方向为从设备背面到正面，如图17-10所示。</p>
            <p class="calibre1"><img src="../images/00030.gif" alt="" width="50%" class="calibre14"/></p>
            <p class="calibre1">
              <strong class="calibre2">图 17-10</strong>
            </p>
            <p class="calibre1">当<code class="calibre11">deviceorientation</code>触发时，<code class="calibre11">event</code>对象中会包含各个轴相对于设备静置时坐标值的变化，主要是以下5个属性。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">alpha</code>：0~360范围内的浮点值，表示围绕<img src="../images/00009.gif" alt="z" class="calibre12"/>轴旋转时<img src="../images/00073.gif" alt="y" class="calibre12"/>轴的度数（左右转）。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">beta</code>：–180~180范围内的浮点值，表示围绕<img src="../images/00080.gif" alt="x" class="calibre12"/>轴旋转时<img src="../images/00009.gif" alt="z" class="calibre12"/>轴的度数（前后转）。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">gamma</code>：–90~90范围内的浮点值，表示围绕<img src="../images/00073.gif" alt="y" class="calibre12"/>轴旋转时<img src="../images/00009.gif" alt="z" class="calibre12"/>轴的度数（扭转）。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">absolute</code>：布尔值，表示设备是否返回绝对值。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">compassCalibrated</code>：布尔值，表示设备的指南针是否正确校准。</li>
            </ul>
            <p class="calibre1">图17-11展示了<code class="calibre11">alpha</code>、<code class="calibre11">beta</code>和<code class="calibre11">gamma</code>值的计算方式。</p>
            <p class="calibre1"><img src="../images/00069.gif" alt="{%}" class="calibre12"/></p>
            <p class="calibre1">
              <strong class="calibre2">图 17-11</strong>
            </p>
            <p class="calibre1">下面是一个输出<code class="calibre11">alpha</code>、<code class="calibre11">beta</code>和<code class="calibre11">gamma</code>值的简单例子：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">window.addeventlistener("deviceorientation", (event) =&gt; {
  let output = document.getelementbyid("output");
  output.innerhtml =
    `alpha=${event.alpha}, beta=${event.beta}, gamma=${event.gamma}&lt;br&gt;`;
});</code></pre>
            <p class="calibre1">基于这些信息，可以随着设备朝向的变化重新组织或修改屏幕上显示的元素。例如，以下代码会随着朝向变化旋转一个元素：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">window.addeventlistener("deviceorientation", (event) =&gt; {
  let arrow = document.getelementbyid("arrow");
  arrow.style.webkittransform = `rotate(${math.round(event.alpha)}deg)`;
});</code></pre>
            <p class="calibre1">这个例子只适用于移动WebKit浏览器，因为使用的是专有的<code class="calibre11">webkitTransform</code>属性（CSS标准的<code class="calibre11">transform</code>属性的临时版本）。“箭头”（arrow）元素会随着<code class="calibre11">event.alpha</code>值的变化而变化，呈现出指南针的样子。这里给CSS3旋转变形函数传入了四舍五入后的值，以确保平顺。<br class="calibre4"/>
            </p>
          </li>
          <li value="3" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">
                <code class="calibre11">devicemotion</code>事件</strong>
            </p>
            <p class="calibre1">DeviceOrientationEvent规范也定义了<code class="calibre11">devicemotion</code>事件。这个事件用于提示设备实际上在移动，而不仅仅是改变了朝向。例如，<code class="calibre11">devicemotion</code>事件可以用来确定设备正在掉落或者正拿在一个行走的人手里。</p>
            <p class="calibre1">当<code class="calibre11">devicemotion</code>事件触发时，<code class="calibre11">event</code>对象中包含如下额外的属性。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">acceleration</code>：对象，包含<code class="calibre11">x</code>、<code class="calibre11">y</code>和<code class="calibre11">z</code>属性，反映不考虑重力情况下各个维度的加速信息。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">accelerationIncludingGravity</code>：对象，包含<code class="calibre11">x</code>、<code class="calibre11">y</code>和<code class="calibre11">z</code>属性，反映各个维度的加速信息，包含<img src="../images/00009.gif" alt="z" class="calibre12"/>轴自然重力加速度。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">interval</code>：毫秒，距离下次触发<code class="calibre11">devicemotion</code>事件的时间。此值在事件之间应为常量。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">rotationRate</code>：对象，包含<code class="calibre11">alpha</code>、<code class="calibre11">beta</code>和<code class="calibre11">gamma</code>属性，表示设备朝向。</li>
            </ul>
            <p class="calibre1">如果无法提供<code class="calibre11">acceleration</code>、<code class="calibre11">accelerationIncludingGravity</code>和<code class="calibre11">rotationRate</code>信息，则属性值为<code class="calibre11">null</code>。为此，在使用这些属性前必须先检测它们的值是否为<code class="calibre11">null</code>。比如：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">window.addeventlistener("devicemotion", (event) =&gt; {
  let output = document.getelementbyid("output");
  if (event.rotationrate !== null) {
    output.innerhtml += `alpha=${event.rotationrate.alpha}` +
                        `beta=${event.rotationrate.beta}` +
                        `gamma=${event.rotationrate.gamma}`;
  }
});</code></pre>
          </li>
        </ol>
        <h3 id="nav_point_394" class="calibre15">17.4.9 触摸及手势事件</h3>
        <p class="calibre1">Safari为iOS定制了一些专有事件，以方便开发者。因为iOS设备没有鼠标和键盘，所以常规的鼠标和键盘事件不足以创建具有完整交互能力的网页。同时，WebKit也为Android定制了很多专有事件，成为了事实标准，并被纳入W3C的Touch Events规范。本节介绍的事件只适用于触屏设备。</p>
        <ol class="calibre16">
          <li value="1" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">触摸事件</strong>
            </p>
            <p class="calibre1">iPhone 3G发布时，iOS 2.0内置了新版本的Safari。这个新的移动Safari支持一些与触摸交互有关的新事件。后来的Android浏览器也实现了同样的事件。当手指放在屏幕上、在屏幕上滑动或从屏幕移开时，<strong class="calibre2">触摸事件</strong>即会触发。触摸事件有如下几种。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">touchstart</code>：手指放到屏幕上时触发（即使有一个手指已经放在了屏幕上）。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">touchmove</code>：手指在屏幕上滑动时连续触发。在这个事件中调用<code class="calibre11">preventDefault</code>()可以阻止滚动。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">touchend</code>：手指从屏幕上移开时触发。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">touchcancel</code>：系统停止跟踪触摸时触发。文档中并未明确什么情况下停止跟踪。</li>
            </ul>
            <p class="calibre1">这些事件都会冒泡，也都可以被取消。尽管触摸事件不属于DOM规范，但浏览器仍然以兼容DOM的方式实现了它们。因此，每个触摸事件的<code class="calibre11">event</code>对象都提供了鼠标事件的公共属性：<code class="calibre11">bubbles</code>、<code class="calibre11">cancelable</code>、<code class="calibre11">view</code>、<code class="calibre11">clientX</code>、<code class="calibre11">clientY</code>、<code class="calibre11">screenX</code>、<code class="calibre11">screenY</code>、<code class="calibre11">detail</code>、<code class="calibre11">altKey</code>、<code class="calibre11">shiftKey</code>、<code class="calibre11">ctrlKey</code>和<code class="calibre11">metaKey</code>。</p>
            <p class="calibre1">除了这些公共的DOM属性，触摸事件还提供了以下3个属性用于跟踪触点。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">touches</code>：<code class="calibre11">Touch</code>对象的数组，表示当前屏幕上的每个触点。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">targetTouches</code>：<code class="calibre11">Touch</code>对象的数组，表示特定于事件目标的触点。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">changedTouches</code>：<code class="calibre11">Touch</code>对象的数组，表示自上次用户动作之后变化的触点。</li>
            </ul>
            <p class="calibre1">每个<code class="calibre11">Touch</code>对象都包含下列属性。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">clientX</code>：触点在视口中的<img src="../images/00080.gif" alt="x" class="calibre12"/>坐标。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">clientY</code>：触点在视口中的<img src="../images/00073.gif" alt="y" class="calibre12"/>坐标。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">identifier</code>：触点ID。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">pageX</code>：触点在页面上的<img src="../images/00080.gif" alt="x" class="calibre12"/>坐标。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">pageY</code>：触点在页面上的<img src="../images/00073.gif" alt="y" class="calibre12"/>坐标。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">screenX</code>：触点在屏幕上的<img src="../images/00080.gif" alt="x" class="calibre12"/>坐标。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">screenY</code>：触点在屏幕上的<img src="../images/00073.gif" alt="y" class="calibre12"/>坐标。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">target</code>：触摸事件的事件目标。</li>
            </ul>
            <p class="calibre1">这些属性可用于追踪屏幕上的触摸轨迹。例如：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">function handletouchevent(event) {
  // 只针对一个触点
  if (event.touches.length == 1) {
    let output = document.getelementbyid("output");
    switch(event.type) {
      case "touchstart":
        output.innerhtml += `&lt;br&gt;touch started:` +
                            `(${event.touches[0].clientx}` +
                            ` ${event.touches[0].clienty})`;
        break;
      case "touchend":
        output.innerhtml += `&lt;br&gt;touch ended:` +
                            `(${event.changedtouches[0].clientx}` +
                            ` ${event.changedtouches[0].clienty})`;
        break;
      case "touchmove":
        event.preventdefault(); // 阻止滚动
        output.innerhtml += `&lt;br&gt;touch moved:` +
                            `(${event.changedtouches[0].clientx}` +
                            ` ${event.changedtouches[0].clienty})`;
        break;
    }
  }
}

document.addeventlistener("touchstart", handletouchevent);
document.addeventlistener("touchend", handletouchevent);
document.addeventlistener("touchmove", handletouchevent);</code></pre>
            <p class="calibre1">以上代码会追踪屏幕上的一个触点。为简单起见，代码只会在屏幕有一个触点时输出信息。在<code class="calibre11">touchstart</code>事件触发时，触点的位置信息会输出到<code class="calibre11">output</code>元素中。在<code class="calibre11">touchmove</code>事件触发时，会取消默认行为以阻止滚动（移动触点通常会滚动页面），并输出变化的触点信息。在<code class="calibre11">touchend</code>事件触发时，会输出触点最后的信息。注意，<code class="calibre11">touchend</code>事件触发时<code class="calibre11">touches</code>集合中什么也没有，这是因为没有滚动的触点了。此时必须使用<code class="calibre11">changedTouches</code>集合。</p>
            <p class="calibre1">这些事件会在文档的所有元素上触发，因此可以分别控制页面的不同部分。当手指点触屏幕上的元素时，依次会发生如下事件（包括鼠标事件）：</p>
            <p class="calibre1">(1)
              <code class="calibre11">touchstart</code>
            </p>
            <p class="calibre1">(2)
              <code class="calibre11">mouseover</code>
            </p>
            <p class="calibre1">(3)
              <code class="calibre11">mousemove</code>（1次）</p>
            <p class="calibre1">(4)
              <code class="calibre11">mousedown</code>
            </p>
            <p class="calibre1">(5)
              <code class="calibre11">mouseup</code>
            </p>
            <p class="calibre1">(6)
              <code class="calibre11">click</code>
            </p>
            <p class="calibre1">(7)
              <code class="calibre11">touchend</code><br class="calibre4"/>
            </p>
          </li>
          <li value="2" class="di_1ji_wu_xu_lie_biao">
            <p class="calibre1">
              <strong class="calibre2">手势事件</strong>
            </p>
            <p class="calibre1">iOS 2.0中的Safari还增加了一种手势事件。<strong class="calibre2">手势事件</strong>会在两个手指触碰屏幕且相对距离或旋转角度变化时触发。手势事件有以下3种。</p>
            <ul class="calibre17">
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">gesturestart</code>：一个手指已经放在屏幕上，再把另一个手指放到屏幕上时触发。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">gesturechange</code>：任何一个手指在屏幕上的位置发生变化时触发。</li>
              <li class="di_1ji_wu_xu_lie_biao">
                <code class="calibre11">gestureend</code>：其中一个手指离开屏幕时触发。</li>
            </ul>
            <p class="calibre1">只有在两个手指同时接触事件接收者时，这些事件才会触发。在一个元素上设置事件处理程序，意味着两个手指必须都在元素边界以内才能触发手势事件（这个元素就是事件目标）。因为这些事件会冒泡，所以也可以把事件处理程序放到文档级别，从而可以处理所有手势事件。使用这种方式时，事件的目标就是两个手指均位于其边界内的元素。</p>
            <p class="calibre1">触摸事件和手势事件存在一定的关系。当一个手指放在屏幕上时，会触发<code class="calibre11">touchstart</code>事件。当另一个手指放到屏幕上时，<code class="calibre11">gesturestart</code>事件会首先触发，然后紧接着触发这个手指的<code class="calibre11">touchstart</code>事件。如果两个手指或其中一个手指移动，则会触发<code class="calibre11">gesturechange</code>事件。只要其中一个手指离开屏幕，就会触发<code class="calibre11">gestureend</code>事件，紧接着触发该手指的<code class="calibre11">touchend</code>事件。</p>
            <p class="calibre1">与触摸事件类似，每个手势事件的<code class="calibre11">event</code>对象都包含所有标准的鼠标事件属性：<code class="calibre11">bubbles</code>、<code class="calibre11">cancelable</code>、<code class="calibre11">view</code>、<code class="calibre11">clientX</code>、<code class="calibre11">clientY</code>、<code class="calibre11">screenX</code>、<code class="calibre11">screenY</code>、<code class="calibre11">detail</code>、<code class="calibre11">altKey</code>、<code class="calibre11">shiftKey</code>、<code class="calibre11">ctrlKey</code>和<code class="calibre11">metaKey</code>。新增的两个<code class="calibre11">event</code>对象属性是<code class="calibre11">rotation</code>和<code class="calibre11">scale</code>。<code class="calibre11">rotation</code>属性表示手指变化旋转的度数，负值表示逆时针旋转，正值表示顺时针旋转（从0开始）。<code class="calibre11">scale</code>属性表示两指之间距离变化（对捏）的程度。开始时为1，然后随着距离增大或缩小相应地增大或缩小。</p>
            <p class="calibre1">可以像下面这样使用手势事件的属性：</p>
            <pre class="dai_ma_wu_xing_hao"><code class="calibre11">function handlegestureevent(event) {
  let output = document.getelementbyid("output");
  switch(event.type) {
    case "gesturestart":
      output.innerhtml += `gesture started: ` +
                          `rotation=${event.rotation},` +
                          `scale=${event.scale}`;
      break;
    case "gestureend":
      output.innerhtml += `gesture ended: ` +
                          `rotation=${event.rotation},` +
                          `scale=${event.scale}`;
      break;
    case "gesturechange":
      output.innerhtml += `gesture changed: ` +
                          `rotation=${event.rotation},` +
                          `scale=${event.scale}`;
      break;
  }
}

document.addeventlistener("gesturestart", handlegestureevent, false);
document.addeventlistener("gestureend", handlegestureevent, false);
document.addeventlistener("gesturechange", handlegestureevent, false);</code></pre>
            <p class="calibre1">与触摸事件的例子一样，以上代码简单地将每个事件对应到一个处理函数，然后输出每个事件的信息。</p>
            <blockquote class="calibre13">
              <p class="calibre1">
                <strong class="calibre2">注意</strong>
                触摸事件也会返回<code class="calibre11">rotation</code>和<code class="calibre11">scale</code>属性，但只在两个手指触碰屏幕时才会变化。一般来说，使用两个手指的手势事件比考虑所有交互的触摸事件使用起来更容易一些。</p>
            </blockquote>
          </li>
        </ol>
        <h3 id="nav_point_395" class="calibre15">17.4.10 事件参考</h3>
        <p class="calibre1">本节给出了DOM规范、HTML5规范，以及概述事件行为的其他当前已发布规范中定义的所有浏览器事件。这些事件按照API和/或规范分类。</p>
        <blockquote class="calibre13">
          <p class="calibre1">
            <strong class="calibre2">注意</strong>
            只包含带厂商前缀事件的规范不在本参考中。</p>
        </blockquote>
        <pre class="dai_ma_wu_xing_hao"><code class="calibre11">ambient light events
devicelight

app cache events
cached
checking
downloading
noupdate
obsolete
updateready

audio channels api events
headphoneschange
mozinterruptbegin
mozinterruptend

battery api events
chargingchange
chargingtimechange
dischargingtimechange
levelchange

broadcast channel api events
message

channel messaging api events
message

clipboard api events
beforecopy
beforecut
beforepaste
copy
cut
paste

contacts api events
contactchange
error
success

css font loading api events
loading
loadingdone
loadingerror

cssom events
animationend
animationiteration
animationstart
transitionend

cssom view events
resize
scroll

device orientation events
compassneedscalibration
devicemotion
deviceorientation

device storage api events
change

dom events
abort
beforeinput
blur
click
compositionend
compositionstart
compositionupdate
dblclick
error
focus
focusin
focusout
input
keydown
keypress
keyup
load
mousedown
mouseenter
mouseleave
mousemove
mouseout
mouseover
mouseup
resize
scroll
select
unload
wheel

download api events
statechange

encrypted media extensions events
encrypted
keystatuschange
message
waitingforkey

engineering mode api events
message

file api events
abort
error
load
loadend
loadstart
progress

file system api events
error
writeend

fmradio api events
antennaavailablechange
disabled
enabled
frequencychange

fullscreen api events
fullscreenchange
fullscreenerror

gamepad api events
gamepadconnected
gamepaddisconnected

html dom events
domcontentloaded
abort
afterprint
afterscriptexecute
beforeprint
beforescriptexecute
beforeunload
blur
cancel
canplay
canplaythrough
change
click
close
connect
contextmenu
durationchange
emptied
error
focus
hashchange
input
invalid
languagechange
load
loadeddata
loadedmetadata
loadend
loadstart
message
offline
online
open

pagehide
pageshow
play
playing
popstate
progress
readystatechange
rejectionhandled
reset
seeked
seeking
select
show
sort
stalled
storage
submit
suspend
timeupdate
toggle
unhandledrejection
unload
volumechange
waiting

html drag and drop api events
drag
dragend
dragenter
dragexit
dragleave
dragover
dragstart
drop

indexeddb events
abort
blocked
close
complete
error
success
upgradeneeded
versionchange

inter-app connection api events
message

media capture and streams events
active
addtrack
devicechange
ended
inactive
mute
overconstrained
ratechange
removetrack
started
unmute

media source extensions events
abort
addsourcebuffer
error
removesourcebuffer
sourceclose
sourceended
sourceopen
update
updateend
updatestart

mediastream recording events
dataavailable
error
pause
resume
首页
stop

mobile connection api events
cardstatechange
icccardlockerror

mobile messaging api events
close
deliveryerror
deliverysuccess
error
failed
message
open
received
retrieving
sending
sent

network information api events
change

page visibility api events
visibilitychange

payment request api events
shippingaddresschange
shippingoptionchange

performance api events
resourcetimingbufferfull

pointer events
gotpointercapture
lostpointercapture
pointercancel
pointerdown
pointerenter
pointerleave
pointermove
pointerout
pointerover
pointerup

pointer lock api events
pointerlockchange
pointerlockerror

presentation api events
change
sessionavailable
sessionconnect

proximity events
deviceproximity
userproximity

push api events
push
pushsubscriptionchange

screen orientation api events
change

selection api events
selectionchange
selectstart

server sent events
error
message
open

service workers api events
activate
controllerchange
error
fetch
install
message
statechange
updatefound

settings api events
settingchange

simple push api events
error
success

speaker manager api events
speakerforcedchange

svg events
domattrmodified
domcharacterdatamodified
domnodeinserted
domnodeinsertedintodocument
domnoderemoved
domnoderemovedfromdocument
domsubtreemodified
svgabort
svgerror
svgload
svgresize
svgscroll
svgunload
svgzoom
activate
beginevent
click
endevent
focusin
focusout
mousedown
mousemove
mouseout
mouseover
mouseup
repeatevent

tcp socket api events
connect
data
drain
error

time and clock api events
moztimechange

touch events
touchcancel
touchend
touchmove
touchstart

tv api events
currentchannelchanged
currentsourcechanged
eitbroadcasted
scanningstatechanged

udp socket api events
message

web audio api events
audioprocess
complete
ended
loaded
message
nodecreate
statechange

web components events
slotchange

webgl events
webglcontextcreationerror
webglcontextlost
webglcontextrestored

web manifest events
install

web midi api events
midimessage
statechange

web notifications events
click
close
error
show

webrtc events
addstream
close
datachannel
error
icecandidate
iceconnectionstatechange
icegatheringstatechange
identityresult
idpassertionerror
idpvalidationerror
isolationchange
message
negotiationneeded
open
peeridentity
removestream
signalingstatechange
tonechange
websockets api events
close
error
message
open

web speech api events
audioend
audiostart
boundary
end_(speechrecognition)
end_(speechsynthesis)
error_(speechrecognitionerror)
error_(speechsynthesis)
mark
nomatch
pause_(speechsynthesis)
result
resume
soundend
soundstart
speechend
speechstart
start_(speechrecognition)
start_(speechsynthesis)

web storage api events
storage

web telephony api events
incoming

webvr api events
vrdisplayactivate
vrdisplayblur
vrdisplayconnected
vrdisplaydeactivate
vrdisplaydisconnected
vrdisplayfocus
vrdisplaypresentchange

webvtt events
addtrack
change
cuechange
enter
exit
removetrack

wifi information api events
connectioninfoupdate
statuschange

wifi p2p api events
disabled
enabled
peerinfoupdate
statuschange

xmlhttprequest events
abort
error
load
loadend
loadstart
progress
readystatechange
timeout</code></pre>

      </div>

      <div class="calibreToc">
        <h2>
          <a href="../../54m0dfqx.html">Table of contents
          </a>
        </h2>
        <div>
          <ul>
            <li>
              <a href="part0002.html#nav_point_0">版权声明</a>
            </li>
            <li>
              <a href="part0003.html#nav_point_1">献词</a>
            </li>
            <li>
              <a href="part0004.html#nav_point_2">译者序</a>
            </li>
            <li>
              <a href="part0005.html#nav_point_3">序</a>
            </li>
            <li>
              <a href="part0006.html#nav_point_4">前言</a>
            </li>
            <li>
              <a href="part0012.html#nav_point_10">致谢</a>
            </li>
            <li>
              <a href="part0013.html#nav_point_11">第 1 章 什么是JavaScript</a>
            </li>
            <li>
              <a href="part0018.html#nav_point_19">第 2 章 HTML中的JavaScript</a>
            </li>
            <li>
              <a href="part0024.html#nav_point_31">第 3 章 语言基础</a>
            </li>
            <li>
              <a href="part0033.html#nav_point_78">第 4 章 变量、作用域与内存</a>
            </li>
            <li>
              <a href="part0038.html#nav_point_93">第 5 章 基本引用类型</a>
            </li>
            <li>
              <a href="part0044.html#nav_point_111">第 6 章 集合引用类型</a>
            </li>
            <li>
              <a href="part0054.html#nav_point_153">第 7 章 迭代器与生成器</a>
            </li>
            <li>
              <a href="part0059.html#nav_point_166">第 8 章 对象、类与面向对象编程</a>
            </li>
            <li>
              <a href="part0065.html#nav_point_194">第 9 章 代理与反射</a>
            </li>
            <li>
              <a href="part0070.html#nav_point_225">第 10 章 函数</a>
            </li>
            <li>
              <a href="part0088.html#nav_point_258">第 11 章 期约与异步函数</a>
            </li>
            <li>
              <a href="part0093.html#nav_point_273">第 12 章 BOM</a>
            </li>
            <li>
              <a href="part0100.html#nav_point_294">第 13 章 客户端检测</a>
            </li>
            <li>
              <a href="part0105.html#nav_point_306">第 14 章 DOM</a>
            </li>
            <li>
              <a href="part0110.html#nav_point_328">第 15 章 DOM扩展</a>
            </li>
            <li>
              <a href="part0116.html#nav_point_348">第 16 章 DOM2和DOM3</a>
            </li>
            <li>
              <a href="part0122.html#nav_point_370">第 17 章 事件</a>
            </li>
            <li>
              <a href="part0130.html#nav_point_403">第 18 章 动画与Canvas图形</a>
            </li>
            <li>
              <a href="part0136.html#nav_point_428">第 19 章 表单脚本</a>
            </li>
            <li>
              <a href="part0143.html#nav_point_450">第 20 章 JavaScript API</a>
            </li>
            <li>
              <a href="part0157.html#nav_point_500">第 21 章 错误处理与调试</a>
            </li>
            <li>
              <a href="part0163.html#nav_point_526">第 22 章 处理XML</a>
            </li>
            <li>
              <a href="part0168.html#nav_point_542">第 23 章 JSON</a>
            </li>
            <li>
              <a href="part0172.html#nav_point_552">第 24 章 网络请求与远程资源</a>
            </li>
            <li>
              <a href="part0182.html#nav_point_582">第 25 章 客户端存储</a>
            </li>
            <li>
              <a href="part0187.html#nav_point_607">第 26 章 模块</a>
            </li>
            <li>
              <a href="part0193.html#nav_point_633">第 27 章 工作者线程</a>
            </li>
            <li>
              <a href="part0199.html#nav_point_667">第 28 章 最佳实践</a>
            </li>
            <li>
              <a href="part0204.html#nav_point_683">附录 A ES2018和ES2019</a>
            </li>
            <li>
              <a href="part0215.html#nav_point_708">附录 B 严格模式</a>
            </li>
            <li>
              <a href="part0223.html#nav_point_719">附录 C JavaScript库和框架</a>
            </li>
            <li>
              <a href="part0227.html#nav_point_741">附录 D JavaScript工具</a>
            </li>
            <li>
              <a href="part0239.html#nav_point_800">作者简介</a>
            </li>
          </ul>
        </div>

      </div>

      <div class="calibreEbNav">

        <a href="part0125.html" class="calibreAPrev">上一页
        </a>

        <a href="../../54m0dfqx.html" class="calibreAHome">首页
        </a>

        <a href="part0127.html" class="calibreANext">下一页
        </a>

      </div>

    </div>

    <script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6487844781006261" crossorigin="anonymous"></script>
  </body>
</html>